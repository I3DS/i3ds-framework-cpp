/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Radar.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RadarMeasurement400K_validity_Initialize(RadarMeasurement400K_validity* pVal)
{
  *pVal = (RadarMeasurement400K_validity)
  {
    .nCount = 1,    .arr =
    {
      depth_valid
    }
  };
}
#endif


flag RadarMeasurement400K_validity_IsConstraintValid(const RadarMeasurement400K_validity* pVal, int* pErrCode)
{

  flag ret = TRUE;
  int i1=0;
  *pErrCode=0;

  (void)pVal;

  ret = (1 <= pVal->nCount && pVal->nCount <= 400000);
  *pErrCode = ret ? 0 : ERR_RadarMeasurement400K_validity;
  i1 = 0;
  while (ret && (i1< pVal->nCount))
    {
      ret = Depth_validity_t_IsConstraintValid(&pVal->arr[i1], pErrCode);
      i1 = i1+1;
    }

  return ret;
}

flag RadarMeasurement400K_validity_Encode(const RadarMeasurement400K_validity* pVal, BitStream* pBitStrm, int* pErrCode,
    flag bCheckConstraints)
{
  flag ret = TRUE;
  int i1=0;

  ret = bCheckConstraints ? RadarMeasurement400K_validity_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      {
        asn1SccSint nCount1 = pVal->nCount;
        asn1SccSint curBlockSize1 = 0;
        asn1SccSint curItem1 = 0;
        while (nCount1 >= 0x4000)
          {
            if (nCount1 >= 0x10000)
              {
                curBlockSize1 = 0x10000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC4, 0, 0xFF);
              }
            else if (nCount1 >= 0xC000)
              {
                curBlockSize1 = 0xC000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC3, 0, 0xFF);
              }
            else if (nCount1 >= 0x8000)
              {
                curBlockSize1 = 0x8000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC2, 0, 0xFF);
              }
            else
              {
                curBlockSize1 = 0x4000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC1, 0, 0xFF);
              }

            for(i1=(int)curItem1; i1 < curBlockSize1 + curItem1; i1++)
              {
                ret = Depth_validity_t_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
              }
            curItem1 += curBlockSize1;
            nCount1 -= curBlockSize1;
          }

        if (nCount1 <= 0x7F)
          {
            BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount1, 0, 0xFF);
          }
        else
          {
            BitStream_AppendBit(pBitStrm, 1);
            BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount1, 0, 0x7FFF);
          }

        for(i1=(int)curItem1; i1 < curItem1 + nCount1; i1++)
          {
            ret = Depth_validity_t_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
          }
      }
    }

  return ret;
}

flag RadarMeasurement400K_validity_Decode(RadarMeasurement400K_validity* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;
  int i1=0;

  {
    asn1SccSint nCount1 = 0;
    asn1SccSint curBlockSize1 = 0;
    asn1SccSint curItem1 = 0;
    pVal->nCount = 0;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount1, 0, 0xFF);
    *pErrCode = ret ? 0 : 272367617;
    if (ret)
      {
        while(ret && (nCount1 & 0xC0)==0xC0)
          {
            if (nCount1 == 0xC4)
              {
                curBlockSize1 = 0x10000;
              }
            else if (nCount1 == 0xC3)
              {
                curBlockSize1 = 0xC000;
              }
            else if (nCount1 == 0xC2)
              {
                curBlockSize1 = 0x8000;
              }
            else if (nCount1 == 0xC1)
              {
                curBlockSize1 = 0x4000;
              }
            else
              {
                *pErrCode = 540803073;
                return FALSE;
              }
            if (curItem1 + curBlockSize1 > 400000)
              {
                *pErrCode = 272367618;
                return FALSE;
              }

            for(i1=curItem1; ret && (i1 < curItem1 + curBlockSize1) ; i1++)
              {
                ret = Depth_validity_t_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
              }

            if (ret)
              {
                pVal->nCount += (long)curBlockSize1;
                curItem1 += curBlockSize1;
                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount1, 0, 0xFF);
                *pErrCode = ret ? 0 : 272367619;
              }
          }
        if (ret)
          {
            if ( (nCount1 & 0x80)>0)
              {
                asn1SccSint len2;
                nCount1 <<= 8;
                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF);
                *pErrCode = ret ? 0 : 272367620;
                if (ret)
                  {
                    nCount1 |= len2;
                    nCount1 &= 0x7FFF;
                  }
              }
            ret = ret && (curItem1 + nCount1 <= 400000);
            *pErrCode = ret ? 0 : 272367621;
            if (ret)
              {
                for(i1=curItem1; ret && (i1 < curItem1 + nCount1) ; i1++)
                  {
                    ret = Depth_validity_t_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
                  }
                if (ret)
                  {
                    pVal->nCount += (long)nCount1;
                  }
              }
          }
      }
  }

  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RadarMeasurement400K_distances_Initialize(RadarMeasurement400K_distances* pVal)
{
  *pVal = (RadarMeasurement400K_distances)
  {
    .nCount = 1,    .arr =
    {
      0.00000000000000000000E+000
    }
  };
}
#endif


flag RadarMeasurement400K_distances_IsConstraintValid(const RadarMeasurement400K_distances* pVal, int* pErrCode)
{

  flag ret = TRUE;
  int i1=0;
  *pErrCode=0;

  (void)pVal;

  ret = (1 <= pVal->nCount && pVal->nCount <= 400000);
  *pErrCode = ret ? 0 : ERR_RadarMeasurement400K_distances;
  i1 = 0;
  while (ret && (i1< pVal->nCount))
    {
      ret = T_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
      i1 = i1+1;
    }

  return ret;
}

flag RadarMeasurement400K_distances_Encode(const RadarMeasurement400K_distances* pVal, BitStream* pBitStrm,
    int* pErrCode, flag bCheckConstraints)
{
  flag ret = TRUE;
  int i1=0;

  ret = bCheckConstraints ? RadarMeasurement400K_distances_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      {
        asn1SccSint nCount1 = pVal->nCount;
        asn1SccSint curBlockSize1 = 0;
        asn1SccSint curItem1 = 0;
        while (nCount1 >= 0x4000)
          {
            if (nCount1 >= 0x10000)
              {
                curBlockSize1 = 0x10000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC4, 0, 0xFF);
              }
            else if (nCount1 >= 0xC000)
              {
                curBlockSize1 = 0xC000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC3, 0, 0xFF);
              }
            else if (nCount1 >= 0x8000)
              {
                curBlockSize1 = 0x8000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC2, 0, 0xFF);
              }
            else
              {
                curBlockSize1 = 0x4000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC1, 0, 0xFF);
              }

            for(i1=(int)curItem1; i1 < curBlockSize1 + curItem1; i1++)
              {
                ret = T_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
              }
            curItem1 += curBlockSize1;
            nCount1 -= curBlockSize1;
          }

        if (nCount1 <= 0x7F)
          {
            BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount1, 0, 0xFF);
          }
        else
          {
            BitStream_AppendBit(pBitStrm, 1);
            BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount1, 0, 0x7FFF);
          }

        for(i1=(int)curItem1; i1 < curItem1 + nCount1; i1++)
          {
            ret = T_Float_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
          }
      }
    }

  return ret;
}

flag RadarMeasurement400K_distances_Decode(RadarMeasurement400K_distances* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;
  int i1=0;

  {
    asn1SccSint nCount1 = 0;
    asn1SccSint curBlockSize1 = 0;
    asn1SccSint curItem1 = 0;
    pVal->nCount = 0;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount1, 0, 0xFF);
    *pErrCode = ret ? 0 : 272367622;
    if (ret)
      {
        while(ret && (nCount1 & 0xC0)==0xC0)
          {
            if (nCount1 == 0xC4)
              {
                curBlockSize1 = 0x10000;
              }
            else if (nCount1 == 0xC3)
              {
                curBlockSize1 = 0xC000;
              }
            else if (nCount1 == 0xC2)
              {
                curBlockSize1 = 0x8000;
              }
            else if (nCount1 == 0xC1)
              {
                curBlockSize1 = 0x4000;
              }
            else
              {
                *pErrCode = 540803074;
                return FALSE;
              }
            if (curItem1 + curBlockSize1 > 400000)
              {
                *pErrCode = 272367623;
                return FALSE;
              }

            for(i1=curItem1; ret && (i1 < curItem1 + curBlockSize1) ; i1++)
              {
                ret = T_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
              }

            if (ret)
              {
                pVal->nCount += (long)curBlockSize1;
                curItem1 += curBlockSize1;
                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount1, 0, 0xFF);
                *pErrCode = ret ? 0 : 272367624;
              }
          }
        if (ret)
          {
            if ( (nCount1 & 0x80)>0)
              {
                asn1SccSint len2;
                nCount1 <<= 8;
                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF);
                *pErrCode = ret ? 0 : 272367625;
                if (ret)
                  {
                    nCount1 |= len2;
                    nCount1 &= 0x7FFF;
                  }
              }
            ret = ret && (curItem1 + nCount1 <= 400000);
            *pErrCode = ret ? 0 : 272367626;
            if (ret)
              {
                for(i1=curItem1; ret && (i1 < curItem1 + nCount1) ; i1++)
                  {
                    ret = T_Float_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
                  }
                if (ret)
                  {
                    pVal->nCount += (long)nCount1;
                  }
              }
          }
      }
  }

  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RadarMeasurement400K_Initialize(RadarMeasurement400K* pVal)
{
  *pVal = (RadarMeasurement400K)
  {
    .attributes =
    {
      .timestamp = -9223372036854775807LL,
      .validity = sample_empty,
      .attributes = {
        .nCount = 0,    .arr =
        {

        }
      }
    },
    .distances = {    .nCount = 1,    .arr =
      {
        0.00000000000000000000E+000
      }
    },
    .validity = {    .nCount = 1,    .arr =
      {
        depth_valid
      }
    },
    .region =
    {
      .offset_x = 0,
      .offset_y = 0,
      .size_x = 0,
      .size_y = 0
    }
  };
}
#endif


flag RadarMeasurement400K_IsConstraintValid(const RadarMeasurement400K* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = SampleAttributes_IsConstraintValid(&pVal->attributes, pErrCode);
  if (ret)
    {
      ret = RadarMeasurement400K_distances_IsConstraintValid(&pVal->distances, pErrCode);
      if (ret)
        {
          ret = RadarMeasurement400K_validity_IsConstraintValid(&pVal->validity, pErrCode);
          if (ret)
            {
              ret = PlanarRegion_IsConstraintValid(&pVal->region, pErrCode);

            }
        }
    }

  return ret;
}

flag RadarMeasurement400K_Encode(const RadarMeasurement400K* pVal, BitStream* pBitStrm, int* pErrCode,
                                 flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? RadarMeasurement400K_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode attributes */
      ret = SampleAttributes_Encode(&pVal->attributes, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode distances */
          ret = RadarMeasurement400K_distances_Encode(&pVal->distances, pBitStrm, pErrCode, FALSE);
          if (ret)
            {
              /*Encode validity */
              ret = RadarMeasurement400K_validity_Encode(&pVal->validity, pBitStrm, pErrCode, FALSE);
              if (ret)
                {
                  /*Encode region */
                  ret = PlanarRegion_Encode(&pVal->region, pBitStrm, pErrCode, FALSE);

                }
            }
        }
    }

  return ret;
}

flag RadarMeasurement400K_Decode(RadarMeasurement400K* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode attributes */
  ret = SampleAttributes_Decode(&pVal->attributes, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode distances */
      ret = RadarMeasurement400K_distances_Decode(&pVal->distances, pBitStrm, pErrCode);
      if (ret)
        {
          /*Decode validity */
          ret = RadarMeasurement400K_validity_Decode(&pVal->validity, pBitStrm, pErrCode);
          if (ret)
            {
              /*Decode region */
              ret = PlanarRegion_Decode(&pVal->region, pBitStrm, pErrCode);

            }
        }
    }


  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RadarRegion_Initialize(RadarRegion* pVal)
{
  *pVal = (RadarRegion)
  {
    .enable = FALSE,
     .region =
    {
      .offset_x = 0,
      .offset_y = 0,
      .size_x = 0,
      .size_y = 0
    }
  };
}
#endif


flag RadarRegion_IsConstraintValid(const RadarRegion* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = T_Boolean_IsConstraintValid(&pVal->enable, pErrCode);
  if (ret)
    {
      ret = PlanarRegion_IsConstraintValid(&pVal->region, pErrCode);

    }

  return ret;
}

flag RadarRegion_Encode(const RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? RadarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode enable */
      ret = T_Boolean_Encode(&pVal->enable, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode region */
          ret = PlanarRegion_Encode(&pVal->region, pBitStrm, pErrCode, FALSE);

        }
    }

  return ret;
}

flag RadarRegion_Decode(RadarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode enable */
  ret = T_Boolean_Decode(&pVal->enable, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode region */
      ret = PlanarRegion_Decode(&pVal->region, pBitStrm, pErrCode);

    }


  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void RadarConfiguration_Initialize(RadarConfiguration* pVal)
{
  *pVal = (RadarConfiguration)
  {
    .region_enabled = FALSE,
     .region =
    {
      .offset_x = 0,
      .offset_y = 0,
      .size_x = 0,
      .size_y = 0
    }
  };
}
#endif


flag RadarConfiguration_IsConstraintValid(const RadarConfiguration* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = T_Boolean_IsConstraintValid(&pVal->region_enabled, pErrCode);
  if (ret)
    {
      ret = PlanarRegion_IsConstraintValid(&pVal->region, pErrCode);

    }

  return ret;
}

flag RadarConfiguration_Encode(const RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode,
                               flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? RadarConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode region_enabled */
      ret = T_Boolean_Encode(&pVal->region_enabled, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode region */
          ret = PlanarRegion_Encode(&pVal->region, pBitStrm, pErrCode, FALSE);

        }
    }

  return ret;
}

flag RadarConfiguration_Decode(RadarConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode region_enabled */
  ret = T_Boolean_Decode(&pVal->region_enabled, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode region */
      ret = PlanarRegion_Decode(&pVal->region, pBitStrm, pErrCode);

    }


  return ret;
}

