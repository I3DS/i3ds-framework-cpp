/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Eigen.h"



void Affine3d_elem_Initialize(Affine3d_elem* pVal)
{
    int i2;

	i2 = 0;
	while (i2< 4) {
	    T_Double_Initialize((&(pVal->arr[i2])));
	    i2 = i2 + 1;
	}
	pVal->nCount = 1;
}
void Affine3d_Initialize(Affine3d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    Affine3d_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Affine3d_IsConstraintValid(const Affine3d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_AFFINE3D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].nCount) && (pVal->arr[i1].nCount <= 4));
        	*pErrCode = ret ? 0 :  ERR_AFFINE3D_ELM; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].arr[i2]) && (pVal->arr[i1].arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_AFFINE3D_ELM_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag Affine3d_Encode(const Affine3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? Affine3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].nCount, 1, 4);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
	    	{
	    		ret = T_Double_Encode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Affine3d_Decode(Affine3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_AFFINE3D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_AFFINE3D_ELM;
		pVal->arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
		{
			ret = T_Double_Decode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode);
		}
	}

	return ret  && Affine3d_IsConstraintValid(pVal, pErrCode);
}



void Matrix6d_elem_Initialize(Matrix6d_elem* pVal)
{
    int i2;

	i2 = 0;
	while (i2< 6) {
	    T_Double_Initialize((&(pVal->arr[i2])));
	    i2 = i2 + 1;
	}
	pVal->nCount = 1;
}
void Matrix6d_Initialize(Matrix6d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 6) {
	    Matrix6d_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Matrix6d_IsConstraintValid(const Matrix6d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 6));
    *pErrCode = ret ? 0 :  ERR_MATRIX6D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].nCount) && (pVal->arr[i1].nCount <= 6));
        	*pErrCode = ret ? 0 :  ERR_MATRIX6D_ELM; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].arr[i2]) && (pVal->arr[i1].arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_MATRIX6D_ELM_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag Matrix6d_Encode(const Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? Matrix6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 6);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].nCount, 1, 6);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
	    	{
	    		ret = T_Double_Encode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Matrix6d_Decode(Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIX6D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIX6D_ELM;
		pVal->arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
		{
			ret = T_Double_Decode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode);
		}
	}

	return ret  && Matrix6d_IsConstraintValid(pVal, pErrCode);
}



void Matrix3d_elem_Initialize(Matrix3d_elem* pVal)
{
    int i2;

	i2 = 0;
	while (i2< 3) {
	    T_Double_Initialize((&(pVal->arr[i2])));
	    i2 = i2 + 1;
	}
	pVal->nCount = 1;
}
void Matrix3d_Initialize(Matrix3d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    Matrix3d_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Matrix3d_IsConstraintValid(const Matrix3d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_MATRIX3D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].nCount) && (pVal->arr[i1].nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_MATRIX3D_ELM; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].arr[i2]) && (pVal->arr[i1].arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_MATRIX3D_ELM_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag Matrix3d_Encode(const Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? Matrix3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].nCount, 1, 3);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
	    	{
	    		ret = T_Double_Encode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Matrix3d_Decode(Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIX3D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIX3D_ELM;
		pVal->arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
		{
			ret = T_Double_Decode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode);
		}
	}

	return ret  && Matrix3d_IsConstraintValid(pVal, pErrCode);
}



void Vector6d_Initialize(Vector6d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 6) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Vector6d_IsConstraintValid(const Vector6d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 6));
    *pErrCode = ret ? 0 :  ERR_VECTOR6D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1]) && (pVal->arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_VECTOR6D_ELM; 
        }
    }

	return ret;
}

flag Vector6d_Encode(const Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Vector6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 6);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Vector6d_Decode(Vector6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_VECTOR6D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Vector6d_IsConstraintValid(pVal, pErrCode);
}



void Vector3d_Initialize(Vector3d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Vector3d_IsConstraintValid(const Vector3d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_VECTOR3D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1]) && (pVal->arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_VECTOR3D_ELM; 
        }
    }

	return ret;
}

flag Vector3d_Encode(const Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Vector3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Vector3d_Decode(Vector3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_VECTOR3D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Vector3d_IsConstraintValid(pVal, pErrCode);
}



void MatrixXd_elem_Initialize(MatrixXd_elem* pVal)
{
    int i2;

	i2 = 0;
	while (i2< 20) {
	    T_Double_Initialize((&(pVal->arr[i2])));
	    i2 = i2 + 1;
	}
	pVal->nCount = 1;
}
void MatrixXd_Initialize(MatrixXd* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 20) {
	    MatrixXd_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag MatrixXd_IsConstraintValid(const MatrixXd* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 20));
    *pErrCode = ret ? 0 :  ERR_MATRIXXD; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].nCount) && (pVal->arr[i1].nCount <= 20));
        	*pErrCode = ret ? 0 :  ERR_MATRIXXD_ELM; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].arr[i2]) && (pVal->arr[i1].arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_MATRIXXD_ELM_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag MatrixXd_Encode(const MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? MatrixXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 20);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].nCount, 1, 20);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
	    	{
	    		ret = T_Double_Encode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag MatrixXd_Decode(MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 20);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIXXD;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 20);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIXXD_ELM;
		pVal->arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
		{
			ret = T_Double_Decode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode);
		}
	}

	return ret  && MatrixXd_IsConstraintValid(pVal, pErrCode);
}



void Quaterniond_Initialize(Quaterniond* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Quaterniond_IsConstraintValid(const Quaterniond* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_QUATERNIOND; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1]) && (pVal->arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_QUATERNIOND_ELM; 
        }
    }

	return ret;
}

flag Quaterniond_Encode(const Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Quaterniond_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Quaterniond_Decode(Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_QUATERNIOND;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Quaterniond_IsConstraintValid(pVal, pErrCode);
}



void VectorXd_Initialize(VectorXd* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 100) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag VectorXd_IsConstraintValid(const VectorXd* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 100));
    *pErrCode = ret ? 0 :  ERR_VECTORXD; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1]) && (pVal->arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_VECTORXD_ELM; 
        }
    }

	return ret;
}

flag VectorXd_Encode(const VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? VectorXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 100);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag VectorXd_Decode(VectorXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 100);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_VECTORXD;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && VectorXd_IsConstraintValid(pVal, pErrCode);
}



void Isometry3d_elem_Initialize(Isometry3d_elem* pVal)
{
    int i2;

	i2 = 0;
	while (i2< 4) {
	    T_Double_Initialize((&(pVal->arr[i2])));
	    i2 = i2 + 1;
	}
	pVal->nCount = 1;
}
void Isometry3d_Initialize(Isometry3d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    Isometry3d_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Isometry3d_IsConstraintValid(const Isometry3d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_ISOMETRY3D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].nCount) && (pVal->arr[i1].nCount <= 4));
        	*pErrCode = ret ? 0 :  ERR_ISOMETRY3D_ELM; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].arr[i2]) && (pVal->arr[i1].arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_ISOMETRY3D_ELM_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag Isometry3d_Encode(const Isometry3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? Isometry3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].nCount, 1, 4);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
	    	{
	    		ret = T_Double_Encode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Isometry3d_Decode(Isometry3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ISOMETRY3D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_ISOMETRY3D_ELM;
		pVal->arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
		{
			ret = T_Double_Decode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode);
		}
	}

	return ret  && Isometry3d_IsConstraintValid(pVal, pErrCode);
}



void Matrix2d_elem_Initialize(Matrix2d_elem* pVal)
{
    int i2;

	i2 = 0;
	while (i2< 2) {
	    T_Double_Initialize((&(pVal->arr[i2])));
	    i2 = i2 + 1;
	}
	pVal->nCount = 1;
}
void Matrix2d_Initialize(Matrix2d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 2) {
	    Matrix2d_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Matrix2d_IsConstraintValid(const Matrix2d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 2));
    *pErrCode = ret ? 0 :  ERR_MATRIX2D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].nCount) && (pVal->arr[i1].nCount <= 2));
        	*pErrCode = ret ? 0 :  ERR_MATRIX2D_ELM; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].arr[i2]) && (pVal->arr[i1].arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_MATRIX2D_ELM_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag Matrix2d_Encode(const Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? Matrix2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 2);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].nCount, 1, 2);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
	    	{
	    		ret = T_Double_Encode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Matrix2d_Decode(Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIX2D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIX2D_ELM;
		pVal->arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
		{
			ret = T_Double_Decode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode);
		}
	}

	return ret  && Matrix2d_IsConstraintValid(pVal, pErrCode);
}



void Vector2d_Initialize(Vector2d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Vector2d_IsConstraintValid(const Vector2d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_VECTOR2D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1]) && (pVal->arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_VECTOR2D_ELM; 
        }
    }

	return ret;
}

flag Vector2d_Encode(const Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Vector2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Vector2d_Decode(Vector2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_VECTOR2D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Vector2d_IsConstraintValid(pVal, pErrCode);
}



void Matrix4d_elem_Initialize(Matrix4d_elem* pVal)
{
    int i2;

	i2 = 0;
	while (i2< 4) {
	    T_Double_Initialize((&(pVal->arr[i2])));
	    i2 = i2 + 1;
	}
	pVal->nCount = 1;
}
void Matrix4d_Initialize(Matrix4d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    Matrix4d_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Matrix4d_IsConstraintValid(const Matrix4d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_MATRIX4D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].nCount) && (pVal->arr[i1].nCount <= 4));
        	*pErrCode = ret ? 0 :  ERR_MATRIX4D_ELM; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].arr[i2]) && (pVal->arr[i1].arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_MATRIX4D_ELM_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag Matrix4d_Encode(const Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? Matrix4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].nCount, 1, 4);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
	    	{
	    		ret = T_Double_Encode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Matrix4d_Decode(Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIX4D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_MATRIX4D_ELM;
		pVal->arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
		{
			ret = T_Double_Decode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode);
		}
	}

	return ret  && Matrix4d_IsConstraintValid(pVal, pErrCode);
}



void Transform3d_elem_Initialize(Transform3d_elem* pVal)
{
    int i2;

	i2 = 0;
	while (i2< 4) {
	    T_Double_Initialize((&(pVal->arr[i2])));
	    i2 = i2 + 1;
	}
	pVal->nCount = 1;
}
void Transform3d_Initialize(Transform3d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    Transform3d_elem_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Transform3d_IsConstraintValid(const Transform3d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_TRANSFORM3D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].nCount) && (pVal->arr[i1].nCount <= 4));
        	*pErrCode = ret ? 0 :  ERR_TRANSFORM3D_ELM; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].arr[i2]) && (pVal->arr[i1].arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_TRANSFORM3D_ELM_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag Transform3d_Encode(const Transform3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	int i2;
	ret = bCheckConstraints ? Transform3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->arr[i1].nCount, 1, 4);
	    		
	    	for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
	    	{
	    		ret = T_Double_Encode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode, FALSE);
	    	}
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Transform3d_Decode(Transform3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;
	int i2;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSFORM3D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRANSFORM3D_ELM;
		pVal->arr[i1].nCount = (long)nCount;
			
		for(i2=0; (i2 < (int)pVal->arr[i1].nCount) && ret; i2++) 
		{
			ret = T_Double_Decode((&(pVal->arr[i1].arr[i2])), pBitStrm, pErrCode);
		}
	}

	return ret  && Transform3d_IsConstraintValid(pVal, pErrCode);
}



void Vector4d_Initialize(Vector4d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Vector4d_IsConstraintValid(const Vector4d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_VECTOR4D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1]) && (pVal->arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_VECTOR4D_ELM; 
        }
    }

	return ret;
}

flag Vector4d_Encode(const Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Vector4d_Decode(Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_VECTOR4D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Vector4d_IsConstraintValid(pVal, pErrCode);
}



void AngleAxisd_Initialize(AngleAxisd* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag AngleAxisd_IsConstraintValid(const AngleAxisd* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_ANGLEAXISD; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1]) && (pVal->arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_ANGLEAXISD_ELM; 
        }
    }

	return ret;
}

flag AngleAxisd_Encode(const AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? AngleAxisd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag AngleAxisd_Decode(AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ANGLEAXISD;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && AngleAxisd_IsConstraintValid(pVal, pErrCode);
}

