/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "taste-extended.h"

const T_UInt32 numT_String = 40;


void T_Time_Initialize(T_Time* pVal)
{


	/*set secs */
	T_UInt32_Initialize((&(pVal->secs)));
	/*set nsecs */
	T_UInt32_Initialize((&(pVal->nsecs)));
}

flag T_Time_IsConstraintValid(const T_Time* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->secs <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_TIME_SECS; 
    if (ret) {
        ret = (pVal->nsecs <= 4294967295UL);
        *pErrCode = ret ? 0 :  ERR_T_TIME_NSECS; 
    }

	return ret;
}

flag T_Time_Encode(const T_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? T_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode secs */
	    ret = T_UInt32_Encode((&(pVal->secs)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode nsecs */
	        ret = T_UInt32_Encode((&(pVal->nsecs)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Time_Decode(T_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode secs */
	ret = T_UInt32_Decode((&(pVal->secs)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode nsecs */
	    ret = T_UInt32_Decode((&(pVal->nsecs)), pBitStrm, pErrCode);
	}

	return ret  && T_Time_IsConstraintValid(pVal, pErrCode);
}



void T_Double_Initialize(T_Double* pVal)
{

	(*(pVal)) = 0.00000000000000000000E+000;
}

flag T_Double_IsConstraintValid(const T_Double* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= (*(pVal))) && ((*(pVal)) <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_T_DOUBLE; 

	return ret;
}

flag T_Double_Encode(const T_Double* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? T_Double_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Double_Decode(T_Double* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_DOUBLE;

	return ret  && T_Double_IsConstraintValid(pVal, pErrCode);
}



void T_Float_Initialize(T_Float* pVal)
{

	(*(pVal)) = 0.00000000000000000000E+000;
}

flag T_Float_IsConstraintValid(const T_Float* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= (*(pVal))) && ((*(pVal)) <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_T_FLOAT; 

	return ret;
}

flag T_Float_Encode(const T_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? T_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Float_Decode(T_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;

	return ret  && T_Float_IsConstraintValid(pVal, pErrCode);
}



void T_Int16_Initialize(T_Int16* pVal)
{

	(*(pVal)) = 0;
}

flag T_Int16_IsConstraintValid(const T_Int16* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-32768LL <= (*(pVal))) && ((*(pVal)) <= 32767LL));
    *pErrCode = ret ? 0 :  ERR_T_INT16; 

	return ret;
}

flag T_Int16_Encode(const T_Int16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? T_Int16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -32768, 32767);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int16_Decode(T_Int16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -32768, 32767);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT16;

	return ret  && T_Int16_IsConstraintValid(pVal, pErrCode);
}



void T_UInt16_Initialize(T_UInt16* pVal)
{

	(*(pVal)) = 0;
}

flag T_UInt16_IsConstraintValid(const T_UInt16* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT16; 

	return ret;
}

flag T_UInt16_Encode(const T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? T_UInt16_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 65535);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt16_Decode(T_UInt16* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 65535);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT16;

	return ret  && T_UInt16_IsConstraintValid(pVal, pErrCode);
}



void T_UInt64_Initialize(T_UInt64* pVal)
{

	(*(pVal)) = 0;
}

flag T_UInt64_IsConstraintValid(const T_UInt64* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_UInt64_Encode(const T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? T_UInt64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 18446744073709551615ULL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_UInt64_Decode(T_UInt64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 18446744073709551615ULL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT64;

	return ret  && T_UInt64_IsConstraintValid(pVal, pErrCode);
}



void T_Int64_Initialize(T_Int64* pVal)
{

	(*(pVal)) = 0;
}

flag T_Int64_IsConstraintValid(const T_Int64* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag T_Int64_Encode(const T_Int64* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? T_Int64_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), LLONG_MIN, 9223372036854775807LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_Int64_Decode(T_Int64* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, LLONG_MIN, 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT64;

	return ret  && T_Int64_IsConstraintValid(pVal, pErrCode);
}



void T_String_Initialize(T_String* pVal)
{

	memset(pVal->arr, 0x0, 40);
	pVal->nCount = 0;

}

flag T_String_IsConstraintValid(const T_String* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->nCount <= 40);
    *pErrCode = ret ? 0 :  ERR_T_STRING; 

	return ret;
}

flag T_String_Encode(const T_String* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? T_String_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 40);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_String_Decode(T_String* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 40);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING;
	}

	return ret  && T_String_IsConstraintValid(pVal, pErrCode);
}

