/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "SampleAttribute.h"



void SampleValidity_Initialize(SampleValidity* pVal)
{

	(*(pVal)) = sample_empty;
}

flag SampleValidity_IsConstraintValid(const SampleValidity* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((*(pVal)) == sample_empty)) || (((*(pVal)) == sample_valid)))) || (((*(pVal)) == sample_invalid)));
    *pErrCode = ret ? 0 :  ERR_SAMPLEVALIDITY; 

	return ret;
}

flag SampleValidity_Encode(const SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? SampleValidity_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case sample_empty:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case sample_valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case sample_invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_SAMPLEVALIDITY; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SampleValidity_Decode(SampleValidity* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SAMPLEVALIDITY;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = sample_empty;
	                break;
	            case 1: 
	                (*(pVal)) = sample_valid;
	                break;
	            case 2: 
	                (*(pVal)) = sample_invalid;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_SAMPLEVALIDITY;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = sample_empty;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && SampleValidity_IsConstraintValid(pVal, pErrCode);
}



void T_String8_Initialize(T_String8* pVal)
{

	memset(pVal->arr, 0x0, 8);
	pVal->nCount = 0;

}

flag T_String8_IsConstraintValid(const T_String8* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->nCount <= 8);
    *pErrCode = ret ? 0 :  ERR_T_STRING8; 

	return ret;
}

flag T_String8_Encode(const T_String8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? T_String8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 8);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	BitStream_AppendByte0(pBitStrm, pVal->arr[i1]);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag T_String8_Decode(T_String8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 8);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING8;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = BitStream_ReadByte(pBitStrm, &(pVal->arr[i1])); 
		*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_STRING8;
	}

	return ret  && T_String8_IsConstraintValid(pVal, pErrCode);
}



void Attribute_value_t_Initialize(Attribute_value_t* pVal)
{

	/*set boolean_value*/
	pVal->kind = boolean_value_PRESENT;
	T_Boolean_Initialize((&(pVal->u.boolean_value)));
}

flag Attribute_value_t_IsConstraintValid(const Attribute_value_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    if (pVal->kind == discrete_value_PRESENT) {
    	ret = (-9223372036854775807LL <= pVal->u.discrete_value);
    	*pErrCode = ret ? 0 :  ERR_ATTRIBUTE_VALUE_T_DISCRETE_VALUE; 
    }
    if (ret) {
        if (pVal->kind == real_value_PRESENT) {
        	ret = ((-1.79769313486231570000E+308 <= pVal->u.real_value) && (pVal->u.real_value <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_ATTRIBUTE_VALUE_T_REAL_VALUE; 
        }
        if (ret) {
            if (pVal->kind == string_value_PRESENT) {
            	ret = (pVal->u.string_value.nCount <= 8);
            	*pErrCode = ret ? 0 :  ERR_ATTRIBUTE_VALUE_T_STRING_VALUE; 
            }
        }
    }

	return ret;
}

flag Attribute_value_t_Encode(const Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Attribute_value_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(pVal->kind) 
	    {
	    case boolean_value_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	    	ret = T_Boolean_Encode((&(pVal->u.boolean_value)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case discrete_value_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	    	ret = T_Int64_Encode((&(pVal->u.discrete_value)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case real_value_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	    	ret = T_Double_Encode((&(pVal->u.real_value)), pBitStrm, pErrCode, FALSE);
	    	break;
	    case string_value_PRESENT:
	    	BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	    	ret = T_String8_Encode((&(pVal->u.string_value)), pBitStrm, pErrCode, FALSE);
	    	break;
	    default:                            /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_ENCODE_ATTRIBUTE_VALUE_T;         /*COVERAGE_IGNORE*/
	        ret = FALSE;                    /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Attribute_value_t_Decode(Attribute_value_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint Attribute_value_t_index_tmp;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &Attribute_value_t_index_tmp, 0, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ATTRIBUTE_VALUE_T;
	if (ret) {
	    switch(Attribute_value_t_index_tmp) 
	    {
	    case 0:
	    	pVal->kind = boolean_value_PRESENT;
	    	ret = T_Boolean_Decode((&(pVal->u.boolean_value)), pBitStrm, pErrCode);
	    	break;
	    case 1:
	    	pVal->kind = discrete_value_PRESENT;
	    	ret = T_Int64_Decode((&(pVal->u.discrete_value)), pBitStrm, pErrCode);
	    	break;
	    case 2:
	    	pVal->kind = real_value_PRESENT;
	    	ret = T_Double_Decode((&(pVal->u.real_value)), pBitStrm, pErrCode);
	    	break;
	    case 3:
	    	pVal->kind = string_value_PRESENT;
	    	ret = T_String8_Decode((&(pVal->u.string_value)), pBitStrm, pErrCode);
	    	break;
	    default:                        /*COVERAGE_IGNORE*/
	        *pErrCode = ERR_UPER_DECODE_ATTRIBUTE_VALUE_T;     /*COVERAGE_IGNORE*/
	        ret = FALSE;                /*COVERAGE_IGNORE*/
	    }
	}  /*COVERAGE_IGNORE*/

	return ret  && Attribute_value_t_IsConstraintValid(pVal, pErrCode);
}



void Sample_attribute_t_Initialize(Sample_attribute_t* pVal)
{


	/*set attribute_key */
	T_UInt8_Initialize((&(pVal->attribute_key)));
	/*set attribute_value */
	Attribute_value_t_Initialize((&(pVal->attribute_value)));
}

flag Sample_attribute_t_IsConstraintValid(const Sample_attribute_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->attribute_key <= 255UL);
    *pErrCode = ret ? 0 :  ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_KEY; 
    if (ret) {
        if (pVal->attribute_value.kind == discrete_value_PRESENT) {
        	ret = (-9223372036854775807LL <= pVal->attribute_value.u.discrete_value);
        	*pErrCode = ret ? 0 :  ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_DISCRETE_VALUE; 
        }
        if (ret) {
            if (pVal->attribute_value.kind == real_value_PRESENT) {
            	ret = ((-1.79769313486231570000E+308 <= pVal->attribute_value.u.real_value) && (pVal->attribute_value.u.real_value <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_REAL_VALUE; 
            }
            if (ret) {
                if (pVal->attribute_value.kind == string_value_PRESENT) {
                	ret = (pVal->attribute_value.u.string_value.nCount <= 8);
                	*pErrCode = ret ? 0 :  ERR_SAMPLE_ATTRIBUTE_T_ATTRIBUTE_VALUE_STRING_VALUE; 
                }
            }
        }
    }

	return ret;
}

flag Sample_attribute_t_Encode(const Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Sample_attribute_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode attribute_key */
	    ret = T_UInt8_Encode((&(pVal->attribute_key)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode attribute_value */
	        ret = Attribute_value_t_Encode((&(pVal->attribute_value)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Sample_attribute_t_Decode(Sample_attribute_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode attribute_key */
	ret = T_UInt8_Decode((&(pVal->attribute_key)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode attribute_value */
	    ret = Attribute_value_t_Decode((&(pVal->attribute_value)), pBitStrm, pErrCode);
	}

	return ret  && Sample_attribute_t_IsConstraintValid(pVal, pErrCode);
}



void SampleAttributes_attributes_Initialize(SampleAttributes_attributes* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    Sample_attribute_t_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 0;
}
void SampleAttributes_Initialize(SampleAttributes* pVal)
{


	/*set timestamp */
	T_Int64_Initialize((&(pVal->timestamp)));
	/*set validity */
	SampleValidity_Initialize((&(pVal->validity)));
	/*set attributes */
	SampleAttributes_attributes_Initialize((&(pVal->attributes)));
}

flag SampleAttributes_IsConstraintValid(const SampleAttributes* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = (-9223372036854775807LL <= pVal->timestamp);
    *pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_TIMESTAMP; 
    if (ret) {
        ret = (((((pVal->validity == sample_empty)) || ((pVal->validity == sample_valid)))) || ((pVal->validity == sample_invalid)));
        *pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_VALIDITY; 
        if (ret) {
            ret = (pVal->attributes.nCount <= 4);
            *pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->attributes.nCount; i1++) 
                {
                	ret = (pVal->attributes.arr[i1].attribute_key <= 255UL);
                	*pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY; 
                	if (ret) {
                	    if (pVal->attributes.arr[i1].attribute_value.kind == discrete_value_PRESENT) {
                	    	ret = (-9223372036854775807LL <= pVal->attributes.arr[i1].attribute_value.u.discrete_value);
                	    	*pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE; 
                	    }
                	    if (ret) {
                	        if (pVal->attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
                	        	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
                	        	*pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE; 
                	        }
                	        if (ret) {
                	            if (pVal->attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
                	            	ret = (pVal->attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
                	            	*pErrCode = ret ? 0 :  ERR_SAMPLEATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE; 
                	            }
                	        }
                	    }
                	}
                }
            }
        }
    }

	return ret;
}

flag SampleAttributes_Encode(const SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? SampleAttributes_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode timestamp */
	    ret = Timepoint_Encode((&(pVal->timestamp)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode validity */
	        ret = SampleValidity_Encode((&(pVal->validity)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode attributes */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.nCount, 0, 4);
	            	
	            for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++) 
	            {
	            	ret = Sample_attribute_t_Encode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SampleAttributes_Decode(SampleAttributes* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode timestamp */
	ret = Timepoint_Decode((&(pVal->timestamp)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode validity */
	    ret = SampleValidity_Decode((&(pVal->validity)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode attributes */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 4);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_SAMPLEATTRIBUTES_ATTRIBUTES;
	        pVal->attributes.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++) 
	        {
	        	ret = Sample_attribute_t_Decode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && SampleAttributes_IsConstraintValid(pVal, pErrCode);
}

