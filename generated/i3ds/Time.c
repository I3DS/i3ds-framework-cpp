/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Time.h"



void Time_Initialize(Time* pVal)
{


	/*set microseconds */
	T_Int64_Initialize((&(pVal->microseconds)));
	/*set usecPerSec */
	T_Int32_Initialize((&(pVal->usecPerSec)));
}

flag Time_IsConstraintValid(const Time* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (-9223372036854775807LL <= pVal->microseconds);
    *pErrCode = ret ? 0 :  ERR_TIME_MICROSECONDS; 
    if (ret) {
        ret = ((-2147483648LL <= pVal->usecPerSec) && (pVal->usecPerSec <= 2147483647LL));
        *pErrCode = ret ? 0 :  ERR_TIME_USECPERSEC; 
    }

	return ret;
}

flag Time_Encode(const Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode microseconds */
	    ret = T_Int64_Encode((&(pVal->microseconds)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode usecPerSec */
	        ret = T_Int32_Encode((&(pVal->usecPerSec)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Time_Decode(Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode microseconds */
	ret = T_Int64_Decode((&(pVal->microseconds)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode usecPerSec */
	    ret = T_Int32_Decode((&(pVal->usecPerSec)), pBitStrm, pErrCode);
	}

	return ret  && Time_IsConstraintValid(pVal, pErrCode);
}



void Resolution_Initialize(Resolution* pVal)
{

	(*(pVal)) = seconds;
}

flag Resolution_IsConstraintValid(const Resolution* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((*(pVal)) == seconds)) || (((*(pVal)) == milliseconds)))) || (((*(pVal)) == microseconds)));
    *pErrCode = ret ? 0 :  ERR_RESOLUTION; 

	return ret;
}

flag Resolution_Encode(const Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Resolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case seconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case milliseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case microseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_RESOLUTION; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Resolution_Decode(Resolution* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_RESOLUTION;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = seconds;
	                break;
	            case 1: 
	                (*(pVal)) = milliseconds;
	                break;
	            case 2: 
	                (*(pVal)) = microseconds;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_RESOLUTION;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = seconds;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Resolution_IsConstraintValid(pVal, pErrCode);
}

