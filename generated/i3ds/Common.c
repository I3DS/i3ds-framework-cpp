/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Common.h"



void Timepoint_Initialize(Timepoint* pVal)
{

	T_Int64_Initialize(pVal);
}

flag Timepoint_IsConstraintValid(const Timepoint* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Timepoint_Encode(const Timepoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Timepoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = T_Int64_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Timepoint_Decode(Timepoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = T_Int64_Decode(pVal, pBitStrm, pErrCode);

	return ret  && Timepoint_IsConstraintValid(pVal, pErrCode);
}



void NodeID_Initialize(NodeID* pVal)
{

	(*(pVal)) = 0;
}

flag NodeID_IsConstraintValid(const NodeID* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 16777215UL);
    *pErrCode = ret ? 0 :  ERR_NODEID; 

	return ret;
}

flag NodeID_Encode(const NodeID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? NodeID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag NodeID_Decode(NodeID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_NODEID;

	return ret  && NodeID_IsConstraintValid(pVal, pErrCode);
}



void EndpointID_Initialize(EndpointID* pVal)
{

	(*(pVal)) = 0;
}

flag EndpointID_IsConstraintValid(const EndpointID* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_ENDPOINTID; 

	return ret;
}

flag EndpointID_Encode(const EndpointID* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? EndpointID_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag EndpointID_Decode(EndpointID* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_ENDPOINTID;

	return ret  && EndpointID_IsConstraintValid(pVal, pErrCode);
}



void ResultCode_Initialize(ResultCode* pVal)
{

	(*(pVal)) = success;
}

flag ResultCode_IsConstraintValid(const ResultCode* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((((*(pVal)) == success)) || (((*(pVal)) == error_node_id)))) || (((*(pVal)) == error_endpoint_id)))) || (((*(pVal)) == error_unsupported)))) || (((*(pVal)) == error_state)))) || (((*(pVal)) == error_value)))) || (((*(pVal)) == error_other)));
    *pErrCode = ret ? 0 :  ERR_RESULTCODE; 

	return ret;
}

flag ResultCode_Encode(const ResultCode* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ResultCode_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case success:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 6);
	        	break;
	        case error_node_id:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 6);
	        	break;
	        case error_endpoint_id:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 6);
	        	break;
	        case error_unsupported:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 6);
	        	break;
	        case error_state:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 6);
	        	break;
	        case error_value:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 6);
	        	break;
	        case error_other:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 6);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_RESULTCODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ResultCode_Decode(ResultCode* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 6);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_RESULTCODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = success;
	                break;
	            case 1: 
	                (*(pVal)) = error_node_id;
	                break;
	            case 2: 
	                (*(pVal)) = error_endpoint_id;
	                break;
	            case 3: 
	                (*(pVal)) = error_unsupported;
	                break;
	            case 4: 
	                (*(pVal)) = error_state;
	                break;
	            case 5: 
	                (*(pVal)) = error_value;
	                break;
	            case 6: 
	                (*(pVal)) = error_other;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_RESULTCODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = success;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && ResultCode_IsConstraintValid(pVal, pErrCode);
}



void CommandResponse_Initialize(CommandResponse* pVal)
{


	/*set result */
	ResultCode_Initialize((&(pVal->result)));
	/*set message */
	T_String_Initialize((&(pVal->message)));
}

flag CommandResponse_IsConstraintValid(const CommandResponse* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (((((((((((((pVal->result == success)) || ((pVal->result == error_node_id)))) || ((pVal->result == error_endpoint_id)))) || ((pVal->result == error_unsupported)))) || ((pVal->result == error_state)))) || ((pVal->result == error_value)))) || ((pVal->result == error_other)));
    *pErrCode = ret ? 0 :  ERR_COMMANDRESPONSE_RESULT; 
    if (ret) {
        ret = (pVal->message.nCount <= 40);
        *pErrCode = ret ? 0 :  ERR_COMMANDRESPONSE_MESSAGE; 
    }

	return ret;
}

flag CommandResponse_Encode(const CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? CommandResponse_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode result */
	    ret = ResultCode_Encode((&(pVal->result)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode message */
	        ret = T_String_Encode((&(pVal->message)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag CommandResponse_Decode(CommandResponse* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode result */
	ret = ResultCode_Decode((&(pVal->result)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode message */
	    ret = T_String_Decode((&(pVal->message)), pBitStrm, pErrCode);
	}

	return ret  && CommandResponse_IsConstraintValid(pVal, pErrCode);
}

