/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Trigger.h"



void TriggerMask_Initialize(TriggerMask* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 8) {
	    T_Boolean_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag TriggerMask_IsConstraintValid(const TriggerMask* pVal, int* pErrCode)
{
    flag ret = TRUE;
    /* -Werror=unused-parameter */
    (void)pVal;

    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag TriggerMask_Encode(const TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? TriggerMask_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    	
	    for(i1=0; (i1 < (int)8) && ret; i1++) 
	    {
	    	ret = T_Boolean_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TriggerMask_Decode(TriggerMask* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;

		
	for(i1=0; (i1 < (int)8) && ret; i1++) 
	{
		ret = T_Boolean_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && TriggerMask_IsConstraintValid(pVal, pErrCode);
}



void TriggerGenerator_Initialize(TriggerGenerator* pVal)
{

	(*(pVal)) = 1;
}

flag TriggerGenerator_IsConstraintValid(const TriggerGenerator* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 4UL));
    *pErrCode = ret ? 0 :  ERR_TRIGGERGENERATOR; 

	return ret;
}

flag TriggerGenerator_Encode(const TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? TriggerGenerator_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 4);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TriggerGenerator_Decode(TriggerGenerator* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGERGENERATOR;

	return ret  && TriggerGenerator_IsConstraintValid(pVal, pErrCode);
}



void TriggerInput_Initialize(TriggerInput* pVal)
{

	(*(pVal)) = 1;
}

flag TriggerInput_IsConstraintValid(const TriggerInput* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 4UL));
    *pErrCode = ret ? 0 :  ERR_TRIGGERINPUT; 

	return ret;
}

flag TriggerInput_Encode(const TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? TriggerInput_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 4);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TriggerInput_Decode(TriggerInput* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGERINPUT;

	return ret  && TriggerInput_IsConstraintValid(pVal, pErrCode);
}



void TriggerOutput_Initialize(TriggerOutput* pVal)
{

	(*(pVal)) = 1;
}

flag TriggerOutput_IsConstraintValid(const TriggerOutput* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((1UL <= (*(pVal))) && ((*(pVal)) <= 8UL));
    *pErrCode = ret ? 0 :  ERR_TRIGGEROUTPUT; 

	return ret;
}

flag TriggerOutput_Encode(const TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? TriggerOutput_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 1, 8);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TriggerOutput_Decode(TriggerOutput* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 1, 8);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGEROUTPUT;

	return ret  && TriggerOutput_IsConstraintValid(pVal, pErrCode);
}



void TriggerPeriod_Initialize(TriggerPeriod* pVal)
{

	(*(pVal)) = 0;
}

flag TriggerPeriod_IsConstraintValid(const TriggerPeriod* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 16777215UL);
    *pErrCode = ret ? 0 :  ERR_TRIGGERPERIOD; 

	return ret;
}

flag TriggerPeriod_Encode(const TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? TriggerPeriod_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TriggerPeriod_Decode(TriggerPeriod* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGERPERIOD;

	return ret  && TriggerPeriod_IsConstraintValid(pVal, pErrCode);
}



void GeneratorSetup_Initialize(GeneratorSetup* pVal)
{


	/*set source */
	TriggerGenerator_Initialize((&(pVal->source)));
	/*set period */
	TriggerPeriod_Initialize((&(pVal->period)));
}

flag GeneratorSetup_IsConstraintValid(const GeneratorSetup* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
    *pErrCode = ret ? 0 :  ERR_GENERATORSETUP_SOURCE; 
    if (ret) {
        ret = (pVal->period <= 16777215UL);
        *pErrCode = ret ? 0 :  ERR_GENERATORSETUP_PERIOD; 
    }

	return ret;
}

flag GeneratorSetup_Encode(const GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? GeneratorSetup_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode source */
	    ret = TriggerGenerator_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode period */
	        ret = TriggerPeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag GeneratorSetup_Decode(GeneratorSetup* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode source */
	ret = TriggerGenerator_Decode((&(pVal->source)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode period */
	    ret = TriggerPeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
	}

	return ret  && GeneratorSetup_IsConstraintValid(pVal, pErrCode);
}



void TriggerOffset_Initialize(TriggerOffset* pVal)
{

	(*(pVal)) = 0;
}

flag TriggerOffset_IsConstraintValid(const TriggerOffset* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 16777215UL);
    *pErrCode = ret ? 0 :  ERR_TRIGGEROFFSET; 

	return ret;
}

flag TriggerOffset_Encode(const TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? TriggerOffset_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 16777215);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TriggerOffset_Decode(TriggerOffset* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 16777215);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGEROFFSET;

	return ret  && TriggerOffset_IsConstraintValid(pVal, pErrCode);
}



void TriggerDuration_Initialize(TriggerDuration* pVal)
{

	(*(pVal)) = 0;
}

flag TriggerDuration_IsConstraintValid(const TriggerDuration* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 1023UL);
    *pErrCode = ret ? 0 :  ERR_TRIGGERDURATION; 

	return ret;
}

flag TriggerDuration_Encode(const TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? TriggerDuration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 1023);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag TriggerDuration_Decode(TriggerDuration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 1023);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_TRIGGERDURATION;

	return ret  && TriggerDuration_IsConstraintValid(pVal, pErrCode);
}



void ChannelInternal_Initialize(ChannelInternal* pVal)
{


	/*set output_channel */
	TriggerOutput_Initialize((&(pVal->output_channel)));
	/*set source */
	TriggerGenerator_Initialize((&(pVal->source)));
	/*set offset */
	TriggerOffset_Initialize((&(pVal->offset)));
	/*set duration */
	TriggerDuration_Initialize((&(pVal->duration)));
	/*set invert */
	T_Boolean_Initialize((&(pVal->invert)));
}

flag ChannelInternal_IsConstraintValid(const ChannelInternal* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((1UL <= pVal->output_channel) && (pVal->output_channel <= 8UL));
    *pErrCode = ret ? 0 :  ERR_CHANNELINTERNAL_OUTPUT_CHANNEL; 
    if (ret) {
        ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
        *pErrCode = ret ? 0 :  ERR_CHANNELINTERNAL_SOURCE; 
        if (ret) {
            ret = (pVal->offset <= 16777215UL);
            *pErrCode = ret ? 0 :  ERR_CHANNELINTERNAL_OFFSET; 
            if (ret) {
                ret = (pVal->duration <= 1023UL);
                *pErrCode = ret ? 0 :  ERR_CHANNELINTERNAL_DURATION; 
            }
        }
    }

	return ret;
}

flag ChannelInternal_Encode(const ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ChannelInternal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode output_channel */
	    ret = TriggerOutput_Encode((&(pVal->output_channel)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode source */
	        ret = TriggerGenerator_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode offset */
	            ret = TriggerOffset_Encode((&(pVal->offset)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode duration */
	                ret = TriggerDuration_Encode((&(pVal->duration)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode invert */
	                    ret = T_Boolean_Encode((&(pVal->invert)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ChannelInternal_Decode(ChannelInternal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode output_channel */
	ret = TriggerOutput_Decode((&(pVal->output_channel)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode source */
	    ret = TriggerGenerator_Decode((&(pVal->source)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode offset */
	        ret = TriggerOffset_Decode((&(pVal->offset)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode duration */
	            ret = TriggerDuration_Decode((&(pVal->duration)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode invert */
	                ret = T_Boolean_Decode((&(pVal->invert)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && ChannelInternal_IsConstraintValid(pVal, pErrCode);
}



void ChannelExternal_Initialize(ChannelExternal* pVal)
{


	/*set output_channel */
	TriggerOutput_Initialize((&(pVal->output_channel)));
	/*set source */
	TriggerInput_Initialize((&(pVal->source)));
	/*set offset */
	TriggerOffset_Initialize((&(pVal->offset)));
	/*set duration */
	TriggerDuration_Initialize((&(pVal->duration)));
	/*set bypass */
	T_Boolean_Initialize((&(pVal->bypass)));
	/*set invert */
	T_Boolean_Initialize((&(pVal->invert)));
}

flag ChannelExternal_IsConstraintValid(const ChannelExternal* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((1UL <= pVal->output_channel) && (pVal->output_channel <= 8UL));
    *pErrCode = ret ? 0 :  ERR_CHANNELEXTERNAL_OUTPUT_CHANNEL; 
    if (ret) {
        ret = ((1UL <= pVal->source) && (pVal->source <= 4UL));
        *pErrCode = ret ? 0 :  ERR_CHANNELEXTERNAL_SOURCE; 
        if (ret) {
            ret = (pVal->offset <= 16777215UL);
            *pErrCode = ret ? 0 :  ERR_CHANNELEXTERNAL_OFFSET; 
            if (ret) {
                ret = (pVal->duration <= 1023UL);
                *pErrCode = ret ? 0 :  ERR_CHANNELEXTERNAL_DURATION; 
            }
        }
    }

	return ret;
}

flag ChannelExternal_Encode(const ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ChannelExternal_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode output_channel */
	    ret = TriggerOutput_Encode((&(pVal->output_channel)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode source */
	        ret = TriggerInput_Encode((&(pVal->source)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode offset */
	            ret = TriggerOffset_Encode((&(pVal->offset)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode duration */
	                ret = TriggerDuration_Encode((&(pVal->duration)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode bypass */
	                    ret = T_Boolean_Encode((&(pVal->bypass)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode invert */
	                        ret = T_Boolean_Encode((&(pVal->invert)), pBitStrm, pErrCode, FALSE);
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ChannelExternal_Decode(ChannelExternal* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode output_channel */
	ret = TriggerOutput_Decode((&(pVal->output_channel)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode source */
	    ret = TriggerInput_Decode((&(pVal->source)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode offset */
	        ret = TriggerOffset_Decode((&(pVal->offset)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode duration */
	            ret = TriggerDuration_Decode((&(pVal->duration)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode bypass */
	                ret = T_Boolean_Decode((&(pVal->bypass)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode invert */
	                    ret = T_Boolean_Decode((&(pVal->invert)), pBitStrm, pErrCode);
	                }
	            }
	        }
	    }
	}

	return ret  && ChannelExternal_IsConstraintValid(pVal, pErrCode);
}

