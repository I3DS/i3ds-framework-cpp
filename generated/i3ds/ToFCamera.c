/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "ToFCamera.h"



void ToFRange_Initialize(ToFRange* pVal)
{


	/*set min_depth */
	T_Float_Initialize((&(pVal->min_depth)));
	/*set max_depth */
	T_Float_Initialize((&(pVal->max_depth)));
}

flag ToFRange_IsConstraintValid(const ToFRange* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->min_depth) && (pVal->min_depth <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_TOFRANGE_MIN_DEPTH; 
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->max_depth) && (pVal->max_depth <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_TOFRANGE_MAX_DEPTH; 
    }

	return ret;
}

flag ToFRange_Encode(const ToFRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ToFRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode min_depth */
	    ret = T_Float_Encode((&(pVal->min_depth)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode max_depth */
	        ret = T_Float_Encode((&(pVal->max_depth)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ToFRange_Decode(ToFRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode min_depth */
	ret = T_Float_Decode((&(pVal->min_depth)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode max_depth */
	    ret = T_Float_Decode((&(pVal->max_depth)), pBitStrm, pErrCode);
	}

	return ret  && ToFRange_IsConstraintValid(pVal, pErrCode);
}



void ToFMeasurement400K_distances_Initialize(ToFMeasurement400K_distances* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 400000) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void ToFMeasurement400K_validity_Initialize(ToFMeasurement400K_validity* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 400000) {
	    Depth_validity_t_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void ToFMeasurement400K_Initialize(ToFMeasurement400K* pVal)
{


	/*set attributes */
	SampleAttributes_Initialize((&(pVal->attributes)));
	/*set distances */
	ToFMeasurement400K_distances_Initialize((&(pVal->distances)));
	/*set validity */
	ToFMeasurement400K_validity_Initialize((&(pVal->validity)));
	/*set region */
	PlanarRegion_Initialize((&(pVal->region)));
}

flag ToFMeasurement400K_IsConstraintValid(const ToFMeasurement400K* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = (-9223372036854775807LL <= pVal->attributes.timestamp);
    *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_ATTRIBUTES_TIMESTAMP; 
    if (ret) {
        ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
        *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_ATTRIBUTES_VALIDITY; 
        if (ret) {
            ret = (pVal->attributes.attributes.nCount <= 4);
            *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_ATTRIBUTES_ATTRIBUTES; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++) 
                {
                	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
                	*pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY; 
                	if (ret) {
                	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == discrete_value_PRESENT) {
                	    	ret = (-9223372036854775807LL <= pVal->attributes.attributes.arr[i1].attribute_value.u.discrete_value);
                	    	*pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE; 
                	    }
                	    if (ret) {
                	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
                	        	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
                	        	*pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE; 
                	        }
                	        if (ret) {
                	            if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
                	            	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
                	            	*pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE; 
                	            }
                	        }
                	    }
                	}
                }
            }
        }
    }
    if (ret) {
        ret = ((1 <= pVal->distances.nCount) && (pVal->distances.nCount <= 400000));
        *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_DISTANCES; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->distances.nCount; i1++) 
            {
            	ret = ((-3.40282346600000020000E+038 <= pVal->distances.arr[i1]) && (pVal->distances.arr[i1] <= 3.40282346600000020000E+038));
            	*pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_DISTANCES_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->validity.nCount) && (pVal->validity.nCount <= 400000));
            *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_VALIDITY; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->validity.nCount; i1++) 
                {
                	ret = (((((((pVal->validity.arr[i1] == depth_valid)) || ((pVal->validity.arr[i1] == depth_range_error)))) || ((pVal->validity.arr[i1] == depth_range_error_far)))) || ((pVal->validity.arr[i1] == depth_range_error_near)));
                	*pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_VALIDITY_ELM; 
                }
            }
            if (ret) {
                ret = (pVal->region.offset_x <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_REGION_OFFSET_X; 
                if (ret) {
                    ret = (pVal->region.offset_y <= 65535UL);
                    *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_REGION_OFFSET_Y; 
                    if (ret) {
                        ret = (pVal->region.size_x <= 65535UL);
                        *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_REGION_SIZE_X; 
                        if (ret) {
                            ret = (pVal->region.size_y <= 65535UL);
                            *pErrCode = ret ? 0 :  ERR_TOFMEASUREMENT400K_REGION_SIZE_Y; 
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag ToFMeasurement400K_Encode(const ToFMeasurement400K* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nBlockIndex1;
	asn1SccSint nRemainingItemsVar1;
	asn1SccSint nCurBlockSize1;
	asn1SccSint nCurOffset1;
	ret = bCheckConstraints ? ToFMeasurement400K_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode attributes */
	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode distances */
	        nRemainingItemsVar1 = pVal->distances.nCount;
	        nCurBlockSize1 = 0;
	        nCurOffset1 = 0;
	        nBlockIndex1 = 0;
	        while (nRemainingItemsVar1 >= 0x4000 && nBlockIndex1 < pVal->distances.nCount) 
	        {
	        	if (nRemainingItemsVar1 >= 0x10000)
	        	{
	        		nCurBlockSize1 = 0x10000;
	        		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC4, 0, 0xFF); 
	        	}
	        	else if (nRemainingItemsVar1 >= 0xC000)
	        	{
	        		nCurBlockSize1 = 0xC000;
	        		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC3, 0, 0xFF); 
	        	}
	        	else if (nRemainingItemsVar1 >= 0x8000)
	        	{
	        		nCurBlockSize1 = 0x8000;
	        		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC2, 0, 0xFF); 
	        	}
	        	else 
	        	{
	        		nCurBlockSize1 = 0x4000;
	        		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC1, 0, 0xFF); 
	        	}
	        	
	        	for(i1=(int)nCurOffset1; i1 < (int)(nCurBlockSize1 + nCurOffset1); i1++)
	        	{
	        		ret = T_Float_Encode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode, FALSE);
	        	}
	        	nCurOffset1 += nCurBlockSize1;
	        	nRemainingItemsVar1 -= nCurBlockSize1;
	            nBlockIndex1 = nBlockIndex1+1;
	        }

	        if (nRemainingItemsVar1 <= 0x7F)
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, nRemainingItemsVar1, 0, 0xFF);
	        else
	        {
	        	BitStream_AppendBit(pBitStrm, 1);
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, nRemainingItemsVar1, 0, 0x7FFF);
	        }

	        for(i1=(int)nCurOffset1; i1 < (int)(nCurOffset1 + nRemainingItemsVar1); i1++)
	        {
	        	ret = T_Float_Encode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode validity */
	            nRemainingItemsVar1 = pVal->validity.nCount;
	            nCurBlockSize1 = 0;
	            nCurOffset1 = 0;
	            nBlockIndex1 = 0;
	            while (nRemainingItemsVar1 >= 0x4000 && nBlockIndex1 < pVal->validity.nCount) 
	            {
	            	if (nRemainingItemsVar1 >= 0x10000)
	            	{
	            		nCurBlockSize1 = 0x10000;
	            		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC4, 0, 0xFF); 
	            	}
	            	else if (nRemainingItemsVar1 >= 0xC000)
	            	{
	            		nCurBlockSize1 = 0xC000;
	            		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC3, 0, 0xFF); 
	            	}
	            	else if (nRemainingItemsVar1 >= 0x8000)
	            	{
	            		nCurBlockSize1 = 0x8000;
	            		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC2, 0, 0xFF); 
	            	}
	            	else 
	            	{
	            		nCurBlockSize1 = 0x4000;
	            		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC1, 0, 0xFF); 
	            	}
	            	
	            	for(i1=(int)nCurOffset1; i1 < (int)(nCurBlockSize1 + nCurOffset1); i1++)
	            	{
	            		ret = Depth_validity_t_Encode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	            	}
	            	nCurOffset1 += nCurBlockSize1;
	            	nRemainingItemsVar1 -= nCurBlockSize1;
	                nBlockIndex1 = nBlockIndex1+1;
	            }

	            if (nRemainingItemsVar1 <= 0x7F)
	            	BitStream_EncodeConstraintWholeNumber(pBitStrm, nRemainingItemsVar1, 0, 0xFF);
	            else
	            {
	            	BitStream_AppendBit(pBitStrm, 1);
	            	BitStream_EncodeConstraintWholeNumber(pBitStrm, nRemainingItemsVar1, 0, 0x7FFF);
	            }

	            for(i1=(int)nCurOffset1; i1 < (int)(nCurOffset1 + nRemainingItemsVar1); i1++)
	            {
	            	ret = Depth_validity_t_Encode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	            if (ret) {
	                /*Encode region */
	                ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ToFMeasurement400K_Decode(ToFMeasurement400K* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nLengthTmp1;
	asn1SccSint nRemainingItemsVar1;
	asn1SccSint nCurBlockSize1;
	asn1SccSint nCurOffset1;

	/*Decode attributes */
	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode distances */
	    nRemainingItemsVar1 = 0;
	    nCurBlockSize1 = 0;
	    nCurOffset1 = 0;
	    nLengthTmp1 = 0;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nRemainingItemsVar1, 0, 0xFF);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TOFMEASUREMENT400K_DISTANCES;
	    if (ret) {
	    	while(ret && (nRemainingItemsVar1 & 0xC0)==0xC0) 
	    	{
	    		if (nRemainingItemsVar1 == 0xC4)
	    			nCurBlockSize1 = 0x10000;
	    		else if (nRemainingItemsVar1 == 0xC3)
	    			nCurBlockSize1 = 0xC000;
	    		else if (nRemainingItemsVar1 == 0xC2)
	    			nCurBlockSize1 = 0x8000;
	    		else if (nRemainingItemsVar1 == 0xC1)
	    			nCurBlockSize1 = 0x4000;
	    		else {
	    			*pErrCode = ERR_UPER_DECODE_TOFMEASUREMENT400K_DISTANCES; /*COVERAGE_IGNORE*/
	    			return FALSE; /*COVERAGE_IGNORE*/
	    		}
	    		if (nCurOffset1 + nCurBlockSize1 > 400000)
	    		{
	    			*pErrCode = ERR_UPER_DECODE_TOFMEASUREMENT400K_DISTANCES; /*COVERAGE_IGNORE*/
	    			return FALSE; /*COVERAGE_IGNORE*/
	    		}

	    		for(i1=(int)nCurOffset1; ret && (i1 < (int)(nCurOffset1 + nCurBlockSize1)) ; i1++)
	    		{
	    			ret = T_Float_Decode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode);
	    		}
	    	
	            if (ret) {
	    		    nLengthTmp1 += (long)nCurBlockSize1;
	    		    nCurOffset1 += nCurBlockSize1;
	    		    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nRemainingItemsVar1, 0, 0xFF);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_TOFMEASUREMENT400K_DISTANCES;
	            }
	    	}
	        if (ret) {
	    	    if ( (nRemainingItemsVar1 & 0x80)>0) 
	    	    {
	    		    asn1SccSint len2;
	    		    nRemainingItemsVar1 <<= 8;
	    		    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_TOFMEASUREMENT400K_DISTANCES;
	                if (ret) {
	    		        nRemainingItemsVar1 |= len2;
	    		        nRemainingItemsVar1 &= 0x7FFF;
	                }
	    	    }
	            ret = ret && (nCurOffset1 + nRemainingItemsVar1 <= 400000);
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_TOFMEASUREMENT400K_DISTANCES;
	            if (ret) {
	    	        for(i1=(int)nCurOffset1; ret && (i1 < (int)(nCurOffset1 + nRemainingItemsVar1)) ; i1++)
	    	        {
	    		        ret = T_Float_Decode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode);
	    	        }
	                if (ret) {
	    	            nLengthTmp1 += (long)nRemainingItemsVar1;

	                    if ((nLengthTmp1 >= 1) && (nLengthTmp1 <= 400000)) {
	    	                pVal->distances.nCount = (int)nLengthTmp1;

	                    } else {
	                        ret = FALSE;  /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_UPER_DECODE_TOFMEASUREMENT400K_DISTANCES; /*COVERAGE_IGNORE*/
	                    }

	                }
	            }
	        }
	    }
	    if (ret) {
	        /*Decode validity */
	        nRemainingItemsVar1 = 0;
	        nCurBlockSize1 = 0;
	        nCurOffset1 = 0;
	        nLengthTmp1 = 0;
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nRemainingItemsVar1, 0, 0xFF);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_TOFMEASUREMENT400K_VALIDITY;
	        if (ret) {
	        	while(ret && (nRemainingItemsVar1 & 0xC0)==0xC0) 
	        	{
	        		if (nRemainingItemsVar1 == 0xC4)
	        			nCurBlockSize1 = 0x10000;
	        		else if (nRemainingItemsVar1 == 0xC3)
	        			nCurBlockSize1 = 0xC000;
	        		else if (nRemainingItemsVar1 == 0xC2)
	        			nCurBlockSize1 = 0x8000;
	        		else if (nRemainingItemsVar1 == 0xC1)
	        			nCurBlockSize1 = 0x4000;
	        		else {
	        			*pErrCode = ERR_UPER_DECODE_TOFMEASUREMENT400K_VALIDITY; /*COVERAGE_IGNORE*/
	        			return FALSE; /*COVERAGE_IGNORE*/
	        		}
	        		if (nCurOffset1 + nCurBlockSize1 > 400000)
	        		{
	        			*pErrCode = ERR_UPER_DECODE_TOFMEASUREMENT400K_VALIDITY; /*COVERAGE_IGNORE*/
	        			return FALSE; /*COVERAGE_IGNORE*/
	        		}

	        		for(i1=(int)nCurOffset1; ret && (i1 < (int)(nCurOffset1 + nCurBlockSize1)) ; i1++)
	        		{
	        			ret = Depth_validity_t_Decode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode);
	        		}
	        	
	                if (ret) {
	        		    nLengthTmp1 += (long)nCurBlockSize1;
	        		    nCurOffset1 += nCurBlockSize1;
	        		    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nRemainingItemsVar1, 0, 0xFF);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TOFMEASUREMENT400K_VALIDITY;
	                }
	        	}
	            if (ret) {
	        	    if ( (nRemainingItemsVar1 & 0x80)>0) 
	        	    {
	        		    asn1SccSint len2;
	        		    nRemainingItemsVar1 <<= 8;
	        		    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_TOFMEASUREMENT400K_VALIDITY;
	                    if (ret) {
	        		        nRemainingItemsVar1 |= len2;
	        		        nRemainingItemsVar1 &= 0x7FFF;
	                    }
	        	    }
	                ret = ret && (nCurOffset1 + nRemainingItemsVar1 <= 400000);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_TOFMEASUREMENT400K_VALIDITY;
	                if (ret) {
	        	        for(i1=(int)nCurOffset1; ret && (i1 < (int)(nCurOffset1 + nRemainingItemsVar1)) ; i1++)
	        	        {
	        		        ret = Depth_validity_t_Decode((&(pVal->validity.arr[i1])), pBitStrm, pErrCode);
	        	        }
	                    if (ret) {
	        	            nLengthTmp1 += (long)nRemainingItemsVar1;

	                        if ((nLengthTmp1 >= 1) && (nLengthTmp1 <= 400000)) {
	        	                pVal->validity.nCount = (int)nLengthTmp1;

	                        } else {
	                            ret = FALSE;  /*COVERAGE_IGNORE*/
	                            *pErrCode = ERR_UPER_DECODE_TOFMEASUREMENT400K_VALIDITY; /*COVERAGE_IGNORE*/
	                        }

	                    }
	                }
	            }
	        }
	        if (ret) {
	            /*Decode region */
	            ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && ToFMeasurement400K_IsConstraintValid(pVal, pErrCode);
}



void ToFRegion_Initialize(ToFRegion* pVal)
{


	/*set enable */
	T_Boolean_Initialize((&(pVal->enable)));
	/*set region */
	PlanarRegion_Initialize((&(pVal->region)));
}

flag ToFRegion_IsConstraintValid(const ToFRegion* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->region.offset_x <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_OFFSET_X; 
    if (ret) {
        ret = (pVal->region.offset_y <= 65535UL);
        *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_OFFSET_Y; 
        if (ret) {
            ret = (pVal->region.size_x <= 65535UL);
            *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_SIZE_X; 
            if (ret) {
                ret = (pVal->region.size_y <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_SIZE_Y; 
            }
        }
    }

	return ret;
}

flag ToFRegion_Encode(const ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ToFRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode enable */
	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode region */
	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ToFRegion_Decode(ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode enable */
	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode region */
	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
	}

	return ret  && ToFRegion_IsConstraintValid(pVal, pErrCode);
}



void ToFConfiguration_Initialize(ToFConfiguration* pVal)
{


	/*set region_enabled */
	T_Boolean_Initialize((&(pVal->region_enabled)));
	/*set region */
	PlanarRegion_Initialize((&(pVal->region)));
	/*set min_depth */
	T_Float_Initialize((&(pVal->min_depth)));
	/*set max_depth */
	T_Float_Initialize((&(pVal->max_depth)));
}

flag ToFConfiguration_IsConstraintValid(const ToFConfiguration* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->region.offset_x <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_OFFSET_X; 
    if (ret) {
        ret = (pVal->region.offset_y <= 65535UL);
        *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_OFFSET_Y; 
        if (ret) {
            ret = (pVal->region.size_x <= 65535UL);
            *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_SIZE_X; 
            if (ret) {
                ret = (pVal->region.size_y <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_SIZE_Y; 
            }
        }
    }
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->min_depth) && (pVal->min_depth <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_MIN_DEPTH; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->max_depth) && (pVal->max_depth <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_MAX_DEPTH; 
        }
    }

	return ret;
}

flag ToFConfiguration_Encode(const ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ToFConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode region_enabled */
	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode region */
	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode min_depth */
	            ret = T_Float_Encode((&(pVal->min_depth)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode max_depth */
	                ret = T_Float_Encode((&(pVal->max_depth)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ToFConfiguration_Decode(ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode region_enabled */
	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode region */
	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode min_depth */
	        ret = T_Float_Decode((&(pVal->min_depth)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode max_depth */
	            ret = T_Float_Decode((&(pVal->max_depth)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && ToFConfiguration_IsConstraintValid(pVal, pErrCode);
}

