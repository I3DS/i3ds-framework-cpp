/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "ToFCamera.h"



void ToFRange_Initialize(ToFRange* pVal)
{


	/*set min_depth */
	T_Float_Initialize((&(pVal->min_depth)));
	/*set max_depth */
	T_Float_Initialize((&(pVal->max_depth)));
}

flag ToFRange_IsConstraintValid(const ToFRange* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->min_depth) && (pVal->min_depth <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_TOFRANGE_MIN_DEPTH; 
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->max_depth) && (pVal->max_depth <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_TOFRANGE_MAX_DEPTH; 
    }

	return ret;
}

flag ToFRange_Encode(const ToFRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ToFRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode min_depth */
	    ret = T_Float_Encode((&(pVal->min_depth)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode max_depth */
	        ret = T_Float_Encode((&(pVal->max_depth)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ToFRange_Decode(ToFRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode min_depth */
	ret = T_Float_Decode((&(pVal->min_depth)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode max_depth */
	    ret = T_Float_Decode((&(pVal->max_depth)), pBitStrm, pErrCode);
	}

	return ret  && ToFRange_IsConstraintValid(pVal, pErrCode);
}



void ToFRegion_Initialize(ToFRegion* pVal)
{


	/*set enable */
	T_Boolean_Initialize((&(pVal->enable)));
	/*set region */
	PlanarRegion_Initialize((&(pVal->region)));
}

flag ToFRegion_IsConstraintValid(const ToFRegion* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->region.offset_x <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_OFFSET_X; 
    if (ret) {
        ret = (pVal->region.offset_y <= 65535UL);
        *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_OFFSET_Y; 
        if (ret) {
            ret = (pVal->region.size_x <= 65535UL);
            *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_SIZE_X; 
            if (ret) {
                ret = (pVal->region.size_y <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_TOFREGION_REGION_SIZE_Y; 
            }
        }
    }

	return ret;
}

flag ToFRegion_Encode(const ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ToFRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode enable */
	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode region */
	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ToFRegion_Decode(ToFRegion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode enable */
	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode region */
	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
	}

	return ret  && ToFRegion_IsConstraintValid(pVal, pErrCode);
}



void ToFConfiguration_Initialize(ToFConfiguration* pVal)
{


	/*set region_enabled */
	T_Boolean_Initialize((&(pVal->region_enabled)));
	/*set region */
	PlanarRegion_Initialize((&(pVal->region)));
	/*set min_depth */
	T_Float_Initialize((&(pVal->min_depth)));
	/*set max_depth */
	T_Float_Initialize((&(pVal->max_depth)));
}

flag ToFConfiguration_IsConstraintValid(const ToFConfiguration* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->region.offset_x <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_OFFSET_X; 
    if (ret) {
        ret = (pVal->region.offset_y <= 65535UL);
        *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_OFFSET_Y; 
        if (ret) {
            ret = (pVal->region.size_x <= 65535UL);
            *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_SIZE_X; 
            if (ret) {
                ret = (pVal->region.size_y <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_REGION_SIZE_Y; 
            }
        }
    }
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->min_depth) && (pVal->min_depth <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_MIN_DEPTH; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->max_depth) && (pVal->max_depth <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_TOFCONFIGURATION_MAX_DEPTH; 
        }
    }

	return ret;
}

flag ToFConfiguration_Encode(const ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? ToFConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode region_enabled */
	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode region */
	        ret = PlanarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode min_depth */
	            ret = T_Float_Encode((&(pVal->min_depth)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode max_depth */
	                ret = T_Float_Encode((&(pVal->max_depth)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag ToFConfiguration_Decode(ToFConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode region_enabled */
	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode region */
	    ret = PlanarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode min_depth */
	        ret = T_Float_Decode((&(pVal->min_depth)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode max_depth */
	            ret = T_Float_Decode((&(pVal->max_depth)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && ToFConfiguration_IsConstraintValid(pVal, pErrCode);
}

