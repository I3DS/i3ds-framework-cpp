/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "DepthMap.h"



void Depth_validity_t_Initialize(Depth_validity_t* pVal)
{

	(*(pVal)) = depth_valid;
}

flag Depth_validity_t_IsConstraintValid(const Depth_validity_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((*(pVal)) == depth_valid)) || (((*(pVal)) == depth_range_error)))) || (((*(pVal)) == depth_range_error_far)))) || (((*(pVal)) == depth_range_error_near)));
    *pErrCode = ret ? 0 :  ERR_DEPTH_VALIDITY_T; 

	return ret;
}

flag Depth_validity_t_Encode(const Depth_validity_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Depth_validity_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case depth_valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case depth_range_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case depth_range_error_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case depth_range_error_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_DEPTH_VALIDITY_T; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Depth_validity_t_Decode(Depth_validity_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_DEPTH_VALIDITY_T;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = depth_valid;
	                break;
	            case 1: 
	                (*(pVal)) = depth_range_error;
	                break;
	            case 2: 
	                (*(pVal)) = depth_range_error_far;
	                break;
	            case 3: 
	                (*(pVal)) = depth_range_error_near;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_DEPTH_VALIDITY_T;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = depth_valid;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Depth_validity_t_IsConstraintValid(pVal, pErrCode);
}

