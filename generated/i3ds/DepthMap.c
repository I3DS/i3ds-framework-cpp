/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "DepthMap.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Depth_validity_t_Initialize(Depth_validity_t* pVal)
{
    *pVal = (Depth_validity_t) valid_measurement;
}
#endif

 
flag Depth_validity_t_IsConstraintValid(const Depth_validity_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == valid_measurement) || (*pVal == too_far)) || (*pVal == too_near)) || (*pVal == measurement_error));
	*pErrCode = ret ? 0 : ERR_Depth_validity_t;

	return ret;
}

flag Depth_validity_t_Encode(const Depth_validity_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? Depth_validity_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch(*pVal) 
	    {
	        case valid_measurement:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case too_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case too_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case measurement_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:
	    	    *pErrCode = 1075838977; //COVERAGE_IGNORE
	    	    ret = FALSE;            //COVERAGE_IGNORE
	    }
    }

	return ret;
}

flag Depth_validity_t_Decode(Depth_validity_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	asn1SccSint enumIndex;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	*pErrCode = ret ? 0 : 270532609;
	if (ret) {
	    switch(enumIndex) 
	    {
	        case 0: 
	            *pVal = valid_measurement;
	            break;
	        case 1: 
	            *pVal = too_far;
	            break;
	        case 2: 
	            *pVal = too_near;
	            break;
	        case 3: 
	            *pVal = measurement_error;
	            break;
	        default:
		        *pErrCode = 1075838978;     //COVERAGE_IGNORE
		        ret = FALSE;                //COVERAGE_IGNORE
	    }
	}

	return ret;
}

