/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Sensor.h"



void SamplePeriod_Initialize(SamplePeriod* pVal)
{

	T_UInt32_Initialize(pVal);
}

flag SamplePeriod_IsConstraintValid(const SamplePeriod* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_SAMPLEPERIOD; 

	return ret;
}

flag SamplePeriod_Encode(const SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? SamplePeriod_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SamplePeriod_Decode(SamplePeriod* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret  && SamplePeriod_IsConstraintValid(pVal, pErrCode);
}



void BatchSize_Initialize(BatchSize* pVal)
{

	T_UInt32_Initialize(pVal);
}

flag BatchSize_IsConstraintValid(const BatchSize* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_BATCHSIZE; 

	return ret;
}

flag BatchSize_Encode(const BatchSize* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? BatchSize_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag BatchSize_Decode(BatchSize* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret  && BatchSize_IsConstraintValid(pVal, pErrCode);
}



void BatchCount_Initialize(BatchCount* pVal)
{

	T_UInt32_Initialize(pVal);
}

flag BatchCount_IsConstraintValid(const BatchCount* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_BATCHCOUNT; 

	return ret;
}

flag BatchCount_Encode(const BatchCount* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? BatchCount_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = T_UInt32_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag BatchCount_Decode(BatchCount* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = T_UInt32_Decode(pVal, pBitStrm, pErrCode);

	return ret  && BatchCount_IsConstraintValid(pVal, pErrCode);
}



void SampleCommand_Initialize(SampleCommand* pVal)
{


	/*set period */
	T_UInt32_Initialize((&(pVal->period)));
	/*set batch_size */
	T_UInt32_Initialize((&(pVal->batch_size)));
	/*set batch_count */
	T_UInt32_Initialize((&(pVal->batch_count)));
}

flag SampleCommand_IsConstraintValid(const SampleCommand* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->period <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_SAMPLECOMMAND_PERIOD; 
    if (ret) {
        ret = (pVal->batch_size <= 4294967295UL);
        *pErrCode = ret ? 0 :  ERR_SAMPLECOMMAND_BATCH_SIZE; 
        if (ret) {
            ret = (pVal->batch_count <= 4294967295UL);
            *pErrCode = ret ? 0 :  ERR_SAMPLECOMMAND_BATCH_COUNT; 
        }
    }

	return ret;
}

flag SampleCommand_Encode(const SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? SampleCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode period */
	    ret = SamplePeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode batch_size */
	        ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode batch_count */
	            ret = BatchCount_Encode((&(pVal->batch_count)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SampleCommand_Decode(SampleCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode period */
	ret = SamplePeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode batch_size */
	    ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode batch_count */
	        ret = BatchCount_Decode((&(pVal->batch_count)), pBitStrm, pErrCode);
	    }
	}

	return ret  && SampleCommand_IsConstraintValid(pVal, pErrCode);
}



void SensorConfiguration_Initialize(SensorConfiguration* pVal)
{


	/*set device_name */
	T_String_Initialize((&(pVal->device_name)));
	/*set period */
	T_UInt32_Initialize((&(pVal->period)));
	/*set batch_size */
	T_UInt32_Initialize((&(pVal->batch_size)));
	/*set batch_count */
	T_UInt32_Initialize((&(pVal->batch_count)));
}

flag SensorConfiguration_IsConstraintValid(const SensorConfiguration* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->device_name.nCount <= 40);
    *pErrCode = ret ? 0 :  ERR_SENSORCONFIGURATION_DEVICE_NAME; 
    if (ret) {
        ret = (pVal->period <= 4294967295UL);
        *pErrCode = ret ? 0 :  ERR_SENSORCONFIGURATION_PERIOD; 
        if (ret) {
            ret = (pVal->batch_size <= 4294967295UL);
            *pErrCode = ret ? 0 :  ERR_SENSORCONFIGURATION_BATCH_SIZE; 
            if (ret) {
                ret = (pVal->batch_count <= 4294967295UL);
                *pErrCode = ret ? 0 :  ERR_SENSORCONFIGURATION_BATCH_COUNT; 
            }
        }
    }

	return ret;
}

flag SensorConfiguration_Encode(const SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? SensorConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode device_name */
	    ret = T_String_Encode((&(pVal->device_name)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode period */
	        ret = SamplePeriod_Encode((&(pVal->period)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode batch_size */
	            ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode batch_count */
	                ret = BatchCount_Encode((&(pVal->batch_count)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SensorConfiguration_Decode(SensorConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode device_name */
	ret = T_String_Decode((&(pVal->device_name)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode period */
	    ret = SamplePeriod_Decode((&(pVal->period)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode batch_size */
	        ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode batch_count */
	            ret = BatchCount_Decode((&(pVal->batch_count)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && SensorConfiguration_IsConstraintValid(pVal, pErrCode);
}



void SensorState_Initialize(SensorState* pVal)
{

	(*(pVal)) = inactive;
}

flag SensorState_IsConstraintValid(const SensorState* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((*(pVal)) == inactive)) || (((*(pVal)) == standby)))) || (((*(pVal)) == operational)))) || (((*(pVal)) == failure)));
    *pErrCode = ret ? 0 :  ERR_SENSORSTATE; 

	return ret;
}

flag SensorState_Encode(const SensorState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? SensorState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case inactive:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case standby:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case operational:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case failure:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_SENSORSTATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SensorState_Decode(SensorState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_SENSORSTATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = inactive;
	                break;
	            case 1: 
	                (*(pVal)) = standby;
	                break;
	            case 2: 
	                (*(pVal)) = operational;
	                break;
	            case 3: 
	                (*(pVal)) = failure;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_SENSORSTATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = inactive;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && SensorState_IsConstraintValid(pVal, pErrCode);
}



void SensorStatus_Initialize(SensorStatus* pVal)
{


	/*set current_state */
	SensorState_Initialize((&(pVal->current_state)));
	/*set device_temperature */
	Base_Temperature_Initialize((&(pVal->device_temperature)));
}

flag SensorStatus_IsConstraintValid(const SensorStatus* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (((((((pVal->current_state == inactive)) || ((pVal->current_state == standby)))) || ((pVal->current_state == operational)))) || ((pVal->current_state == failure)));
    *pErrCode = ret ? 0 :  ERR_SENSORSTATUS_CURRENT_STATE; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->device_temperature.kelvin) && (pVal->device_temperature.kelvin <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_SENSORSTATUS_DEVICE_TEMPERATURE_KELVIN; 
    }

	return ret;
}

flag SensorStatus_Encode(const SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? SensorStatus_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode current_state */
	    ret = SensorState_Encode((&(pVal->current_state)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode device_temperature */
	        ret = Base_Temperature_Encode((&(pVal->device_temperature)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag SensorStatus_Decode(SensorStatus* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode current_state */
	ret = SensorState_Decode((&(pVal->current_state)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode device_temperature */
	    ret = Base_Temperature_Decode((&(pVal->device_temperature)), pBitStrm, pErrCode);
	}

	return ret  && SensorStatus_IsConstraintValid(pVal, pErrCode);
}



void StateCommand_Initialize(StateCommand* pVal)
{

	(*(pVal)) = activate;
}

flag StateCommand_IsConstraintValid(const StateCommand* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((*(pVal)) == activate)) || (((*(pVal)) == start)))) || (((*(pVal)) == stop)))) || (((*(pVal)) == deactivate)));
    *pErrCode = ret ? 0 :  ERR_STATECOMMAND; 

	return ret;
}

flag StateCommand_Encode(const StateCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? StateCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case activate:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case start:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case stop:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case deactivate:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_STATECOMMAND; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag StateCommand_Decode(StateCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_STATECOMMAND;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = activate;
	                break;
	            case 1: 
	                (*(pVal)) = start;
	                break;
	            case 2: 
	                (*(pVal)) = stop;
	                break;
	            case 3: 
	                (*(pVal)) = deactivate;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_STATECOMMAND;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = activate;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && StateCommand_IsConstraintValid(pVal, pErrCode);
}

