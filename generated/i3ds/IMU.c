/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "IMU.h"



void IMUSample_Initialize(IMUSample* pVal)
{


	/*set axis_x_rate */
	T_Double_Initialize((&(pVal->axis_x_rate)));
	/*set axis_x_acceleration */
	T_Double_Initialize((&(pVal->axis_x_acceleration)));
	/*set axis_y_rate */
	T_Double_Initialize((&(pVal->axis_y_rate)));
	/*set axis_y_acceleration */
	T_Double_Initialize((&(pVal->axis_y_acceleration)));
	/*set axis_z_rate */
	T_Double_Initialize((&(pVal->axis_z_rate)));
	/*set axis_z_acceleration */
	T_Double_Initialize((&(pVal->axis_z_acceleration)));
}

flag IMUSample_IsConstraintValid(const IMUSample* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->axis_x_rate) && (pVal->axis_x_rate <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_X_RATE; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->axis_x_acceleration) && (pVal->axis_x_acceleration <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_X_ACCELERATION; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->axis_y_rate) && (pVal->axis_y_rate <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_Y_RATE; 
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->axis_y_acceleration) && (pVal->axis_y_acceleration <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_Y_ACCELERATION; 
                if (ret) {
                    ret = ((-1.79769313486231570000E+308 <= pVal->axis_z_rate) && (pVal->axis_z_rate <= 1.79769313486231570000E+308));
                    *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_Z_RATE; 
                    if (ret) {
                        ret = ((-1.79769313486231570000E+308 <= pVal->axis_z_acceleration) && (pVal->axis_z_acceleration <= 1.79769313486231570000E+308));
                        *pErrCode = ret ? 0 :  ERR_IMUSAMPLE_AXIS_Z_ACCELERATION; 
                    }
                }
            }
        }
    }

	return ret;
}

flag IMUSample_Encode(const IMUSample* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? IMUSample_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode axis_x_rate */
	    ret = T_Double_Encode((&(pVal->axis_x_rate)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode axis_x_acceleration */
	        ret = T_Double_Encode((&(pVal->axis_x_acceleration)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode axis_y_rate */
	            ret = T_Double_Encode((&(pVal->axis_y_rate)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode axis_y_acceleration */
	                ret = T_Double_Encode((&(pVal->axis_y_acceleration)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode axis_z_rate */
	                    ret = T_Double_Encode((&(pVal->axis_z_rate)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode axis_z_acceleration */
	                        ret = T_Double_Encode((&(pVal->axis_z_acceleration)), pBitStrm, pErrCode, FALSE);
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag IMUSample_Decode(IMUSample* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode axis_x_rate */
	ret = T_Double_Decode((&(pVal->axis_x_rate)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode axis_x_acceleration */
	    ret = T_Double_Decode((&(pVal->axis_x_acceleration)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode axis_y_rate */
	        ret = T_Double_Decode((&(pVal->axis_y_rate)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode axis_y_acceleration */
	            ret = T_Double_Decode((&(pVal->axis_y_acceleration)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode axis_z_rate */
	                ret = T_Double_Decode((&(pVal->axis_z_rate)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode axis_z_acceleration */
	                    ret = T_Double_Decode((&(pVal->axis_z_acceleration)), pBitStrm, pErrCode);
	                }
	            }
	        }
	    }
	}

	return ret  && IMUSample_IsConstraintValid(pVal, pErrCode);
}



void IMUMeasurement20_samples_Initialize(IMUMeasurement20_samples* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 20) {
	    IMUSample_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 0;
}
void IMUMeasurement20_Initialize(IMUMeasurement20* pVal)
{


	/*set attributes */
	SampleAttributes_Initialize((&(pVal->attributes)));
	/*set samples */
	IMUMeasurement20_samples_Initialize((&(pVal->samples)));
	/*set batch_size */
	T_UInt32_Initialize((&(pVal->batch_size)));
}

flag IMUMeasurement20_IsConstraintValid(const IMUMeasurement20* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
    *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_VALIDITY; 
    if (ret) {
        ret = (pVal->attributes.attributes.nCount <= 4);
        *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++) 
            {
            	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
            	*pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY; 
            	if (ret) {
            	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE; 
            	    }
            	    if (ret) {
            	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
            	        	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
            	        	*pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE; 
            	        }
            	    }
            	}
            }
        }
    }
    if (ret) {
        ret = (pVal->samples.nCount <= 20);
        *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->samples.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_x_rate) && (pVal->samples.arr[i1].axis_x_rate <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_RATE; 
            	if (ret) {
            	    ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_x_acceleration) && (pVal->samples.arr[i1].axis_x_acceleration <= 1.79769313486231570000E+308));
            	    *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_X_ACCELERATION; 
            	    if (ret) {
            	        ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_y_rate) && (pVal->samples.arr[i1].axis_y_rate <= 1.79769313486231570000E+308));
            	        *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_RATE; 
            	        if (ret) {
            	            ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_y_acceleration) && (pVal->samples.arr[i1].axis_y_acceleration <= 1.79769313486231570000E+308));
            	            *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Y_ACCELERATION; 
            	            if (ret) {
            	                ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_z_rate) && (pVal->samples.arr[i1].axis_z_rate <= 1.79769313486231570000E+308));
            	                *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_RATE; 
            	                if (ret) {
            	                    ret = ((-1.79769313486231570000E+308 <= pVal->samples.arr[i1].axis_z_acceleration) && (pVal->samples.arr[i1].axis_z_acceleration <= 1.79769313486231570000E+308));
            	                    *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_SAMPLES_ELM_AXIS_Z_ACCELERATION; 
            	                }
            	            }
            	        }
            	    }
            	}
            }
        }
        if (ret) {
            ret = (pVal->batch_size <= 4294967295UL);
            *pErrCode = ret ? 0 :  ERR_IMUMEASUREMENT20_BATCH_SIZE; 
        }
    }

	return ret;
}

flag IMUMeasurement20_Encode(const IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? IMUMeasurement20_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode attributes */
	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode samples */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->samples.nCount, 0, 20);
	        	
	        for(i1=0; (i1 < (int)pVal->samples.nCount) && ret; i1++) 
	        {
	        	ret = IMUSample_Encode((&(pVal->samples.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode batch_size */
	            ret = BatchSize_Encode((&(pVal->batch_size)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag IMUMeasurement20_Decode(IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode attributes */
	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode samples */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 20);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_IMUMEASUREMENT20_SAMPLES;
	    pVal->samples.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->samples.nCount) && ret; i1++) 
	    {
	    	ret = IMUSample_Decode((&(pVal->samples.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode batch_size */
	        ret = BatchSize_Decode((&(pVal->batch_size)), pBitStrm, pErrCode);
	    }
	}

	return ret  && IMUMeasurement20_IsConstraintValid(pVal, pErrCode);
}

