/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "IMU.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void IMUSample_Initialize(IMUSample* pVal)
{
  *pVal = (IMUSample)
  {
    .axis_x_rate = 0.00000000000000000000E+000,
     .axis_x_acceleration = 0.00000000000000000000E+000,
      .axis_y_rate = 0.00000000000000000000E+000,
       .axis_y_acceleration = 0.00000000000000000000E+000,
        .axis_z_rate = 0.00000000000000000000E+000,
         .axis_z_acceleration = 0.00000000000000000000E+000
  };
}
#endif


flag IMUSample_IsConstraintValid(const IMUSample* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = T_Double_IsConstraintValid(&pVal->axis_x_rate, pErrCode);
  if (ret)
    {
      ret = T_Double_IsConstraintValid(&pVal->axis_x_acceleration, pErrCode);
      if (ret)
        {
          ret = T_Double_IsConstraintValid(&pVal->axis_y_rate, pErrCode);
          if (ret)
            {
              ret = T_Double_IsConstraintValid(&pVal->axis_y_acceleration, pErrCode);
              if (ret)
                {
                  ret = T_Double_IsConstraintValid(&pVal->axis_z_rate, pErrCode);
                  if (ret)
                    {
                      ret = T_Double_IsConstraintValid(&pVal->axis_z_acceleration, pErrCode);

                    }
                }
            }
        }
    }

  return ret;
}

flag IMUSample_Encode(const IMUSample* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? IMUSample_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode axis_x_rate */
      ret = T_Double_Encode(&pVal->axis_x_rate, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode axis_x_acceleration */
          ret = T_Double_Encode(&pVal->axis_x_acceleration, pBitStrm, pErrCode, FALSE);
          if (ret)
            {
              /*Encode axis_y_rate */
              ret = T_Double_Encode(&pVal->axis_y_rate, pBitStrm, pErrCode, FALSE);
              if (ret)
                {
                  /*Encode axis_y_acceleration */
                  ret = T_Double_Encode(&pVal->axis_y_acceleration, pBitStrm, pErrCode, FALSE);
                  if (ret)
                    {
                      /*Encode axis_z_rate */
                      ret = T_Double_Encode(&pVal->axis_z_rate, pBitStrm, pErrCode, FALSE);
                      if (ret)
                        {
                          /*Encode axis_z_acceleration */
                          ret = T_Double_Encode(&pVal->axis_z_acceleration, pBitStrm, pErrCode, FALSE);

                        }
                    }
                }
            }
        }
    }

  return ret;
}

flag IMUSample_Decode(IMUSample* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode axis_x_rate */
  ret = T_Double_Decode(&pVal->axis_x_rate, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode axis_x_acceleration */
      ret = T_Double_Decode(&pVal->axis_x_acceleration, pBitStrm, pErrCode);
      if (ret)
        {
          /*Decode axis_y_rate */
          ret = T_Double_Decode(&pVal->axis_y_rate, pBitStrm, pErrCode);
          if (ret)
            {
              /*Decode axis_y_acceleration */
              ret = T_Double_Decode(&pVal->axis_y_acceleration, pBitStrm, pErrCode);
              if (ret)
                {
                  /*Decode axis_z_rate */
                  ret = T_Double_Decode(&pVal->axis_z_rate, pBitStrm, pErrCode);
                  if (ret)
                    {
                      /*Decode axis_z_acceleration */
                      ret = T_Double_Decode(&pVal->axis_z_acceleration, pBitStrm, pErrCode);

                    }
                }
            }
        }
    }


  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void IMUMeasurement20_samples_Initialize(IMUMeasurement20_samples* pVal)
{
  *pVal = (IMUMeasurement20_samples)
  {
    .nCount = 0,    .arr =
    {

    }
  };
}
#endif


flag IMUMeasurement20_samples_IsConstraintValid(const IMUMeasurement20_samples* pVal, int* pErrCode)
{

  flag ret = TRUE;
  int i1=0;
  *pErrCode=0;

  (void)pVal;

  ret = (0 <= pVal->nCount && pVal->nCount <= 20);
  *pErrCode = ret ? 0 : ERR_IMUMeasurement20_samples;
  i1 = 0;
  while (ret && (i1< pVal->nCount))
    {
      ret = IMUSample_IsConstraintValid(&pVal->arr[i1], pErrCode);
      i1 = i1+1;
    }

  return ret;
}

flag IMUMeasurement20_samples_Encode(const IMUMeasurement20_samples* pVal, BitStream* pBitStrm, int* pErrCode,
                                     flag bCheckConstraints)
{
  flag ret = TRUE;
  int i1=0;

  ret = bCheckConstraints ? IMUMeasurement20_samples_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 0, 20);

      for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
        {
          ret = IMUSample_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
        }
    }

  return ret;
}

flag IMUMeasurement20_samples_Decode(IMUMeasurement20_samples* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;
  asn1SccSint nCount;
  int i1=0;

  ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 0, 20);
  *pErrCode = ret ? 0 : 270794753;
  pVal->nCount = (long)nCount;

  for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++)
    {
      ret = IMUSample_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
    }

  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void IMUMeasurement20_Initialize(IMUMeasurement20* pVal)
{
  *pVal = (IMUMeasurement20)
  {
    .attributes =
    {
      .timestamp = -9223372036854775807LL,
      .validity = sample_empty,
      .attributes = {
        .nCount = 0,    .arr =
        {

        }
      }
    },
    .samples = {    .nCount = 0,    .arr =
      {

      }
    },
    .batch_size = 0
  };
}
#endif


flag IMUMeasurement20_IsConstraintValid(const IMUMeasurement20* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = SampleAttributes_IsConstraintValid(&pVal->attributes, pErrCode);
  if (ret)
    {
      ret = IMUMeasurement20_samples_IsConstraintValid(&pVal->samples, pErrCode);
      if (ret)
        {
          ret = BatchSize_IsConstraintValid(&pVal->batch_size, pErrCode);

        }
    }

  return ret;
}

flag IMUMeasurement20_Encode(const IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? IMUMeasurement20_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode attributes */
      ret = SampleAttributes_Encode(&pVal->attributes, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode samples */
          ret = IMUMeasurement20_samples_Encode(&pVal->samples, pBitStrm, pErrCode, FALSE);
          if (ret)
            {
              /*Encode batch_size */
              ret = BatchSize_Encode(&pVal->batch_size, pBitStrm, pErrCode, FALSE);

            }
        }
    }

  return ret;
}

flag IMUMeasurement20_Decode(IMUMeasurement20* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode attributes */
  ret = SampleAttributes_Decode(&pVal->attributes, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode samples */
      ret = IMUMeasurement20_samples_Decode(&pVal->samples, pBitStrm, pErrCode);
      if (ret)
        {
          /*Decode batch_size */
          ret = BatchSize_Decode(&pVal->batch_size, pBitStrm, pErrCode);

        }
    }


  return ret;
}

