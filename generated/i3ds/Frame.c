/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Frame.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void Frame_mode_t_Initialize(Frame_mode_t* pVal)
{
  *pVal = (Frame_mode_t) mode_undefined;
}
#endif


flag Frame_mode_t_IsConstraintValid(const Frame_mode_t* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = ((((((((((((((*pVal == mode_undefined) || (*pVal == mode_mono)) || (*pVal == mode_rgb)) || (*pVal == mode_bgr))
                  || (*pVal == mode_uyvy)) || (*pVal == mode_rgba)) || (*pVal == mode_bayer_rggb)) || (*pVal == mode_bayer_grbg))
              || (*pVal == mode_bayer_bggr)) || (*pVal == mode_bayer_gbrg)) || (*pVal == mode_pjpg)) || (*pVal == mode_jpeg))
          || (*pVal == mode_png)) || (*pVal == mode_tiff));
  *pErrCode = ret ? 0 : ERR_Frame_mode_t;

  return ret;
}

flag Frame_mode_t_Encode(const Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? Frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      switch(*pVal)
        {
        case mode_undefined:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 13);
          break;
        case mode_mono:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 13);
          break;
        case mode_rgb:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 13);
          break;
        case mode_bgr:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 13);
          break;
        case mode_uyvy:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 13);
          break;
        case mode_rgba:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 13);
          break;
        case mode_bayer_rggb:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 13);
          break;
        case mode_bayer_grbg:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 13);
          break;
        case mode_bayer_bggr:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 13);
          break;
        case mode_bayer_gbrg:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 13);
          break;
        case mode_pjpg:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 13);
          break;
        case mode_jpeg:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 13);
          break;
        case mode_png:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 13);
          break;
        case mode_tiff:
          BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 13);
          break;
        default:
          *pErrCode = 1077149697; //COVERAGE_IGNORE
          ret = FALSE;            //COVERAGE_IGNORE
        }
    }

  return ret;
}

flag Frame_mode_t_Decode(Frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;
  asn1SccSint enumIndex;

  ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 13);
  *pErrCode = ret ? 0 : 271843329;
  if (ret)
    {
      switch(enumIndex)
        {
        case 0:
          *pVal = mode_undefined;
          break;
        case 1:
          *pVal = mode_mono;
          break;
        case 2:
          *pVal = mode_rgb;
          break;
        case 3:
          *pVal = mode_bgr;
          break;
        case 4:
          *pVal = mode_uyvy;
          break;
        case 5:
          *pVal = mode_rgba;
          break;
        case 6:
          *pVal = mode_bayer_rggb;
          break;
        case 7:
          *pVal = mode_bayer_grbg;
          break;
        case 8:
          *pVal = mode_bayer_bggr;
          break;
        case 9:
          *pVal = mode_bayer_gbrg;
          break;
        case 10:
          *pVal = mode_pjpg;
          break;
        case 11:
          *pVal = mode_jpeg;
          break;
        case 12:
          *pVal = mode_png;
          break;
        case 13:
          *pVal = mode_tiff;
          break;
        default:
          *pErrCode = 1077149698;     //COVERAGE_IGNORE
          ret = FALSE;                //COVERAGE_IGNORE
        }
    }

  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void FrameDescriptor_Initialize(FrameDescriptor* pVal)
{
  *pVal = (FrameDescriptor)
  {
    .attributes =
    {
      .timestamp = -9223372036854775807LL,
      .validity = sample_empty,
      .attributes = {
        .nCount = 0,    .arr =
        {

        }
      }
    },
    .frame_mode = mode_undefined,
     .data_depth = 0,
      .pixel_size = 0,
       .region =
    {
      .offset_x = 0,
      .offset_y = 0,
      .size_x = 0,
      .size_y = 0
    },
    .image_count = 0
  };
}
#endif


flag FrameDescriptor_IsConstraintValid(const FrameDescriptor* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = SampleAttributes_IsConstraintValid(&pVal->attributes, pErrCode);
  if (ret)
    {
      ret = Frame_mode_t_IsConstraintValid(&pVal->frame_mode, pErrCode);
      if (ret)
        {
          ret = T_UInt8_IsConstraintValid(&pVal->data_depth, pErrCode);
          if (ret)
            {
              ret = T_UInt8_IsConstraintValid(&pVal->pixel_size, pErrCode);
              if (ret)
                {
                  ret = PlanarRegion_IsConstraintValid(&pVal->region, pErrCode);
                  if (ret)
                    {
                      ret = T_UInt8_IsConstraintValid(&pVal->image_count, pErrCode);

                    }
                }
            }
        }
    }

  return ret;
}

flag FrameDescriptor_Encode(const FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? FrameDescriptor_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode attributes */
      ret = SampleAttributes_Encode(&pVal->attributes, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode frame_mode */
          ret = Frame_mode_t_Encode(&pVal->frame_mode, pBitStrm, pErrCode, FALSE);
          if (ret)
            {
              /*Encode data_depth */
              ret = T_UInt8_Encode(&pVal->data_depth, pBitStrm, pErrCode, FALSE);
              if (ret)
                {
                  /*Encode pixel_size */
                  ret = T_UInt8_Encode(&pVal->pixel_size, pBitStrm, pErrCode, FALSE);
                  if (ret)
                    {
                      /*Encode region */
                      ret = PlanarRegion_Encode(&pVal->region, pBitStrm, pErrCode, FALSE);
                      if (ret)
                        {
                          /*Encode image_count */
                          ret = T_UInt8_Encode(&pVal->image_count, pBitStrm, pErrCode, FALSE);

                        }
                    }
                }
            }
        }
    }

  return ret;
}

flag FrameDescriptor_Decode(FrameDescriptor* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode attributes */
  ret = SampleAttributes_Decode(&pVal->attributes, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode frame_mode */
      ret = Frame_mode_t_Decode(&pVal->frame_mode, pBitStrm, pErrCode);
      if (ret)
        {
          /*Decode data_depth */
          ret = T_UInt8_Decode(&pVal->data_depth, pBitStrm, pErrCode);
          if (ret)
            {
              /*Decode pixel_size */
              ret = T_UInt8_Decode(&pVal->pixel_size, pBitStrm, pErrCode);
              if (ret)
                {
                  /*Decode region */
                  ret = PlanarRegion_Decode(&pVal->region, pBitStrm, pErrCode);
                  if (ret)
                    {
                      /*Decode image_count */
                      ret = T_UInt8_Decode(&pVal->image_count, pBitStrm, pErrCode);

                    }
                }
            }
        }
    }


  return ret;
}

