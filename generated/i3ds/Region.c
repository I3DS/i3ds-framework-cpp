/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "Region.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void PlanarRegion_Initialize(PlanarRegion* pVal)
{
    *pVal = (PlanarRegion) {
    .offset_x = 0,
    .offset_y = 0,
    .size_x = 0,
    .size_y = 0
};
}
#endif

 
flag PlanarRegion_IsConstraintValid(const PlanarRegion* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = T_UInt16_IsConstraintValid(&pVal->offset_x, pErrCode);
	if (ret) {
	    ret = T_UInt16_IsConstraintValid(&pVal->offset_y, pErrCode);
	    if (ret) {
	        ret = T_UInt16_IsConstraintValid(&pVal->size_x, pErrCode);
	        if (ret) {
	            ret = T_UInt16_IsConstraintValid(&pVal->size_y, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag PlanarRegion_Encode(const PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? PlanarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode offset_x */
	    ret = T_UInt16_Encode(&pVal->offset_x, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode offset_y */
	        ret = T_UInt16_Encode(&pVal->offset_y, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode size_x */
	            ret = T_UInt16_Encode(&pVal->size_x, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode size_y */
	                ret = T_UInt16_Encode(&pVal->size_y, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag PlanarRegion_Decode(PlanarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode offset_x */
	ret = T_UInt16_Decode(&pVal->offset_x, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode offset_y */
	    ret = T_UInt16_Decode(&pVal->offset_y, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode size_x */
	        ret = T_UInt16_Decode(&pVal->size_x, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode size_y */
	            ret = T_UInt16_Decode(&pVal->size_y, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void PolarRegion_Initialize(PolarRegion* pVal)
{
    *pVal = (PolarRegion) {
    .offset_x = 0.00000000000000000000E+000,
    .offset_y = 0.00000000000000000000E+000,
    .size_x = 0.00000000000000000000E+000,
    .size_y = 0.00000000000000000000E+000
};
}
#endif

 
flag PolarRegion_IsConstraintValid(const PolarRegion* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = T_Float_IsConstraintValid(&pVal->offset_x, pErrCode);
	if (ret) {
	    ret = T_Float_IsConstraintValid(&pVal->offset_y, pErrCode);
	    if (ret) {
	        ret = T_Float_IsConstraintValid(&pVal->size_x, pErrCode);
	        if (ret) {
	            ret = T_Float_IsConstraintValid(&pVal->size_y, pErrCode);
	        
	        }
	    }
	}

	return ret;
}

flag PolarRegion_Encode(const PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
    
	ret = bCheckConstraints ? PolarRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode offset_x */
	    ret = T_Float_Encode(&pVal->offset_x, pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode offset_y */
	        ret = T_Float_Encode(&pVal->offset_y, pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode size_x */
	            ret = T_Float_Encode(&pVal->size_x, pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode size_y */
	                ret = T_Float_Encode(&pVal->size_y, pBitStrm, pErrCode, FALSE);
	            
	            }
	        }
	    }
    }

	return ret;
}

flag PolarRegion_Decode(PolarRegion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode offset_x */
	ret = T_Float_Decode(&pVal->offset_x, pBitStrm, pErrCode);
	if (ret) {
	    /*Decode offset_y */
	    ret = T_Float_Decode(&pVal->offset_y, pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode size_x */
	        ret = T_Float_Decode(&pVal->size_x, pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode size_y */
	            ret = T_Float_Decode(&pVal->size_y, pBitStrm, pErrCode);
	        
	        }
	    }
	}


	return ret;
}

