/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "LIDAR.h"



void LIDARMeasurement750K_points_Initialize(LIDARMeasurement750K_points* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 750000) {
	    Point_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void LIDARMeasurement750K_Initialize(LIDARMeasurement750K* pVal)
{


	/*set attributes */
	SampleAttributes_Initialize((&(pVal->attributes)));
	/*set points */
	LIDARMeasurement750K_points_Initialize((&(pVal->points)));
	/*set region */
	PolarRegion_Initialize((&(pVal->region)));
}

flag LIDARMeasurement750K_IsConstraintValid(const LIDARMeasurement750K* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = (-9223372036854775807LL <= pVal->attributes.timestamp);
    *pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_ATTRIBUTES_TIMESTAMP; 
    if (ret) {
        ret = (((((pVal->attributes.validity == sample_empty)) || ((pVal->attributes.validity == sample_valid)))) || ((pVal->attributes.validity == sample_invalid)));
        *pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_ATTRIBUTES_VALIDITY; 
        if (ret) {
            ret = (pVal->attributes.attributes.nCount <= 4);
            *pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_ATTRIBUTES_ATTRIBUTES; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->attributes.attributes.nCount; i1++) 
                {
                	ret = (pVal->attributes.attributes.arr[i1].attribute_key <= 255UL);
                	*pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_KEY; 
                	if (ret) {
                	    if (pVal->attributes.attributes.arr[i1].attribute_value.kind == discrete_value_PRESENT) {
                	    	ret = (-9223372036854775807LL <= pVal->attributes.attributes.arr[i1].attribute_value.u.discrete_value);
                	    	*pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_DISCRETE_VALUE; 
                	    }
                	    if (ret) {
                	        if (pVal->attributes.attributes.arr[i1].attribute_value.kind == real_value_PRESENT) {
                	        	ret = ((-1.79769313486231570000E+308 <= pVal->attributes.attributes.arr[i1].attribute_value.u.real_value) && (pVal->attributes.attributes.arr[i1].attribute_value.u.real_value <= 1.79769313486231570000E+308));
                	        	*pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_REAL_VALUE; 
                	        }
                	        if (ret) {
                	            if (pVal->attributes.attributes.arr[i1].attribute_value.kind == string_value_PRESENT) {
                	            	ret = (pVal->attributes.attributes.arr[i1].attribute_value.u.string_value.nCount <= 8);
                	            	*pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_ATTRIBUTES_ATTRIBUTES_ELM_ATTRIBUTE_VALUE_STRING_VALUE; 
                	            }
                	        }
                	    }
                	}
                }
            }
        }
    }
    if (ret) {
        ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 750000));
        *pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_POINTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->points.nCount; i1++) 
            {
            	ret = ((1 <= pVal->points.arr[i1].nCount) && (pVal->points.arr[i1].nCount <= 3));
            	*pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_POINTS_ELM; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->points.arr[i1].nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].arr[i2]) && (pVal->points.arr[i1].arr[i2] <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_POINTS_ELM_ELM; 
            	    }
            	}
            }
        }
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_x) && (pVal->region.offset_x <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_REGION_OFFSET_X; 
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_y) && (pVal->region.offset_y <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_REGION_OFFSET_Y; 
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->region.size_x) && (pVal->region.size_x <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_REGION_SIZE_X; 
                    if (ret) {
                        ret = ((-3.40282346600000020000E+038 <= pVal->region.size_y) && (pVal->region.size_y <= 3.40282346600000020000E+038));
                        *pErrCode = ret ? 0 :  ERR_LIDARMEASUREMENT750K_REGION_SIZE_Y; 
                    }
                }
            }
        }
    }

	return ret;
}

flag LIDARMeasurement750K_Encode(const LIDARMeasurement750K* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nBlockIndex1;
	asn1SccSint nRemainingItemsVar1;
	asn1SccSint nCurBlockSize1;
	asn1SccSint nCurOffset1;
	ret = bCheckConstraints ? LIDARMeasurement750K_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode attributes */
	    ret = SampleAttributes_Encode((&(pVal->attributes)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode points */
	        nRemainingItemsVar1 = pVal->points.nCount;
	        nCurBlockSize1 = 0;
	        nCurOffset1 = 0;
	        nBlockIndex1 = 0;
	        while (nRemainingItemsVar1 >= 0x4000 && nBlockIndex1 < pVal->points.nCount) 
	        {
	        	if (nRemainingItemsVar1 >= 0x10000)
	        	{
	        		nCurBlockSize1 = 0x10000;
	        		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC4, 0, 0xFF); 
	        	}
	        	else if (nRemainingItemsVar1 >= 0xC000)
	        	{
	        		nCurBlockSize1 = 0xC000;
	        		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC3, 0, 0xFF); 
	        	}
	        	else if (nRemainingItemsVar1 >= 0x8000)
	        	{
	        		nCurBlockSize1 = 0x8000;
	        		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC2, 0, 0xFF); 
	        	}
	        	else 
	        	{
	        		nCurBlockSize1 = 0x4000;
	        		BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC1, 0, 0xFF); 
	        	}
	        	
	        	for(i1=(int)nCurOffset1; i1 < (int)(nCurBlockSize1 + nCurOffset1); i1++)
	        	{
	        		ret = Point_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
	        	}
	        	nCurOffset1 += nCurBlockSize1;
	        	nRemainingItemsVar1 -= nCurBlockSize1;
	            nBlockIndex1 = nBlockIndex1+1;
	        }

	        if (nRemainingItemsVar1 <= 0x7F)
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, nRemainingItemsVar1, 0, 0xFF);
	        else
	        {
	        	BitStream_AppendBit(pBitStrm, 1);
	        	BitStream_EncodeConstraintWholeNumber(pBitStrm, nRemainingItemsVar1, 0, 0x7FFF);
	        }

	        for(i1=(int)nCurOffset1; i1 < (int)(nCurOffset1 + nRemainingItemsVar1); i1++)
	        {
	        	ret = Point_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode region */
	            ret = PolarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag LIDARMeasurement750K_Decode(LIDARMeasurement750K* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nLengthTmp1;
	asn1SccSint nRemainingItemsVar1;
	asn1SccSint nCurBlockSize1;
	asn1SccSint nCurOffset1;

	/*Decode attributes */
	ret = SampleAttributes_Decode((&(pVal->attributes)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode points */
	    nRemainingItemsVar1 = 0;
	    nCurBlockSize1 = 0;
	    nCurOffset1 = 0;
	    nLengthTmp1 = 0;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nRemainingItemsVar1, 0, 0xFF);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_LIDARMEASUREMENT750K_POINTS;
	    if (ret) {
	    	while(ret && (nRemainingItemsVar1 & 0xC0)==0xC0) 
	    	{
	    		if (nRemainingItemsVar1 == 0xC4)
	    			nCurBlockSize1 = 0x10000;
	    		else if (nRemainingItemsVar1 == 0xC3)
	    			nCurBlockSize1 = 0xC000;
	    		else if (nRemainingItemsVar1 == 0xC2)
	    			nCurBlockSize1 = 0x8000;
	    		else if (nRemainingItemsVar1 == 0xC1)
	    			nCurBlockSize1 = 0x4000;
	    		else {
	    			*pErrCode = ERR_UPER_DECODE_LIDARMEASUREMENT750K_POINTS; /*COVERAGE_IGNORE*/
	    			return FALSE; /*COVERAGE_IGNORE*/
	    		}
	    		if (nCurOffset1 + nCurBlockSize1 > 750000)
	    		{
	    			*pErrCode = ERR_UPER_DECODE_LIDARMEASUREMENT750K_POINTS; /*COVERAGE_IGNORE*/
	    			return FALSE; /*COVERAGE_IGNORE*/
	    		}

	    		for(i1=(int)nCurOffset1; ret && (i1 < (int)(nCurOffset1 + nCurBlockSize1)) ; i1++)
	    		{
	    			ret = Point_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
	    		}
	    	
	            if (ret) {
	    		    nLengthTmp1 += (long)nCurBlockSize1;
	    		    nCurOffset1 += nCurBlockSize1;
	    		    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nRemainingItemsVar1, 0, 0xFF);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_LIDARMEASUREMENT750K_POINTS;
	            }
	    	}
	        if (ret) {
	    	    if ( (nRemainingItemsVar1 & 0x80)>0) 
	    	    {
	    		    asn1SccSint len2;
	    		    nRemainingItemsVar1 <<= 8;
	    		    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_LIDARMEASUREMENT750K_POINTS;
	                if (ret) {
	    		        nRemainingItemsVar1 |= len2;
	    		        nRemainingItemsVar1 &= 0x7FFF;
	                }
	    	    }
	            ret = ret && (nCurOffset1 + nRemainingItemsVar1 <= 750000);
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_LIDARMEASUREMENT750K_POINTS;
	            if (ret) {
	    	        for(i1=(int)nCurOffset1; ret && (i1 < (int)(nCurOffset1 + nRemainingItemsVar1)) ; i1++)
	    	        {
	    		        ret = Point_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
	    	        }
	                if (ret) {
	    	            nLengthTmp1 += (long)nRemainingItemsVar1;

	                    if ((nLengthTmp1 >= 1) && (nLengthTmp1 <= 750000)) {
	    	                pVal->points.nCount = (int)nLengthTmp1;

	                    } else {
	                        ret = FALSE;  /*COVERAGE_IGNORE*/
	                        *pErrCode = ERR_UPER_DECODE_LIDARMEASUREMENT750K_POINTS; /*COVERAGE_IGNORE*/
	                    }

	                }
	            }
	        }
	    }
	    if (ret) {
	        /*Decode region */
	        ret = PolarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
	    }
	}

	return ret  && LIDARMeasurement750K_IsConstraintValid(pVal, pErrCode);
}



void LIDARRegion_Initialize(LIDARRegion* pVal)
{


	/*set enable */
	T_Boolean_Initialize((&(pVal->enable)));
	/*set region */
	PolarRegion_Initialize((&(pVal->region)));
}

flag LIDARRegion_IsConstraintValid(const LIDARRegion* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_x) && (pVal->region.offset_x <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_LIDARREGION_REGION_OFFSET_X; 
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_y) && (pVal->region.offset_y <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_LIDARREGION_REGION_OFFSET_Y; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->region.size_x) && (pVal->region.size_x <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_LIDARREGION_REGION_SIZE_X; 
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->region.size_y) && (pVal->region.size_y <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_LIDARREGION_REGION_SIZE_Y; 
            }
        }
    }

	return ret;
}

flag LIDARRegion_Encode(const LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? LIDARRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode enable */
	    ret = T_Boolean_Encode((&(pVal->enable)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode region */
	        ret = PolarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag LIDARRegion_Decode(LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode enable */
	ret = T_Boolean_Decode((&(pVal->enable)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode region */
	    ret = PolarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
	}

	return ret  && LIDARRegion_IsConstraintValid(pVal, pErrCode);
}



void LIDARConfiguration_Initialize(LIDARConfiguration* pVal)
{


	/*set region_enabled */
	T_Boolean_Initialize((&(pVal->region_enabled)));
	/*set region */
	PolarRegion_Initialize((&(pVal->region)));
}

flag LIDARConfiguration_IsConstraintValid(const LIDARConfiguration* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_x) && (pVal->region.offset_x <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_LIDARCONFIGURATION_REGION_OFFSET_X; 
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->region.offset_y) && (pVal->region.offset_y <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_LIDARCONFIGURATION_REGION_OFFSET_Y; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->region.size_x) && (pVal->region.size_x <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_LIDARCONFIGURATION_REGION_SIZE_X; 
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->region.size_y) && (pVal->region.size_y <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_LIDARCONFIGURATION_REGION_SIZE_Y; 
            }
        }
    }

	return ret;
}

flag LIDARConfiguration_Encode(const LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? LIDARConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode region_enabled */
	    ret = T_Boolean_Encode((&(pVal->region_enabled)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode region */
	        ret = PolarRegion_Encode((&(pVal->region)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag LIDARConfiguration_Decode(LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode region_enabled */
	ret = T_Boolean_Decode((&(pVal->region_enabled)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode region */
	    ret = PolarRegion_Decode((&(pVal->region)), pBitStrm, pErrCode);
	}

	return ret  && LIDARConfiguration_IsConstraintValid(pVal, pErrCode);
}

