/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "LIDAR.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LIDARMeasurement200K_points_Initialize(LIDARMeasurement200K_points* pVal)
{
  *pVal = (LIDARMeasurement200K_points)
  {
    .nCount = 1,    .arr =
    {
      {
        .nCount = 1,    .arr =
        {
          0.00000000000000000000E+000
        }
      }
    }
  };
}
#endif


flag LIDARMeasurement200K_points_IsConstraintValid(const LIDARMeasurement200K_points* pVal, int* pErrCode)
{

  flag ret = TRUE;
  int i1=0;
  *pErrCode=0;

  (void)pVal;

  ret = (1 <= pVal->nCount && pVal->nCount <= 200000);
  *pErrCode = ret ? 0 : ERR_LIDARMeasurement200K_points;
  i1 = 0;
  while (ret && (i1< pVal->nCount))
    {
      ret = Point_IsConstraintValid(&pVal->arr[i1], pErrCode);
      i1 = i1+1;
    }

  return ret;
}

flag LIDARMeasurement200K_points_Encode(const LIDARMeasurement200K_points* pVal, BitStream* pBitStrm, int* pErrCode,
                                        flag bCheckConstraints)
{
  flag ret = TRUE;
  int i1=0;

  ret = bCheckConstraints ? LIDARMeasurement200K_points_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      {
        asn1SccSint nCount1 = pVal->nCount;
        asn1SccSint curBlockSize1 = 0;
        asn1SccSint curItem1 = 0;
        while (nCount1 >= 0x4000)
          {
            if (nCount1 >= 0x10000)
              {
                curBlockSize1 = 0x10000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC4, 0, 0xFF);
              }
            else if (nCount1 >= 0xC000)
              {
                curBlockSize1 = 0xC000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC3, 0, 0xFF);
              }
            else if (nCount1 >= 0x8000)
              {
                curBlockSize1 = 0x8000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC2, 0, 0xFF);
              }
            else
              {
                curBlockSize1 = 0x4000;
                BitStream_EncodeConstraintWholeNumber(pBitStrm, 0xC1, 0, 0xFF);
              }

            for(i1=(int)curItem1; i1 < curBlockSize1 + curItem1; i1++)
              {
                ret = Point_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
              }
            curItem1 += curBlockSize1;
            nCount1 -= curBlockSize1;
          }

        if (nCount1 <= 0x7F)
          {
            BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount1, 0, 0xFF);
          }
        else
          {
            BitStream_AppendBit(pBitStrm, 1);
            BitStream_EncodeConstraintWholeNumber(pBitStrm, nCount1, 0, 0x7FFF);
          }

        for(i1=(int)curItem1; i1 < curItem1 + nCount1; i1++)
          {
            ret = Point_Encode(&pVal->arr[i1], pBitStrm, pErrCode, FALSE);
          }
      }
    }

  return ret;
}

flag LIDARMeasurement200K_points_Decode(LIDARMeasurement200K_points* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;
  int i1=0;

  {
    asn1SccSint nCount1 = 0;
    asn1SccSint curBlockSize1 = 0;
    asn1SccSint curItem1 = 0;
    pVal->nCount = 0;
    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount1, 0, 0xFF);
    *pErrCode = ret ? 0 : 272105473;
    if (ret)
      {
        while(ret && (nCount1 & 0xC0)==0xC0)
          {
            if (nCount1 == 0xC4)
              {
                curBlockSize1 = 0x10000;
              }
            else if (nCount1 == 0xC3)
              {
                curBlockSize1 = 0xC000;
              }
            else if (nCount1 == 0xC2)
              {
                curBlockSize1 = 0x8000;
              }
            else if (nCount1 == 0xC1)
              {
                curBlockSize1 = 0x4000;
              }
            else
              {
                *pErrCode = 540540929;
                return FALSE;
              }
            if (curItem1 + curBlockSize1 > 200000)
              {
                *pErrCode = 272105474;
                return FALSE;
              }

            for(i1=curItem1; ret && (i1 < curItem1 + curBlockSize1) ; i1++)
              {
                ret = Point_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
              }

            if (ret)
              {
                pVal->nCount += (long)curBlockSize1;
                curItem1 += curBlockSize1;
                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount1, 0, 0xFF);
                *pErrCode = ret ? 0 : 272105475;
              }
          }
        if (ret)
          {
            if ( (nCount1 & 0x80)>0)
              {
                asn1SccSint len2;
                nCount1 <<= 8;
                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &len2, 0, 0xFF);
                *pErrCode = ret ? 0 : 272105476;
                if (ret)
                  {
                    nCount1 |= len2;
                    nCount1 &= 0x7FFF;
                  }
              }
            ret = ret && (curItem1 + nCount1 <= 200000);
            *pErrCode = ret ? 0 : 272105477;
            if (ret)
              {
                for(i1=curItem1; ret && (i1 < curItem1 + nCount1) ; i1++)
                  {
                    ret = Point_Decode(&pVal->arr[i1], pBitStrm, pErrCode);
                  }
                if (ret)
                  {
                    pVal->nCount += (long)nCount1;
                  }
              }
          }
      }
  }

  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LIDARMeasurement200K_Initialize(LIDARMeasurement200K* pVal)
{
  *pVal = (LIDARMeasurement200K)
  {
    .attributes =
    {
      .timestamp = -9223372036854775807LL,
      .validity = sample_empty,
      .attributes = {
        .nCount = 0,    .arr =
        {

        }
      }
    },
    .points = {    .nCount = 1,    .arr =
      {
        {
          .nCount = 1,    .arr =
          {
            0.00000000000000000000E+000
          }
        }
      }
    },
    .region =
    {
      .offset_x = 0.00000000000000000000E+000,
      .offset_y = 0.00000000000000000000E+000,
      .size_x = 0.00000000000000000000E+000,
      .size_y = 0.00000000000000000000E+000
    }
  };
}
#endif


flag LIDARMeasurement200K_IsConstraintValid(const LIDARMeasurement200K* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = SampleAttributes_IsConstraintValid(&pVal->attributes, pErrCode);
  if (ret)
    {
      ret = LIDARMeasurement200K_points_IsConstraintValid(&pVal->points, pErrCode);
      if (ret)
        {
          ret = PolarRegion_IsConstraintValid(&pVal->region, pErrCode);

        }
    }

  return ret;
}

flag LIDARMeasurement200K_Encode(const LIDARMeasurement200K* pVal, BitStream* pBitStrm, int* pErrCode,
                                 flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? LIDARMeasurement200K_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode attributes */
      ret = SampleAttributes_Encode(&pVal->attributes, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode points */
          ret = LIDARMeasurement200K_points_Encode(&pVal->points, pBitStrm, pErrCode, FALSE);
          if (ret)
            {
              /*Encode region */
              ret = PolarRegion_Encode(&pVal->region, pBitStrm, pErrCode, FALSE);

            }
        }
    }

  return ret;
}

flag LIDARMeasurement200K_Decode(LIDARMeasurement200K* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode attributes */
  ret = SampleAttributes_Decode(&pVal->attributes, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode points */
      ret = LIDARMeasurement200K_points_Decode(&pVal->points, pBitStrm, pErrCode);
      if (ret)
        {
          /*Decode region */
          ret = PolarRegion_Decode(&pVal->region, pBitStrm, pErrCode);

        }
    }


  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LIDARRegion_Initialize(LIDARRegion* pVal)
{
  *pVal = (LIDARRegion)
  {
    .enable = FALSE,
     .region =
    {
      .offset_x = 0.00000000000000000000E+000,
      .offset_y = 0.00000000000000000000E+000,
      .size_x = 0.00000000000000000000E+000,
      .size_y = 0.00000000000000000000E+000
    }
  };
}
#endif


flag LIDARRegion_IsConstraintValid(const LIDARRegion* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = T_Boolean_IsConstraintValid(&pVal->enable, pErrCode);
  if (ret)
    {
      ret = PolarRegion_IsConstraintValid(&pVal->region, pErrCode);

    }

  return ret;
}

flag LIDARRegion_Encode(const LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? LIDARRegion_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode enable */
      ret = T_Boolean_Encode(&pVal->enable, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode region */
          ret = PolarRegion_Encode(&pVal->region, pBitStrm, pErrCode, FALSE);

        }
    }

  return ret;
}

flag LIDARRegion_Decode(LIDARRegion* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode enable */
  ret = T_Boolean_Decode(&pVal->enable, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode region */
      ret = PolarRegion_Decode(&pVal->region, pBitStrm, pErrCode);

    }


  return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void LIDARConfiguration_Initialize(LIDARConfiguration* pVal)
{
  *pVal = (LIDARConfiguration)
  {
    .region_enabled = FALSE,
     .region =
    {
      .offset_x = 0.00000000000000000000E+000,
      .offset_y = 0.00000000000000000000E+000,
      .size_x = 0.00000000000000000000E+000,
      .size_y = 0.00000000000000000000E+000
    }
  };
}
#endif


flag LIDARConfiguration_IsConstraintValid(const LIDARConfiguration* pVal, int* pErrCode)
{

  flag ret = TRUE;
  *pErrCode=0;

  (void)pVal;

  ret = T_Boolean_IsConstraintValid(&pVal->region_enabled, pErrCode);
  if (ret)
    {
      ret = PolarRegion_IsConstraintValid(&pVal->region, pErrCode);

    }

  return ret;
}

flag LIDARConfiguration_Encode(const LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode,
                               flag bCheckConstraints)
{
  flag ret = TRUE;

  ret = bCheckConstraints ? LIDARConfiguration_IsConstraintValid(pVal, pErrCode) : TRUE ;
  if (ret)
    {
      /*Encode region_enabled */
      ret = T_Boolean_Encode(&pVal->region_enabled, pBitStrm, pErrCode, FALSE);
      if (ret)
        {
          /*Encode region */
          ret = PolarRegion_Encode(&pVal->region, pBitStrm, pErrCode, FALSE);

        }
    }

  return ret;
}

flag LIDARConfiguration_Decode(LIDARConfiguration* pVal, BitStream* pBitStrm, int* pErrCode)
{
  flag ret = TRUE;

  /*Decode region_enabled */
  ret = T_Boolean_Decode(&pVal->region_enabled, pBitStrm, pErrCode);
  if (ret)
    {
      /*Decode region */
      ret = PolarRegion_Decode(&pVal->region, pBitStrm, pErrCode);

    }


  return ret;
}

