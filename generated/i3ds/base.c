/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "base.h"



void Base_Angle_Initialize(Base_Angle* pVal)
{


	/*set rad */
	T_Double_Initialize((&(pVal->rad)));
}

flag Base_Angle_IsConstraintValid(const Base_Angle* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->rad) && (pVal->rad <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_ANGLE_RAD; 

	return ret;
}

flag Base_Angle_Encode(const Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Angle_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rad */
	    ret = T_Double_Encode((&(pVal->rad)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Angle_Decode(Base_Angle* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode rad */
	ret = T_Double_Decode((&(pVal->rad)), pBitStrm, pErrCode);

	return ret  && Base_Angle_IsConstraintValid(pVal, pErrCode);
}



void Base_commands_Motion2D_Initialize(Base_commands_Motion2D* pVal)
{


	/*set translation */
	T_Double_Initialize((&(pVal->translation)));
	/*set rotation */
	T_Double_Initialize((&(pVal->rotation)));
	/*set heading */
	Base_Angle_Initialize((&(pVal->heading)));
}

flag Base_commands_Motion2D_IsConstraintValid(const Base_commands_Motion2D* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_TRANSLATION; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_ROTATION; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_MOTION2D_HEADING_RAD; 
        }
    }

	return ret;
}

flag Base_commands_Motion2D_Encode(const Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_commands_Motion2D_Decode(Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
}



void Base_PoseUpdateThreshold_Initialize(Base_PoseUpdateThreshold* pVal)
{


	/*set distance */
	T_Double_Initialize((&(pVal->distance)));
	/*set angle */
	T_Double_Initialize((&(pVal->angle)));
}

flag Base_PoseUpdateThreshold_IsConstraintValid(const Base_PoseUpdateThreshold* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->distance) && (pVal->distance <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_POSEUPDATETHRESHOLD_DISTANCE; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->angle) && (pVal->angle <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_POSEUPDATETHRESHOLD_ANGLE; 
    }

	return ret;
}

flag Base_PoseUpdateThreshold_Encode(const Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode distance */
	    ret = T_Double_Encode((&(pVal->distance)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode angle */
	        ret = T_Double_Encode((&(pVal->angle)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_PoseUpdateThreshold_Decode(Base_PoseUpdateThreshold* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode distance */
	ret = T_Double_Decode((&(pVal->distance)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode angle */
	    ret = T_Double_Decode((&(pVal->angle)), pBitStrm, pErrCode);
	}

	return ret  && Base_PoseUpdateThreshold_IsConstraintValid(pVal, pErrCode);
}



void Base_Temperature_Initialize(Base_Temperature* pVal)
{


	/*set kelvin */
	T_Double_Initialize((&(pVal->kelvin)));
}

flag Base_Temperature_IsConstraintValid(const Base_Temperature* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->kelvin) && (pVal->kelvin <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_TEMPERATURE_KELVIN; 

	return ret;
}

flag Base_Temperature_Encode(const Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Temperature_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode kelvin */
	    ret = T_Double_Encode((&(pVal->kelvin)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Temperature_Decode(Base_Temperature* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode kelvin */
	ret = T_Double_Decode((&(pVal->kelvin)), pBitStrm, pErrCode);

	return ret  && Base_Temperature_IsConstraintValid(pVal, pErrCode);
}



void Base_commands_Speed6D_Initialize(Base_commands_Speed6D* pVal)
{


	/*set surge */
	T_Double_Initialize((&(pVal->surge)));
	/*set sway */
	T_Double_Initialize((&(pVal->sway)));
	/*set heave */
	T_Double_Initialize((&(pVal->heave)));
	/*set roll */
	T_Double_Initialize((&(pVal->roll)));
	/*set pitch */
	T_Double_Initialize((&(pVal->pitch)));
	/*set yaw */
	T_Double_Initialize((&(pVal->yaw)));
}

flag Base_commands_Speed6D_IsConstraintValid(const Base_commands_Speed6D* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->surge) && (pVal->surge <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_SURGE; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->sway) && (pVal->sway <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_SWAY; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->heave) && (pVal->heave <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_HEAVE; 
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->roll) && (pVal->roll <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_ROLL; 
                if (ret) {
                    ret = ((-1.79769313486231570000E+308 <= pVal->pitch) && (pVal->pitch <= 1.79769313486231570000E+308));
                    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_PITCH; 
                    if (ret) {
                        ret = ((-1.79769313486231570000E+308 <= pVal->yaw) && (pVal->yaw <= 1.79769313486231570000E+308));
                        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_SPEED6D_YAW; 
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_commands_Speed6D_Encode(const Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_commands_Speed6D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode surge */
	    ret = T_Double_Encode((&(pVal->surge)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sway */
	        ret = T_Double_Encode((&(pVal->sway)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heave */
	            ret = T_Double_Encode((&(pVal->heave)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode roll */
	                ret = T_Double_Encode((&(pVal->roll)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode pitch */
	                    ret = T_Double_Encode((&(pVal->pitch)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode yaw */
	                        ret = T_Double_Encode((&(pVal->yaw)), pBitStrm, pErrCode, FALSE);
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_commands_Speed6D_Decode(Base_commands_Speed6D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode surge */
	ret = T_Double_Decode((&(pVal->surge)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sway */
	    ret = T_Double_Decode((&(pVal->sway)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heave */
	        ret = T_Double_Decode((&(pVal->heave)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode roll */
	            ret = T_Double_Decode((&(pVal->roll)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode pitch */
	                ret = T_Double_Decode((&(pVal->pitch)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode yaw */
	                    ret = T_Double_Decode((&(pVal->yaw)), pBitStrm, pErrCode);
	                }
	            }
	        }
	    }
	}

	return ret  && Base_commands_Speed6D_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_AngleAxisd_axis_Initialize(Wrappers_AngleAxisd_axis* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_AngleAxisd_Initialize(Wrappers_AngleAxisd* pVal)
{


	/*set angle */
	T_Double_Initialize((&(pVal->angle)));
	/*set axis */
	Wrappers_AngleAxisd_axis_Initialize((&(pVal->axis)));
}

flag Wrappers_AngleAxisd_IsConstraintValid(const Wrappers_AngleAxisd* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->angle) && (pVal->angle <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_ANGLE; 
    if (ret) {
        ret = ((1 <= pVal->axis.nCount) && (pVal->axis.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_AXIS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->axis.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->axis.arr[i1]) && (pVal->axis.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_WRAPPERS_ANGLEAXISD_AXIS_ELM; 
            }
        }
    }

	return ret;
}

flag Wrappers_AngleAxisd_Encode(const Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode angle */
	    ret = T_Double_Encode((&(pVal->angle)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode axis */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->axis.nCount, 1, 3);
	        	
	        for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++) 
	        {
	        	ret = T_Double_Encode((&(pVal->axis.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_AngleAxisd_Decode(Wrappers_AngleAxisd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode angle */
	ret = T_Double_Decode((&(pVal->angle)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode axis */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_ANGLEAXISD_AXIS;
	    pVal->axis.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->axis.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Decode((&(pVal->axis.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && Wrappers_AngleAxisd_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Vector2d_data_Initialize(Wrappers_Vector2d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 2) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Vector2d_Initialize(Wrappers_Vector2d* pVal)
{


	/*set data */
	Wrappers_Vector2d_data_Initialize((&(pVal->data)));
}

flag Wrappers_Vector2d_IsConstraintValid(const Wrappers_Vector2d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 2));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR2D_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR2D_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_Vector2d_Encode(const Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Vector2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 2);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Vector2d_Decode(Wrappers_Vector2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 2);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR2D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Vector2d_IsConstraintValid(pVal, pErrCode);
}



void Base_Pose2D_Initialize(Base_Pose2D* pVal)
{


	/*set position */
	Wrappers_Vector2d_Initialize((&(pVal->position)));
	/*set orientation */
	T_Double_Initialize((&(pVal->orientation)));
}

flag Base_Pose2D_IsConstraintValid(const Base_Pose2D* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 2));
    *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_POSITION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_POSE2D_POSITION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->orientation) && (pVal->orientation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_ORIENTATION; 
    }

	return ret;
}

flag Base_Pose2D_Encode(const Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Pose2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = Wrappers_Vector2d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = T_Double_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Pose2D_Decode(Base_Pose2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = Wrappers_Vector2d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = T_Double_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	}

	return ret  && Base_Pose2D_IsConstraintValid(pVal, pErrCode);
}



void Base_Pose2D_m_Initialize(Base_Pose2D_m* pVal)
{


	/*set position */
	Wrappers_Vector2d_Initialize((&(pVal->position)));
	/*set orientation */
	T_Double_Initialize((&(pVal->orientation)));
}

flag Base_Pose2D_m_IsConstraintValid(const Base_Pose2D_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 2));
    *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_POSITION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_POSITION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->orientation) && (pVal->orientation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_POSE2D_M_ORIENTATION; 
    }

	return ret;
}

flag Base_Pose2D_m_Encode(const Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Pose2D_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = Wrappers_Vector2d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = T_Double_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Pose2D_m_Decode(Base_Pose2D_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = Wrappers_Vector2d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = T_Double_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	}

	return ret  && Base_Pose2D_m_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Matrix2d_data_Initialize(Wrappers_Matrix2d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Matrix2d_Initialize(Wrappers_Matrix2d* pVal)
{


	/*set data */
	Wrappers_Matrix2d_data_Initialize((&(pVal->data)));
}

flag Wrappers_Matrix2d_IsConstraintValid(const Wrappers_Matrix2d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX2D_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX2D_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_Matrix2d_Encode(const Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Matrix2d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Matrix2d_Decode(Wrappers_Matrix2d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX2D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Matrix2d_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Vector3d_data_Initialize(Wrappers_Vector3d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Vector3d_Initialize(Wrappers_Vector3d* pVal)
{


	/*set data */
	Wrappers_Vector3d_data_Initialize((&(pVal->data)));
}

flag Wrappers_Vector3d_IsConstraintValid(const Wrappers_Vector3d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR3D_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR3D_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_Vector3d_Encode(const Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Vector3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Vector3d_Decode(Wrappers_Vector3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR3D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Vector3d_IsConstraintValid(pVal, pErrCode);
}



void Base_Wrench_Initialize(Base_Wrench* pVal)
{


	/*set force */
	Wrappers_Vector3d_Initialize((&(pVal->force)));
	/*set torque */
	Wrappers_Vector3d_Initialize((&(pVal->torque)));
}

flag Base_Wrench_IsConstraintValid(const Base_Wrench* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_FORCE_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_FORCE_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_TORQUE_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_TORQUE_DATA_ELM; 
            }
        }
    }

	return ret;
}

flag Base_Wrench_Encode(const Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Wrench_Decode(Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
	}

	return ret  && Base_Wrench_IsConstraintValid(pVal, pErrCode);
}



void Base_Waypoint_Initialize(Base_Waypoint* pVal)
{


	/*set position */
	Wrappers_Vector3d_Initialize((&(pVal->position)));
	/*set heading */
	T_Double_Initialize((&(pVal->heading)));
	/*set tol_position */
	T_Double_Initialize((&(pVal->tol_position)));
	/*set tol_heading */
	T_Double_Initialize((&(pVal->tol_heading)));
}

flag Base_Waypoint_IsConstraintValid(const Base_Waypoint* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_POSITION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_POSITION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->heading) && (pVal->heading <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_HEADING; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->tol_position) && (pVal->tol_position <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_TOL_POSITION; 
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->tol_heading) && (pVal->tol_heading <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_TOL_HEADING; 
            }
        }
    }

	return ret;
}

flag Base_Waypoint_Encode(const Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heading */
	        ret = T_Double_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tol_position */
	            ret = T_Double_Encode((&(pVal->tol_position)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tol_heading */
	                ret = T_Double_Encode((&(pVal->tol_heading)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Waypoint_Decode(Base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heading */
	    ret = T_Double_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tol_position */
	        ret = T_Double_Decode((&(pVal->tol_position)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tol_heading */
	            ret = T_Double_Decode((&(pVal->tol_heading)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_Waypoint_IsConstraintValid(pVal, pErrCode);
}



void Base_Waypoint_m_Initialize(Base_Waypoint_m* pVal)
{


	/*set position */
	Wrappers_Vector3d_Initialize((&(pVal->position)));
	/*set heading */
	T_Double_Initialize((&(pVal->heading)));
	/*set tol_position */
	T_Double_Initialize((&(pVal->tol_position)));
	/*set tol_heading */
	T_Double_Initialize((&(pVal->tol_heading)));
}

flag Base_Waypoint_m_IsConstraintValid(const Base_Waypoint_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_POSITION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_POSITION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->heading) && (pVal->heading <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_HEADING; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->tol_position) && (pVal->tol_position <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_TOL_POSITION; 
            if (ret) {
                ret = ((-1.79769313486231570000E+308 <= pVal->tol_heading) && (pVal->tol_heading <= 1.79769313486231570000E+308));
                *pErrCode = ret ? 0 :  ERR_BASE_WAYPOINT_M_TOL_HEADING; 
            }
        }
    }

	return ret;
}

flag Base_Waypoint_m_Encode(const Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Waypoint_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode heading */
	        ret = T_Double_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode tol_position */
	            ret = T_Double_Encode((&(pVal->tol_position)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode tol_heading */
	                ret = T_Double_Encode((&(pVal->tol_heading)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Waypoint_m_Decode(Base_Waypoint_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode heading */
	    ret = T_Double_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode tol_position */
	        ret = T_Double_Decode((&(pVal->tol_position)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode tol_heading */
	            ret = T_Double_Decode((&(pVal->tol_heading)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_Waypoint_m_IsConstraintValid(pVal, pErrCode);
}



void Std_orogen_typekits_mtype_std_vector_base_Waypoint_Initialize(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Waypoint_m_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].position.data.nCount) && (pVal->arr[i1].position.data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].position.data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].position.data.arr[i2]) && (pVal->arr[i1].position.data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_POSITION_DATA_ELM; 
        	    }
        	}
        	if (ret) {
        	    ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].heading) && (pVal->arr[i1].heading <= 1.79769313486231570000E+308));
        	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_HEADING; 
        	    if (ret) {
        	        ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].tol_position) && (pVal->arr[i1].tol_position <= 1.79769313486231570000E+308));
        	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_POSITION; 
        	        if (ret) {
        	            ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].tol_heading) && (pVal->arr[i1].tol_heading <= 1.79769313486231570000E+308));
        	            *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT_ELM_TOL_HEADING; 
        	        }
        	    }
        	}
        }
    }

	return ret;
}

flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Encode(const Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = Base_Waypoint_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Std_orogen_typekits_mtype_std_vector_base_Waypoint_Decode(Std_orogen_typekits_mtype_std_vector_base_Waypoint* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WAYPOINT;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = Base_Waypoint_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Std_orogen_typekits_mtype_std_vector_base_Waypoint_IsConstraintValid(pVal, pErrCode);
}



void Base_Wrench_m_Initialize(Base_Wrench_m* pVal)
{


	/*set force */
	Wrappers_Vector3d_Initialize((&(pVal->force)));
	/*set torque */
	Wrappers_Vector3d_Initialize((&(pVal->torque)));
}

flag Base_Wrench_m_IsConstraintValid(const Base_Wrench_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_FORCE_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_FORCE_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_TORQUE_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_WRENCH_M_TORQUE_DATA_ELM; 
            }
        }
    }

	return ret;
}

flag Base_Wrench_m_Encode(const Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Wrench_m_Decode(Base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
	}

	return ret  && Base_Wrench_m_IsConstraintValid(pVal, pErrCode);
}



void Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Wrench_m_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].force.data.nCount) && (pVal->arr[i1].force.data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].force.data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].force.data.arr[i2]) && (pVal->arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_FORCE_DATA_ELM; 
        	    }
        	}
        	if (ret) {
        	    ret = ((1 <= pVal->arr[i1].torque.data.nCount) && (pVal->arr[i1].torque.data.nCount <= 3));
        	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA; 
        	    if (ret) {
        	        for(i2 = 0; ret && i2 < pVal->arr[i1].torque.data.nCount; i2++) 
        	        {
        	        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].torque.data.arr[i2]) && (pVal->arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
        	        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH_ELM_TORQUE_DATA_ELM; 
        	        }
        	    }
        	}
        }
    }

	return ret;
}

flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode(const Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = Base_Wrench_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode(Std_orogen_typekits_mtype_std_vector_base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_WRENCH;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = Base_Wrench_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Std_orogen_typekits_mtype_std_vector_base_Wrench_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Matrix3d_data_Initialize(Wrappers_Matrix3d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 9) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Matrix3d_Initialize(Wrappers_Matrix3d* pVal)
{


	/*set data */
	Wrappers_Matrix3d_data_Initialize((&(pVal->data)));
}

flag Wrappers_Matrix3d_IsConstraintValid(const Wrappers_Matrix3d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 9));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX3D_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX3D_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_Matrix3d_Encode(const Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Matrix3d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 9);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Matrix3d_Decode(Wrappers_Matrix3d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 9);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX3D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Matrix3d_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Vector4d_data_Initialize(Wrappers_Vector4d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 4) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Vector4d_Initialize(Wrappers_Vector4d* pVal)
{


	/*set data */
	Wrappers_Vector4d_data_Initialize((&(pVal->data)));
}

flag Wrappers_Vector4d_IsConstraintValid(const Wrappers_Vector4d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 4));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR4D_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR4D_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_Vector4d_Encode(const Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 4);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Vector4d_Decode(Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 4);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR4D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
}



void Std_vector_Wrappers_Vector4d_Initialize(Std_vector_Wrappers_Vector4d* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Std_vector_Wrappers_Vector4d_IsConstraintValid(const Std_vector_Wrappers_Vector4d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((1 <= pVal->arr[i1].data.nCount) && (pVal->arr[i1].data.nCount <= 4));
        	*pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->arr[i1].data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].data.arr[i2]) && (pVal->arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_STD_VECTOR_WRAPPERS_VECTOR4D_ELM_DATA_ELM; 
        	    }
        	}
        }
    }

	return ret;
}

flag Std_vector_Wrappers_Vector4d_Encode(const Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Std_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = Wrappers_Vector4d_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Std_vector_Wrappers_Vector4d_Decode(Std_vector_Wrappers_Vector4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_VECTOR_WRAPPERS_VECTOR4D;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = Wrappers_Vector4d_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Std_vector_Wrappers_Vector4d_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Matrix4d_data_Initialize(Wrappers_Matrix4d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 16) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Matrix4d_Initialize(Wrappers_Matrix4d* pVal)
{


	/*set data */
	Wrappers_Matrix4d_data_Initialize((&(pVal->data)));
}

flag Wrappers_Matrix4d_IsConstraintValid(const Wrappers_Matrix4d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 16));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX4D_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX4D_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_Matrix4d_Encode(const Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Matrix4d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 16);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Matrix4d_Decode(Wrappers_Matrix4d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 16);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX4D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Matrix4d_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Vector6d_data_Initialize(Wrappers_Vector6d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 6) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Vector6d_Initialize(Wrappers_Vector6d* pVal)
{


	/*set data */
	Wrappers_Vector6d_data_Initialize((&(pVal->data)));
}

flag Wrappers_Vector6d_IsConstraintValid(const Wrappers_Vector6d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 6));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR6D_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTOR6D_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_Vector6d_Encode(const Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Vector6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 6);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Vector6d_Decode(Wrappers_Vector6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 6);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTOR6D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Vector6d_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Matrix6d_data_Initialize(Wrappers_Matrix6d_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 36) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Matrix6d_Initialize(Wrappers_Matrix6d* pVal)
{


	/*set data */
	Wrappers_Matrix6d_data_Initialize((&(pVal->data)));
}

flag Wrappers_Matrix6d_IsConstraintValid(const Wrappers_Matrix6d* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 36));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX6D_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIX6D_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_Matrix6d_Encode(const Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Matrix6d_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 36);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Matrix6d_Decode(Wrappers_Matrix6d* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 36);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIX6D_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Matrix6d_IsConstraintValid(pVal, pErrCode);
}



void Base_TwistWithCovariance_Initialize(Base_TwistWithCovariance* pVal)
{


	/*set vel */
	Wrappers_Vector3d_Initialize((&(pVal->vel)));
	/*set rot */
	Wrappers_Vector3d_Initialize((&(pVal->rot)));
	/*set cov */
	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
}

flag Base_TwistWithCovariance_IsConstraintValid(const Base_TwistWithCovariance* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->vel.data.nCount) && (pVal->vel.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->vel.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->vel.data.arr[i1]) && (pVal->vel.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_VEL_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->rot.data.nCount) && (pVal->rot.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->rot.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->rot.data.arr[i1]) && (pVal->rot.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_ROT_DATA_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_COV_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Base_TwistWithCovariance_Encode(const Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_TwistWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vel */
	    ret = Wrappers_Vector3d_Encode((&(pVal->vel)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rot */
	        ret = Wrappers_Vector3d_Encode((&(pVal->rot)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_TwistWithCovariance_Decode(Base_TwistWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode vel */
	ret = Wrappers_Vector3d_Decode((&(pVal->vel)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rot */
	    ret = Wrappers_Vector3d_Decode((&(pVal->rot)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_TwistWithCovariance_IsConstraintValid(pVal, pErrCode);
}



void Base_TwistWithCovariance_m_Initialize(Base_TwistWithCovariance_m* pVal)
{


	/*set vel */
	Wrappers_Vector3d_Initialize((&(pVal->vel)));
	/*set rot */
	Wrappers_Vector3d_Initialize((&(pVal->rot)));
	/*set cov */
	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
}

flag Base_TwistWithCovariance_m_IsConstraintValid(const Base_TwistWithCovariance_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->vel.data.nCount) && (pVal->vel.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->vel.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->vel.data.arr[i1]) && (pVal->vel.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_VEL_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->rot.data.nCount) && (pVal->rot.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->rot.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->rot.data.arr[i1]) && (pVal->rot.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_ROT_DATA_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_TWISTWITHCOVARIANCE_M_COV_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Base_TwistWithCovariance_m_Encode(const Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode vel */
	    ret = Wrappers_Vector3d_Encode((&(pVal->vel)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rot */
	        ret = Wrappers_Vector3d_Encode((&(pVal->rot)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_TwistWithCovariance_m_Decode(Base_TwistWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode vel */
	ret = Wrappers_Vector3d_Decode((&(pVal->vel)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rot */
	    ret = Wrappers_Vector3d_Decode((&(pVal->rot)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_TwistWithCovariance_m_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_Quaterniond_im_Initialize(Wrappers_Quaterniond_im* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 3) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_Quaterniond_Initialize(Wrappers_Quaterniond* pVal)
{


	/*set im */
	Wrappers_Quaterniond_im_Initialize((&(pVal->im)));
	/*set re */
	T_Double_Initialize((&(pVal->re)));
}

flag Wrappers_Quaterniond_IsConstraintValid(const Wrappers_Quaterniond* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->im.nCount) && (pVal->im.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_IM; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->im.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->im.arr[i1]) && (pVal->im.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_IM_ELM; 
        }
    }
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->re) && (pVal->re <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_WRAPPERS_QUATERNIOND_RE; 
    }

	return ret;
}

flag Wrappers_Quaterniond_Encode(const Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_Quaterniond_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode im */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->im.nCount, 1, 3);
	    	
	    for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->im.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode re */
	        ret = T_Double_Encode((&(pVal->re)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_Quaterniond_Decode(Wrappers_Quaterniond* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode im */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 3);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_QUATERNIOND_IM;
	pVal->im.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->im.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->im.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode re */
	    ret = T_Double_Decode((&(pVal->re)), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_Quaterniond_IsConstraintValid(pVal, pErrCode);
}



void Base_Pose_Initialize(Base_Pose* pVal)
{


	/*set position */
	Wrappers_Vector3d_Initialize((&(pVal->position)));
	/*set orientation */
	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
}

flag Base_Pose_IsConstraintValid(const Base_Pose* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_POSE_POSITION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_POSE_POSITION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_IM; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_IM_ELM; 
            }
        }
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_POSE_ORIENTATION_RE; 
        }
    }

	return ret;
}

flag Base_Pose_Encode(const Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Pose_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Pose_Decode(Base_Pose* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	}

	return ret  && Base_Pose_IsConstraintValid(pVal, pErrCode);
}



void Base_TransformWithCovariance_Initialize(Base_TransformWithCovariance* pVal)
{


	/*set translation */
	Wrappers_Vector3d_Initialize((&(pVal->translation)));
	/*set orientation */
	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
	/*set cov */
	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
}

flag Base_TransformWithCovariance_IsConstraintValid(const Base_TransformWithCovariance* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->translation.data.nCount) && (pVal->translation.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->translation.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->translation.data.arr[i1]) && (pVal->translation.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_TRANSLATION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_IM_ELM; 
            }
        }
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_ORIENTATION_RE; 
        }
        if (ret) {
            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_COV_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Base_TransformWithCovariance_Encode(const Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_TransformWithCovariance_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = Wrappers_Vector3d_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_TransformWithCovariance_Decode(Base_TransformWithCovariance* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = Wrappers_Vector3d_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_TransformWithCovariance_IsConstraintValid(pVal, pErrCode);
}



void Base_Pose_m_Initialize(Base_Pose_m* pVal)
{


	/*set position */
	Wrappers_Vector3d_Initialize((&(pVal->position)));
	/*set orientation */
	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
}

flag Base_Pose_m_IsConstraintValid(const Base_Pose_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_POSITION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_POSE_M_POSITION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_IM; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_IM_ELM; 
            }
        }
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_POSE_M_ORIENTATION_RE; 
        }
    }

	return ret;
}

flag Base_Pose_m_Encode(const Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Pose_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Pose_m_Decode(Base_Pose_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	}

	return ret  && Base_Pose_m_IsConstraintValid(pVal, pErrCode);
}



void Base_TransformWithCovariance_m_Initialize(Base_TransformWithCovariance_m* pVal)
{


	/*set translation */
	Wrappers_Vector3d_Initialize((&(pVal->translation)));
	/*set orientation */
	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
	/*set cov */
	Wrappers_Matrix6d_Initialize((&(pVal->cov)));
}

flag Base_TransformWithCovariance_m_IsConstraintValid(const Base_TransformWithCovariance_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->translation.data.nCount) && (pVal->translation.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->translation.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->translation.data.arr[i1]) && (pVal->translation.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_TRANSLATION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_IM_ELM; 
            }
        }
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_ORIENTATION_RE; 
        }
        if (ret) {
            ret = ((1 <= pVal->cov.data.nCount) && (pVal->cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->cov.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->cov.data.arr[i1]) && (pVal->cov.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_TRANSFORMWITHCOVARIANCE_M_COV_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Base_TransformWithCovariance_m_Encode(const Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = Wrappers_Vector3d_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode orientation */
	        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov */
	            ret = Wrappers_Matrix6d_Encode((&(pVal->cov)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_TransformWithCovariance_m_Decode(Base_TransformWithCovariance_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = Wrappers_Vector3d_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode orientation */
	    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov */
	        ret = Wrappers_Matrix6d_Decode((&(pVal->cov)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_TransformWithCovariance_m_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_VectorXd_data_Initialize(Wrappers_VectorXd_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_VectorXd_Initialize(Wrappers_VectorXd* pVal)
{


	/*set data */
	Wrappers_VectorXd_data_Initialize((&(pVal->data)));
}

flag Wrappers_VectorXd_IsConstraintValid(const Wrappers_VectorXd* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTORXD_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_VECTORXD_DATA_ELM; 
        }
    }

	return ret;
}

flag Wrappers_VectorXd_Encode(const Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_VectorXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_VectorXd_Decode(Wrappers_VectorXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode data */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_VECTORXD_DATA;
	pVal->data.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	{
		ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Wrappers_VectorXd_IsConstraintValid(pVal, pErrCode);
}



void Base_JointState_Initialize(Base_JointState* pVal)
{


	/*set position */
	T_Double_Initialize((&(pVal->position)));
	/*set speed */
	T_Float_Initialize((&(pVal->speed)));
	/*set effort */
	T_Float_Initialize((&(pVal->effort)));
	/*set raw */
	T_Float_Initialize((&(pVal->raw)));
	/*set acceleration */
	T_Float_Initialize((&(pVal->acceleration)));
}

flag Base_JointState_IsConstraintValid(const Base_JointState* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->position) && (pVal->position <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_POSITION; 
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->speed) && (pVal->speed <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_SPEED; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->effort) && (pVal->effort <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_EFFORT; 
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->raw) && (pVal->raw <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_RAW; 
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->acceleration) && (pVal->acceleration <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_ACCELERATION; 
                }
            }
        }
    }

	return ret;
}

flag Base_JointState_Encode(const Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode position */
	    ret = T_Double_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode speed */
	        ret = T_Float_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode effort */
	            ret = T_Float_Encode((&(pVal->effort)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode raw */
	                ret = T_Float_Encode((&(pVal->raw)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode acceleration */
	                    ret = T_Float_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointState_Decode(Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode position */
	ret = T_Double_Decode((&(pVal->position)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode speed */
	    ret = T_Float_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode effort */
	        ret = T_Float_Decode((&(pVal->effort)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode raw */
	            ret = T_Float_Decode((&(pVal->raw)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode acceleration */
	                ret = T_Float_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && Base_JointState_IsConstraintValid(pVal, pErrCode);
}



void Base_JointTrajectory_Initialize(Base_JointTrajectory* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_JointState_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Base_JointTrajectory_IsConstraintValid(const Base_JointTrajectory* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].position) && (pVal->arr[i1].position <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_POSITION; 
        	if (ret) {
        	    ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].speed) && (pVal->arr[i1].speed <= 3.40282346600000020000E+038));
        	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_SPEED; 
        	    if (ret) {
        	        ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].effort) && (pVal->arr[i1].effort <= 3.40282346600000020000E+038));
        	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_EFFORT; 
        	        if (ret) {
        	            ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].raw) && (pVal->arr[i1].raw <= 3.40282346600000020000E+038));
        	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_RAW; 
        	            if (ret) {
        	                ret = ((-3.40282346600000020000E+038 <= pVal->arr[i1].acceleration) && (pVal->arr[i1].acceleration <= 3.40282346600000020000E+038));
        	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRAJECTORY_ELM_ACCELERATION; 
        	            }
        	        }
        	    }
        	}
        }
    }

	return ret;
}

flag Base_JointTrajectory_Encode(const Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = Base_JointState_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointTrajectory_Decode(Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRAJECTORY;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = Base_JointState_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Base_JointTrajectory_IsConstraintValid(pVal, pErrCode);
}



void Base_JointLimitRange_Initialize(Base_JointLimitRange* pVal)
{


	/*set min */
	Base_JointState_Initialize((&(pVal->min)));
	/*set max */
	Base_JointState_Initialize((&(pVal->max)));
}

flag Base_JointLimitRange_IsConstraintValid(const Base_JointLimitRange* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->min.position) && (pVal->min.position <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_POSITION; 
    if (ret) {
        ret = ((-3.40282346600000020000E+038 <= pVal->min.speed) && (pVal->min.speed <= 3.40282346600000020000E+038));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_SPEED; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->min.effort) && (pVal->min.effort <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_EFFORT; 
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->min.raw) && (pVal->min.raw <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_RAW; 
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->min.acceleration) && (pVal->min.acceleration <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MIN_ACCELERATION; 
                }
            }
        }
    }
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->max.position) && (pVal->max.position <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_POSITION; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->max.speed) && (pVal->max.speed <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_SPEED; 
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->max.effort) && (pVal->max.effort <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_EFFORT; 
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->max.raw) && (pVal->max.raw <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_RAW; 
                    if (ret) {
                        ret = ((-3.40282346600000020000E+038 <= pVal->max.acceleration) && (pVal->max.acceleration <= 3.40282346600000020000E+038));
                        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITRANGE_MAX_ACCELERATION; 
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_JointLimitRange_Encode(const Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode min */
	    ret = Base_JointState_Encode((&(pVal->min)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode max */
	        ret = Base_JointState_Encode((&(pVal->max)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointLimitRange_Decode(Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode min */
	ret = Base_JointState_Decode((&(pVal->min)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode max */
	    ret = Base_JointState_Decode((&(pVal->max)), pBitStrm, pErrCode);
	}

	return ret  && Base_JointLimitRange_IsConstraintValid(pVal, pErrCode);
}



void Base_Pressure_Initialize(Base_Pressure* pVal)
{


	/*set pascal */
	T_Float_Initialize((&(pVal->pascal)));
}

flag Base_Pressure_IsConstraintValid(const Base_Pressure* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->pascal) && (pVal->pascal <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_BASE_PRESSURE_PASCAL; 

	return ret;
}

flag Base_Pressure_Encode(const Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pascal */
	    ret = T_Float_Encode((&(pVal->pascal)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Pressure_Decode(Base_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pascal */
	ret = T_Float_Decode((&(pVal->pascal)), pBitStrm, pErrCode);

	return ret  && Base_Pressure_IsConstraintValid(pVal, pErrCode);
}



void Base_Time_Initialize(Base_Time* pVal)
{


	/*set microseconds */
	T_Int64_Initialize((&(pVal->microseconds)));
}

flag Base_Time_IsConstraintValid(const Base_Time* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag Base_Time_Encode(const Base_Time* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Time_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode microseconds */
	    ret = T_Int64_Encode((&(pVal->microseconds)), pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Time_Decode(Base_Time* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode microseconds */
	ret = T_Int64_Decode((&(pVal->microseconds)), pBitStrm, pErrCode);

	return ret  && Base_Time_IsConstraintValid(pVal, pErrCode);
}



void Base_TimeStamped_Base_commands_Motion2D_Initialize(Base_TimeStamped_Base_commands_Motion2D* pVal)
{


	/*set translation */
	T_Double_Initialize((&(pVal->translation)));
	/*set rotation */
	T_Double_Initialize((&(pVal->rotation)));
	/*set heading */
	Base_Angle_Initialize((&(pVal->heading)));
	/*set time */
	Base_Time_Initialize((&(pVal->time)));
}

flag Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(const Base_TimeStamped_Base_commands_Motion2D* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_TRANSLATION; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_ROTATION; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_TIMESTAMPED_BASE_COMMANDS_MOTION2D_HEADING_RAD; 
        }
    }

	return ret;
}

flag Base_TimeStamped_Base_commands_Motion2D_Encode(const Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode time */
	                ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_TimeStamped_Base_commands_Motion2D_Decode(Base_TimeStamped_Base_commands_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode time */
	            ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_TimeStamped_Base_commands_Motion2D_IsConstraintValid(pVal, pErrCode);
}



void Base_LinearAngular6DCommand_Initialize(Base_LinearAngular6DCommand* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set linear */
	Wrappers_Vector3d_Initialize((&(pVal->linear)));
	/*set angular */
	Wrappers_Vector3d_Initialize((&(pVal->angular)));
}

flag Base_LinearAngular6DCommand_IsConstraintValid(const Base_LinearAngular6DCommand* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->linear.data.nCount) && (pVal->linear.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->linear.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->linear.data.arr[i1]) && (pVal->linear.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_LINEAR_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->angular.data.nCount) && (pVal->angular.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->angular.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->angular.data.arr[i1]) && (pVal->angular.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_LINEARANGULAR6DCOMMAND_ANGULAR_DATA_ELM; 
            }
        }
    }

	return ret;
}

flag Base_LinearAngular6DCommand_Encode(const Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode linear */
	        ret = Wrappers_Vector3d_Encode((&(pVal->linear)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular */
	            ret = Wrappers_Vector3d_Encode((&(pVal->angular)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_LinearAngular6DCommand_Decode(Base_LinearAngular6DCommand* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode linear */
	    ret = Wrappers_Vector3d_Decode((&(pVal->linear)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular */
	        ret = Wrappers_Vector3d_Decode((&(pVal->angular)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_LinearAngular6DCommand_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_BodyState_Initialize(Base_samples_BodyState* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set pose */
	Base_TransformWithCovariance_Initialize((&(pVal->pose)));
	/*set velocity */
	Base_TwistWithCovariance_Initialize((&(pVal->velocity)));
}

flag Base_samples_BodyState_IsConstraintValid(const Base_samples_BodyState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->pose.translation.data.nCount) && (pVal->pose.translation.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->pose.translation.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->pose.translation.data.arr[i1]) && (pVal->pose.translation.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_TRANSLATION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->pose.orientation.im.nCount) && (pVal->pose.orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->pose.orientation.im.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.im.arr[i1]) && (pVal->pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_IM_ELM; 
            }
        }
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.re) && (pVal->pose.orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_ORIENTATION_RE; 
        }
        if (ret) {
            ret = ((1 <= pVal->pose.cov.data.nCount) && (pVal->pose.cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->pose.cov.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->pose.cov.data.arr[i1]) && (pVal->pose.cov.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_POSE_COV_DATA_ELM; 
                }
            }
        }
    }
    if (ret) {
        ret = ((1 <= pVal->velocity.vel.data.nCount) && (pVal->velocity.vel.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->velocity.vel.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.vel.data.arr[i1]) && (pVal->velocity.vel.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_VEL_DATA_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->velocity.rot.data.nCount) && (pVal->velocity.rot.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->velocity.rot.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.rot.data.arr[i1]) && (pVal->velocity.rot.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_ROT_DATA_ELM; 
                }
            }
            if (ret) {
                ret = ((1 <= pVal->velocity.cov.data.nCount) && (pVal->velocity.cov.data.nCount <= 36));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->velocity.cov.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.cov.data.arr[i1]) && (pVal->velocity.cov.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_VELOCITY_COV_DATA_ELM; 
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_BodyState_Encode(const Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_BodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pose */
	        ret = Base_TransformWithCovariance_Encode((&(pVal->pose)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode velocity */
	            ret = Base_TwistWithCovariance_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_BodyState_Decode(Base_samples_BodyState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pose */
	    ret = Base_TransformWithCovariance_Decode((&(pVal->pose)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode velocity */
	        ret = Base_TwistWithCovariance_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_samples_BodyState_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_IMUSensors_Initialize(Base_samples_IMUSensors* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set acc */
	Wrappers_Vector3d_Initialize((&(pVal->acc)));
	/*set gyro */
	Wrappers_Vector3d_Initialize((&(pVal->gyro)));
	/*set mag */
	Wrappers_Vector3d_Initialize((&(pVal->mag)));
}

flag Base_samples_IMUSensors_IsConstraintValid(const Base_samples_IMUSensors* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->acc.data.nCount) && (pVal->acc.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->acc.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->acc.data.arr[i1]) && (pVal->acc.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_ACC_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->gyro.data.nCount) && (pVal->gyro.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->gyro.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->gyro.data.arr[i1]) && (pVal->gyro.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_GYRO_DATA_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->mag.data.nCount) && (pVal->mag.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->mag.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->mag.data.arr[i1]) && (pVal->mag.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_MAG_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Base_samples_IMUSensors_Encode(const Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_IMUSensors_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acc */
	        ret = Wrappers_Vector3d_Encode((&(pVal->acc)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode gyro */
	            ret = Wrappers_Vector3d_Encode((&(pVal->gyro)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode mag */
	                ret = Wrappers_Vector3d_Encode((&(pVal->mag)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_IMUSensors_Decode(Base_samples_IMUSensors* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acc */
	    ret = Wrappers_Vector3d_Decode((&(pVal->acc)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode gyro */
	        ret = Wrappers_Vector3d_Decode((&(pVal->gyro)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode mag */
	            ret = Wrappers_Vector3d_Decode((&(pVal->mag)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_samples_IMUSensors_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Motion2D_Initialize(Base_samples_Motion2D* pVal)
{


	/*set translation */
	T_Double_Initialize((&(pVal->translation)));
	/*set rotation */
	T_Double_Initialize((&(pVal->rotation)));
	/*set heading */
	Base_Angle_Initialize((&(pVal->heading)));
	/*set time */
	Base_Time_Initialize((&(pVal->time)));
}

flag Base_samples_Motion2D_IsConstraintValid(const Base_samples_Motion2D* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->translation) && (pVal->translation <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_TRANSLATION; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->rotation) && (pVal->rotation <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_ROTATION; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->heading.rad) && (pVal->heading.rad <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_MOTION2D_HEADING_RAD; 
        }
    }

	return ret;
}

flag Base_samples_Motion2D_Encode(const Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_Motion2D_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode translation */
	    ret = T_Double_Encode((&(pVal->translation)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode rotation */
	        ret = T_Double_Encode((&(pVal->rotation)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode heading */
	            ret = Base_Angle_Encode((&(pVal->heading)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode time */
	                ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Motion2D_Decode(Base_samples_Motion2D* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode translation */
	ret = T_Double_Decode((&(pVal->translation)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode rotation */
	    ret = T_Double_Decode((&(pVal->rotation)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode heading */
	        ret = Base_Angle_Decode((&(pVal->heading)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode time */
	            ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_samples_Motion2D_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Pressure_Initialize(Base_samples_Pressure* pVal)
{


	/*set pascal */
	T_Float_Initialize((&(pVal->pascal)));
	/*set time */
	Base_Time_Initialize((&(pVal->time)));
}

flag Base_samples_Pressure_IsConstraintValid(const Base_samples_Pressure* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-3.40282346600000020000E+038 <= pVal->pascal) && (pVal->pascal <= 3.40282346600000020000E+038));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_PRESSURE_PASCAL; 

	return ret;
}

flag Base_samples_Pressure_Encode(const Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_Pressure_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode pascal */
	    ret = T_Float_Encode((&(pVal->pascal)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode time */
	        ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Pressure_Decode(Base_samples_Pressure* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode pascal */
	ret = T_Float_Decode((&(pVal->pascal)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode time */
	    ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	}

	return ret  && Base_samples_Pressure_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_RigidBodyAcceleration_Initialize(Base_samples_RigidBodyAcceleration* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set acceleration */
	Wrappers_Vector3d_Initialize((&(pVal->acceleration)));
	/*set cov_acceleration */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_acceleration)));
	/*set angular_acceleration */
	Wrappers_Vector3d_Initialize((&(pVal->angular_acceleration)));
	/*set cov_angular_acceleration */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_acceleration)));
}

flag Base_samples_RigidBodyAcceleration_IsConstraintValid(const Base_samples_RigidBodyAcceleration* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->acceleration.data.nCount) && (pVal->acceleration.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->acceleration.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->acceleration.data.arr[i1]) && (pVal->acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ACCELERATION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->cov_acceleration.data.nCount) && (pVal->cov_acceleration.data.nCount <= 9));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->cov_acceleration.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_acceleration.data.arr[i1]) && (pVal->cov_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ACCELERATION_DATA_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->angular_acceleration.data.nCount) && (pVal->angular_acceleration.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->angular_acceleration.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->angular_acceleration.data.arr[i1]) && (pVal->angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_ANGULAR_ACCELERATION_DATA_ELM; 
                }
            }
            if (ret) {
                ret = ((1 <= pVal->cov_angular_acceleration.data.nCount) && (pVal->cov_angular_acceleration.data.nCount <= 9));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->cov_angular_acceleration.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_acceleration.data.arr[i1]) && (pVal->cov_angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_COV_ANGULAR_ACCELERATION_DATA_ELM; 
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_RigidBodyAcceleration_Encode(const Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acceleration */
	        ret = Wrappers_Vector3d_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov_acceleration */
	            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_acceleration)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode angular_acceleration */
	                ret = Wrappers_Vector3d_Encode((&(pVal->angular_acceleration)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_angular_acceleration */
	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_RigidBodyAcceleration_Decode(Base_samples_RigidBodyAcceleration* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acceleration */
	    ret = Wrappers_Vector3d_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov_acceleration */
	        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_acceleration)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode angular_acceleration */
	            ret = Wrappers_Vector3d_Decode((&(pVal->angular_acceleration)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_angular_acceleration */
	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && Base_samples_RigidBodyAcceleration_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Wrench_Initialize(Base_samples_Wrench* pVal)
{


	/*set force */
	Wrappers_Vector3d_Initialize((&(pVal->force)));
	/*set torque */
	Wrappers_Vector3d_Initialize((&(pVal->torque)));
	/*set time */
	Base_Time_Initialize((&(pVal->time)));
}

flag Base_samples_Wrench_IsConstraintValid(const Base_samples_Wrench* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_FORCE_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_FORCE_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_TORQUE_DATA_ELM; 
            }
        }
    }

	return ret;
}

flag Base_samples_Wrench_Encode(const Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Wrench_Decode(Base_samples_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_samples_Wrench_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Pointcloud_points_Initialize(Base_samples_Pointcloud_points* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Wrappers_Vector3d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Pointcloud_colors_Initialize(Base_samples_Pointcloud_colors* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Pointcloud_Initialize(Base_samples_Pointcloud* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set points */
	Base_samples_Pointcloud_points_Initialize((&(pVal->points)));
	/*set colors */
	Base_samples_Pointcloud_colors_Initialize((&(pVal->colors)));
}

flag Base_samples_Pointcloud_IsConstraintValid(const Base_samples_Pointcloud* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->points.nCount; i1++) 
        {
        	ret = ((1 <= pVal->points.arr[i1].data.nCount) && (pVal->points.arr[i1].data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->points.arr[i1].data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].data.arr[i2]) && (pVal->points.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_POINTS_ELM_DATA_ELM; 
        	    }
        	}
        }
    }
    if (ret) {
        ret = ((1 <= pVal->colors.nCount) && (pVal->colors.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->colors.nCount; i1++) 
            {
            	ret = ((1 <= pVal->colors.arr[i1].data.nCount) && (pVal->colors.arr[i1].data.nCount <= 4));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->colors.arr[i1].data.nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->colors.arr[i1].data.arr[i2]) && (pVal->colors.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_COLORS_ELM_DATA_ELM; 
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_samples_Pointcloud_Encode(const Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_Pointcloud_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode points */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	        {
	        	ret = Wrappers_Vector3d_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode colors */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	            {
	            	ret = Wrappers_Vector4d_Encode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Pointcloud_Decode(Base_samples_Pointcloud* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode points */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_POINTS;
	    pVal->points.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	    {
	    	ret = Wrappers_Vector3d_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode colors */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_COLORS;
	        pVal->colors.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	        {
	        	ret = Wrappers_Vector4d_Decode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_samples_Pointcloud_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_SonarBeam_beam_Initialize(Base_samples_SonarBeam_beam* pVal)
{

	memset(pVal->arr, 0x0, 200);
	pVal->nCount = 1;

}
void Base_samples_SonarBeam_Initialize(Base_samples_SonarBeam* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set bearing */
	Base_Angle_Initialize((&(pVal->bearing)));
	/*set sampling_interval */
	T_Double_Initialize((&(pVal->sampling_interval)));
	/*set speed_of_sound */
	T_Float_Initialize((&(pVal->speed_of_sound)));
	/*set beamwidth_horizontal */
	T_Float_Initialize((&(pVal->beamwidth_horizontal)));
	/*set beamwidth_vertical */
	T_Float_Initialize((&(pVal->beamwidth_vertical)));
	/*set beam */
	Base_samples_SonarBeam_beam_Initialize((&(pVal->beam)));
}

flag Base_samples_SonarBeam_IsConstraintValid(const Base_samples_SonarBeam* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->bearing.rad) && (pVal->bearing.rad <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEARING_RAD; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->sampling_interval) && (pVal->sampling_interval <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_SAMPLING_INTERVAL; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_SPEED_OF_SOUND; 
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->beamwidth_horizontal) && (pVal->beamwidth_horizontal <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_HORIZONTAL; 
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->beamwidth_vertical) && (pVal->beamwidth_vertical <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAMWIDTH_VERTICAL; 
                    if (ret) {
                        ret = ((1 <= pVal->beam.nCount) && (pVal->beam.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARBEAM_BEAM; 
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_SonarBeam_Encode(const Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_SonarBeam_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode bearing */
	        ret = Base_Angle_Encode((&(pVal->bearing)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode sampling_interval */
	            ret = T_Double_Encode((&(pVal->sampling_interval)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode speed_of_sound */
	                ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode beamwidth_horizontal */
	                    ret = T_Float_Encode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode beamwidth_vertical */
	                        ret = T_Float_Encode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode beam */
	                            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->beam.nCount, 1, 200);
	                            	
	                            for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++) 
	                            {
	                            	BitStream_AppendByte0(pBitStrm, pVal->beam.arr[i1]);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_SonarBeam_Decode(Base_samples_SonarBeam* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode bearing */
	    ret = Base_Angle_Decode((&(pVal->bearing)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode sampling_interval */
	        ret = T_Double_Decode((&(pVal->sampling_interval)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode speed_of_sound */
	            ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode beamwidth_horizontal */
	                ret = T_Float_Decode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode beamwidth_vertical */
	                    ret = T_Float_Decode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode beam */
	                        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
	                        pVal->beam.nCount = (long)nCount;
	                        	
	                        for(i1=0; (i1 < (int)pVal->beam.nCount) && ret; i1++) 
	                        {
	                        	ret = BitStream_ReadByte(pBitStrm, &(pVal->beam.arr[i1])); 
	                        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARBEAM_BEAM;
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_SonarBeam_IsConstraintValid(pVal, pErrCode);
}



void Base_commands_LinearAngular6DCommand_m_Initialize(Base_commands_LinearAngular6DCommand_m* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set linear */
	Wrappers_Vector3d_Initialize((&(pVal->linear)));
	/*set angular */
	Wrappers_Vector3d_Initialize((&(pVal->angular)));
}

flag Base_commands_LinearAngular6DCommand_m_IsConstraintValid(const Base_commands_LinearAngular6DCommand_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->linear.data.nCount) && (pVal->linear.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->linear.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->linear.data.arr[i1]) && (pVal->linear.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_LINEAR_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->angular.data.nCount) && (pVal->angular.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->angular.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->angular.data.arr[i1]) && (pVal->angular.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_LINEARANGULAR6DCOMMAND_M_ANGULAR_DATA_ELM; 
            }
        }
    }

	return ret;
}

flag Base_commands_LinearAngular6DCommand_m_Encode(const Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode linear */
	        ret = Wrappers_Vector3d_Encode((&(pVal->linear)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular */
	            ret = Wrappers_Vector3d_Encode((&(pVal->angular)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_commands_LinearAngular6DCommand_m_Decode(Base_commands_LinearAngular6DCommand_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode linear */
	    ret = Wrappers_Vector3d_Decode((&(pVal->linear)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular */
	        ret = Wrappers_Vector3d_Decode((&(pVal->angular)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_commands_LinearAngular6DCommand_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_BodyState_m_Initialize(Base_samples_BodyState_m* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set pose */
	Base_TransformWithCovariance_m_Initialize((&(pVal->pose)));
	/*set velocity */
	Base_TwistWithCovariance_m_Initialize((&(pVal->velocity)));
}

flag Base_samples_BodyState_m_IsConstraintValid(const Base_samples_BodyState_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->pose.translation.data.nCount) && (pVal->pose.translation.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->pose.translation.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->pose.translation.data.arr[i1]) && (pVal->pose.translation.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_TRANSLATION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->pose.orientation.im.nCount) && (pVal->pose.orientation.im.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->pose.orientation.im.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.im.arr[i1]) && (pVal->pose.orientation.im.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_IM_ELM; 
            }
        }
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->pose.orientation.re) && (pVal->pose.orientation.re <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_ORIENTATION_RE; 
        }
        if (ret) {
            ret = ((1 <= pVal->pose.cov.data.nCount) && (pVal->pose.cov.data.nCount <= 36));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->pose.cov.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->pose.cov.data.arr[i1]) && (pVal->pose.cov.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_POSE_COV_DATA_ELM; 
                }
            }
        }
    }
    if (ret) {
        ret = ((1 <= pVal->velocity.vel.data.nCount) && (pVal->velocity.vel.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->velocity.vel.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.vel.data.arr[i1]) && (pVal->velocity.vel.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_VEL_DATA_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->velocity.rot.data.nCount) && (pVal->velocity.rot.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->velocity.rot.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.rot.data.arr[i1]) && (pVal->velocity.rot.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_ROT_DATA_ELM; 
                }
            }
            if (ret) {
                ret = ((1 <= pVal->velocity.cov.data.nCount) && (pVal->velocity.cov.data.nCount <= 36));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->velocity.cov.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.cov.data.arr[i1]) && (pVal->velocity.cov.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_BODYSTATE_M_VELOCITY_COV_DATA_ELM; 
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_BodyState_m_Encode(const Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_BodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode pose */
	        ret = Base_TransformWithCovariance_m_Encode((&(pVal->pose)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode velocity */
	            ret = Base_TwistWithCovariance_m_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_BodyState_m_Decode(Base_samples_BodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode pose */
	    ret = Base_TransformWithCovariance_m_Decode((&(pVal->pose)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode velocity */
	        ret = Base_TwistWithCovariance_m_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_samples_BodyState_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_IMUSensors_m_Initialize(Base_samples_IMUSensors_m* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set acc */
	Wrappers_Vector3d_Initialize((&(pVal->acc)));
	/*set gyro */
	Wrappers_Vector3d_Initialize((&(pVal->gyro)));
	/*set mag */
	Wrappers_Vector3d_Initialize((&(pVal->mag)));
}

flag Base_samples_IMUSensors_m_IsConstraintValid(const Base_samples_IMUSensors_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->acc.data.nCount) && (pVal->acc.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->acc.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->acc.data.arr[i1]) && (pVal->acc.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_ACC_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->gyro.data.nCount) && (pVal->gyro.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->gyro.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->gyro.data.arr[i1]) && (pVal->gyro.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_GYRO_DATA_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->mag.data.nCount) && (pVal->mag.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->mag.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->mag.data.arr[i1]) && (pVal->mag.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_IMUSENSORS_M_MAG_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Base_samples_IMUSensors_m_Encode(const Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acc */
	        ret = Wrappers_Vector3d_Encode((&(pVal->acc)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode gyro */
	            ret = Wrappers_Vector3d_Encode((&(pVal->gyro)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode mag */
	                ret = Wrappers_Vector3d_Encode((&(pVal->mag)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_IMUSensors_m_Decode(Base_samples_IMUSensors_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acc */
	    ret = Wrappers_Vector3d_Decode((&(pVal->acc)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode gyro */
	        ret = Wrappers_Vector3d_Decode((&(pVal->gyro)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode mag */
	            ret = Wrappers_Vector3d_Decode((&(pVal->mag)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_samples_IMUSensors_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_RigidBodyAcceleration_m_Initialize(Base_samples_RigidBodyAcceleration_m* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set acceleration */
	Wrappers_Vector3d_Initialize((&(pVal->acceleration)));
	/*set cov_acceleration */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_acceleration)));
	/*set angular_acceleration */
	Wrappers_Vector3d_Initialize((&(pVal->angular_acceleration)));
	/*set cov_angular_acceleration */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_acceleration)));
}

flag Base_samples_RigidBodyAcceleration_m_IsConstraintValid(const Base_samples_RigidBodyAcceleration_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->acceleration.data.nCount) && (pVal->acceleration.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->acceleration.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->acceleration.data.arr[i1]) && (pVal->acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ACCELERATION_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->cov_acceleration.data.nCount) && (pVal->cov_acceleration.data.nCount <= 9));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->cov_acceleration.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_acceleration.data.arr[i1]) && (pVal->cov_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ACCELERATION_DATA_ELM; 
            }
        }
        if (ret) {
            ret = ((1 <= pVal->angular_acceleration.data.nCount) && (pVal->angular_acceleration.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->angular_acceleration.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->angular_acceleration.data.arr[i1]) && (pVal->angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_ANGULAR_ACCELERATION_DATA_ELM; 
                }
            }
            if (ret) {
                ret = ((1 <= pVal->cov_angular_acceleration.data.nCount) && (pVal->cov_angular_acceleration.data.nCount <= 9));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->cov_angular_acceleration.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_acceleration.data.arr[i1]) && (pVal->cov_angular_acceleration.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYACCELERATION_M_COV_ANGULAR_ACCELERATION_DATA_ELM; 
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_RigidBodyAcceleration_m_Encode(const Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode acceleration */
	        ret = Wrappers_Vector3d_Encode((&(pVal->acceleration)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode cov_acceleration */
	            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_acceleration)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode angular_acceleration */
	                ret = Wrappers_Vector3d_Encode((&(pVal->angular_acceleration)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_angular_acceleration */
	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode, FALSE);
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_RigidBodyAcceleration_m_Decode(Base_samples_RigidBodyAcceleration_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode acceleration */
	    ret = Wrappers_Vector3d_Decode((&(pVal->acceleration)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode cov_acceleration */
	        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_acceleration)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode angular_acceleration */
	            ret = Wrappers_Vector3d_Decode((&(pVal->angular_acceleration)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_angular_acceleration */
	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_acceleration)), pBitStrm, pErrCode);
	            }
	        }
	    }
	}

	return ret  && Base_samples_RigidBodyAcceleration_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Wrench_m_Initialize(Base_samples_Wrench_m* pVal)
{


	/*set force */
	Wrappers_Vector3d_Initialize((&(pVal->force)));
	/*set torque */
	Wrappers_Vector3d_Initialize((&(pVal->torque)));
	/*set time */
	Base_Time_Initialize((&(pVal->time)));
}

flag Base_samples_Wrench_m_IsConstraintValid(const Base_samples_Wrench_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->force.data.nCount) && (pVal->force.data.nCount <= 3));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->force.data.nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->force.data.arr[i1]) && (pVal->force.data.arr[i1] <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_FORCE_DATA_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->torque.data.nCount) && (pVal->torque.data.nCount <= 3));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->torque.data.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->torque.data.arr[i1]) && (pVal->torque.data.arr[i1] <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCH_M_TORQUE_DATA_ELM; 
            }
        }
    }

	return ret;
}

flag Base_samples_Wrench_m_Encode(const Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode force */
	    ret = Wrappers_Vector3d_Encode((&(pVal->force)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode torque */
	        ret = Wrappers_Vector3d_Encode((&(pVal->torque)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Wrench_m_Decode(Base_samples_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode force */
	ret = Wrappers_Vector3d_Decode((&(pVal->force)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode torque */
	    ret = Wrappers_Vector3d_Decode((&(pVal->torque)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_samples_Wrench_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Pointcloud_m_points_Initialize(Base_samples_Pointcloud_m_points* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Wrappers_Vector3d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Pointcloud_m_colors_Initialize(Base_samples_Pointcloud_m_colors* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Wrappers_Vector4d_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Pointcloud_m_Initialize(Base_samples_Pointcloud_m* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set points */
	Base_samples_Pointcloud_m_points_Initialize((&(pVal->points)));
	/*set colors */
	Base_samples_Pointcloud_m_colors_Initialize((&(pVal->colors)));
}

flag Base_samples_Pointcloud_m_IsConstraintValid(const Base_samples_Pointcloud_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->points.nCount) && (pVal->points.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->points.nCount; i1++) 
        {
        	ret = ((1 <= pVal->points.arr[i1].data.nCount) && (pVal->points.arr[i1].data.nCount <= 3));
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA; 
        	if (ret) {
        	    for(i2 = 0; ret && i2 < pVal->points.arr[i1].data.nCount; i2++) 
        	    {
        	    	ret = ((-1.79769313486231570000E+308 <= pVal->points.arr[i1].data.arr[i2]) && (pVal->points.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
        	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_POINTS_ELM_DATA_ELM; 
        	    }
        	}
        }
    }
    if (ret) {
        ret = ((1 <= pVal->colors.nCount) && (pVal->colors.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->colors.nCount; i1++) 
            {
            	ret = ((1 <= pVal->colors.arr[i1].data.nCount) && (pVal->colors.arr[i1].data.nCount <= 4));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->colors.arr[i1].data.nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->colors.arr[i1].data.arr[i2]) && (pVal->colors.arr[i1].data.arr[i2] <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_POINTCLOUD_M_COLORS_ELM_DATA_ELM; 
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_samples_Pointcloud_m_Encode(const Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode points */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->points.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	        {
	        	ret = Wrappers_Vector3d_Encode((&(pVal->points.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode colors */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->colors.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	            {
	            	ret = Wrappers_Vector4d_Encode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Pointcloud_m_Decode(Base_samples_Pointcloud_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode points */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_POINTS;
	    pVal->points.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->points.nCount) && ret; i1++) 
	    {
	    	ret = Wrappers_Vector3d_Decode((&(pVal->points.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode colors */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_POINTCLOUD_M_COLORS;
	        pVal->colors.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->colors.nCount) && ret; i1++) 
	        {
	        	ret = Wrappers_Vector4d_Decode((&(pVal->colors.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_samples_Pointcloud_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_frame_frame_size_t_Initialize(Base_samples_frame_frame_size_t* pVal)
{


	/*set width */
	T_UInt16_Initialize((&(pVal->width)));
	/*set height */
	T_UInt16_Initialize((&(pVal->height)));
}

flag Base_samples_frame_frame_size_t_IsConstraintValid(const Base_samples_frame_frame_size_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->width <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_WIDTH; 
    if (ret) {
        ret = (pVal->height <= 65535UL);
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_T_HEIGHT; 
    }

	return ret;
}

flag Base_samples_frame_frame_size_t_Encode(const Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode width */
	    ret = T_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode height */
	        ret = T_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_frame_frame_size_t_Decode(Base_samples_frame_frame_size_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode width */
	ret = T_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode height */
	    ret = T_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
	}

	return ret  && Base_samples_frame_frame_size_t_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_DistanceImage_data_Initialize(Base_samples_DistanceImage_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_DistanceImage_Initialize(Base_samples_DistanceImage* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set width */
	T_UInt16_Initialize((&(pVal->width)));
	/*set height */
	T_UInt16_Initialize((&(pVal->height)));
	/*set scale_x */
	T_Float_Initialize((&(pVal->scale_x)));
	/*set scale_y */
	T_Float_Initialize((&(pVal->scale_y)));
	/*set center_x */
	T_Float_Initialize((&(pVal->center_x)));
	/*set center_y */
	T_Float_Initialize((&(pVal->center_y)));
	/*set data */
	Base_samples_DistanceImage_data_Initialize((&(pVal->data)));
}

flag Base_samples_DistanceImage_IsConstraintValid(const Base_samples_DistanceImage* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = (pVal->width <= 65535UL);
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_WIDTH; 
    if (ret) {
        ret = (pVal->height <= 65535UL);
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_HEIGHT; 
        if (ret) {
            ret = ((-3.40282346600000020000E+038 <= pVal->scale_x) && (pVal->scale_x <= 3.40282346600000020000E+038));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_X; 
            if (ret) {
                ret = ((-3.40282346600000020000E+038 <= pVal->scale_y) && (pVal->scale_y <= 3.40282346600000020000E+038));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_SCALE_Y; 
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->center_x) && (pVal->center_x <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_X; 
                    if (ret) {
                        ret = ((-3.40282346600000020000E+038 <= pVal->center_y) && (pVal->center_y <= 3.40282346600000020000E+038));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_CENTER_Y; 
                        if (ret) {
                            ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA; 
                            if (ret) {
                                for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
                                {
                                	ret = ((-3.40282346600000020000E+038 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 3.40282346600000020000E+038));
                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DISTANCEIMAGE_DATA_ELM; 
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_DistanceImage_Encode(const Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_DistanceImage_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode width */
	        ret = T_UInt16_Encode((&(pVal->width)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode height */
	            ret = T_UInt16_Encode((&(pVal->height)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode scale_x */
	                ret = T_Float_Encode((&(pVal->scale_x)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode scale_y */
	                    ret = T_Float_Encode((&(pVal->scale_y)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode center_x */
	                        ret = T_Float_Encode((&(pVal->center_x)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode center_y */
	                            ret = T_Float_Encode((&(pVal->center_y)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode data */
	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	                                	
	                                for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	                                {
	                                	ret = T_Float_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_DistanceImage_Decode(Base_samples_DistanceImage* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode width */
	    ret = T_UInt16_Decode((&(pVal->width)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode height */
	        ret = T_UInt16_Decode((&(pVal->height)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode scale_x */
	            ret = T_Float_Decode((&(pVal->scale_x)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode scale_y */
	                ret = T_Float_Decode((&(pVal->scale_y)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode center_x */
	                    ret = T_Float_Decode((&(pVal->center_x)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode center_y */
	                        ret = T_Float_Decode((&(pVal->center_y)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode data */
	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DISTANCEIMAGE_DATA;
	                            pVal->data.nCount = (long)nCount;
	                            	
	                            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	                            {
	                            	ret = T_Float_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_DistanceImage_IsConstraintValid(pVal, pErrCode);
}



void Base_JointLimits_names_Initialize(Base_JointLimits_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_JointLimits_elements_Initialize(Base_JointLimits_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_JointLimitRange_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_JointLimits_Initialize(Base_JointLimits* pVal)
{


	/*set names */
	Base_JointLimits_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_JointLimits_elements_Initialize((&(pVal->elements)));
}

flag Base_JointLimits_IsConstraintValid(const Base_JointLimits* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].min.position) && (pVal->elements.arr[i1].min.position <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_POSITION; 
            	if (ret) {
            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.speed) && (pVal->elements.arr[i1].min.speed <= 3.40282346600000020000E+038));
            	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_SPEED; 
            	    if (ret) {
            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.effort) && (pVal->elements.arr[i1].min.effort <= 3.40282346600000020000E+038));
            	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_EFFORT; 
            	        if (ret) {
            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.raw) && (pVal->elements.arr[i1].min.raw <= 3.40282346600000020000E+038));
            	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_RAW; 
            	            if (ret) {
            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.acceleration) && (pVal->elements.arr[i1].min.acceleration <= 3.40282346600000020000E+038));
            	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MIN_ACCELERATION; 
            	            }
            	        }
            	    }
            	}
            	if (ret) {
            	    ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].max.position) && (pVal->elements.arr[i1].max.position <= 1.79769313486231570000E+308));
            	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_POSITION; 
            	    if (ret) {
            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.speed) && (pVal->elements.arr[i1].max.speed <= 3.40282346600000020000E+038));
            	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_SPEED; 
            	        if (ret) {
            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.effort) && (pVal->elements.arr[i1].max.effort <= 3.40282346600000020000E+038));
            	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_EFFORT; 
            	            if (ret) {
            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.raw) && (pVal->elements.arr[i1].max.raw <= 3.40282346600000020000E+038));
            	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_RAW; 
            	                if (ret) {
            	                    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.acceleration) && (pVal->elements.arr[i1].max.acceleration <= 3.40282346600000020000E+038));
            	                    *pErrCode = ret ? 0 :  ERR_BASE_JOINTLIMITS_ELEMENTS_ELM_MAX_ACCELERATION; 
            	                }
            	            }
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_JointLimits_Encode(const Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_JointLimits_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = Base_JointLimitRange_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointLimits_Decode(Base_JointLimits* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTLIMITS_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTLIMITS_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = Base_JointLimitRange_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_JointLimits_IsConstraintValid(pVal, pErrCode);
}



void Base_JointTransform_Initialize(Base_JointTransform* pVal)
{


	/*set sourceframe */
	T_String_Initialize((&(pVal->sourceframe)));
	/*set targetframe */
	T_String_Initialize((&(pVal->targetframe)));
	/*set rotationaxis */
	Wrappers_Vector3d_Initialize((&(pVal->rotationaxis)));
}

flag Base_JointTransform_IsConstraintValid(const Base_JointTransform* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = (pVal->sourceframe.nCount <= 40);
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_SOURCEFRAME; 
    if (ret) {
        ret = (pVal->targetframe.nCount <= 40);
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_TARGETFRAME; 
        if (ret) {
            ret = ((1 <= pVal->rotationaxis.data.nCount) && (pVal->rotationaxis.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->rotationaxis.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->rotationaxis.data.arr[i1]) && (pVal->rotationaxis.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_ROTATIONAXIS_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Base_JointTransform_Encode(const Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceframe */
	    ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode targetframe */
	        ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rotationaxis */
	            ret = Wrappers_Vector3d_Encode((&(pVal->rotationaxis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointTransform_Decode(Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode sourceframe */
	ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode targetframe */
	    ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode rotationaxis */
	        ret = Wrappers_Vector3d_Decode((&(pVal->rotationaxis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_JointTransform_IsConstraintValid(pVal, pErrCode);
}



void Base_JointTransformVector_names_Initialize(Base_JointTransformVector_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_JointTransformVector_elements_Initialize(Base_JointTransformVector_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_JointTransform_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_JointTransformVector_Initialize(Base_JointTransformVector* pVal)
{


	/*set names */
	Base_JointTransformVector_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_JointTransformVector_elements_Initialize((&(pVal->elements)));
}

flag Base_JointTransformVector_IsConstraintValid(const Base_JointTransformVector* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_SOURCEFRAME; 
            	if (ret) {
            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
            	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_TARGETFRAME; 
            	    if (ret) {
            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
            	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA; 
            	        if (ret) {
            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++) 
            	            {
            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
            	            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM; 
            	            }
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_JointTransformVector_Encode(const Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_JointTransformVector_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = Base_JointTransform_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointTransformVector_Decode(Base_JointTransformVector* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = Base_JointTransform_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_JointTransformVector_IsConstraintValid(pVal, pErrCode);
}



void Base_NamedVector_Base_JointTransform_names_Initialize(Base_NamedVector_Base_JointTransform_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_JointTransform_elements_Initialize(Base_NamedVector_Base_JointTransform_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_JointTransform_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_JointTransform_Initialize(Base_NamedVector_Base_JointTransform* pVal)
{


	/*set names */
	Base_NamedVector_Base_JointTransform_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_NamedVector_Base_JointTransform_elements_Initialize((&(pVal->elements)));
}

flag Base_NamedVector_Base_JointTransform_IsConstraintValid(const Base_NamedVector_Base_JointTransform* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_SOURCEFRAME; 
            	if (ret) {
            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_TARGETFRAME; 
            	    if (ret) {
            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA; 
            	        if (ret) {
            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++) 
            	            {
            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
            	            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM; 
            	            }
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_NamedVector_Base_JointTransform_Encode(const Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = Base_JointTransform_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_NamedVector_Base_JointTransform_Decode(Base_NamedVector_Base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = Base_JointTransform_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_NamedVector_Base_JointTransform_IsConstraintValid(pVal, pErrCode);
}



void Base_JointsTrajectory_names_Initialize(Base_JointsTrajectory_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_JointsTrajectory_elements_Initialize(Base_JointsTrajectory_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_JointTrajectory_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_JointsTrajectory_times_val_Initialize(Base_JointsTrajectory_times_val* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Time_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_JointsTrajectory_Initialize(Base_JointsTrajectory* pVal)
{


	/*set names */
	Base_JointsTrajectory_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_JointsTrajectory_elements_Initialize((&(pVal->elements)));
	/*set times_val */
	Base_JointsTrajectory_times_val_Initialize((&(pVal->times_val)));
}

flag Base_JointsTrajectory_IsConstraintValid(const Base_JointsTrajectory* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((1 <= pVal->elements.arr[i1].nCount) && (pVal->elements.arr[i1].nCount <= 200));
            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].arr[i2].position) && (pVal->elements.arr[i1].arr[i2].position <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_POSITION; 
            	    	if (ret) {
            	    	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].speed) && (pVal->elements.arr[i1].arr[i2].speed <= 3.40282346600000020000E+038));
            	    	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_SPEED; 
            	    	    if (ret) {
            	    	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].effort) && (pVal->elements.arr[i1].arr[i2].effort <= 3.40282346600000020000E+038));
            	    	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT; 
            	    	        if (ret) {
            	    	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].raw) && (pVal->elements.arr[i1].arr[i2].raw <= 3.40282346600000020000E+038));
            	    	            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_RAW; 
            	    	            if (ret) {
            	    	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].acceleration) && (pVal->elements.arr[i1].arr[i2].acceleration <= 3.40282346600000020000E+038));
            	    	                *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION; 
            	    	            }
            	    	        }
            	    	    }
            	    	}
            	    }
            	}
            }
        }
        if (ret) {
            ret = ((1 <= pVal->times_val.nCount) && (pVal->times_val.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTRAJECTORY_TIMES_VAL; 
        }
    }

	return ret;
}

flag Base_JointsTrajectory_Encode(const Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_JointsTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = Base_JointTrajectory_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode times_val */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->times_val.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++) 
	            {
	            	ret = Base_Time_Encode((&(pVal->times_val.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointsTrajectory_Decode(Base_JointsTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = Base_JointTrajectory_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode times_val */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTRAJECTORY_TIMES_VAL;
	        pVal->times_val.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->times_val.nCount) && ret; i1++) 
	        {
	        	ret = Base_Time_Decode((&(pVal->times_val.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_JointsTrajectory_IsConstraintValid(pVal, pErrCode);
}



void Base_NamedVector_Base_JointLimitRange_names_Initialize(Base_NamedVector_Base_JointLimitRange_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_JointLimitRange_elements_Initialize(Base_NamedVector_Base_JointLimitRange_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_JointLimitRange_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_JointLimitRange_Initialize(Base_NamedVector_Base_JointLimitRange* pVal)
{


	/*set names */
	Base_NamedVector_Base_JointLimitRange_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_NamedVector_Base_JointLimitRange_elements_Initialize((&(pVal->elements)));
}

flag Base_NamedVector_Base_JointLimitRange_IsConstraintValid(const Base_NamedVector_Base_JointLimitRange* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].min.position) && (pVal->elements.arr[i1].min.position <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_POSITION; 
            	if (ret) {
            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.speed) && (pVal->elements.arr[i1].min.speed <= 3.40282346600000020000E+038));
            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_SPEED; 
            	    if (ret) {
            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.effort) && (pVal->elements.arr[i1].min.effort <= 3.40282346600000020000E+038));
            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_EFFORT; 
            	        if (ret) {
            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.raw) && (pVal->elements.arr[i1].min.raw <= 3.40282346600000020000E+038));
            	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_RAW; 
            	            if (ret) {
            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].min.acceleration) && (pVal->elements.arr[i1].min.acceleration <= 3.40282346600000020000E+038));
            	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MIN_ACCELERATION; 
            	            }
            	        }
            	    }
            	}
            	if (ret) {
            	    ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].max.position) && (pVal->elements.arr[i1].max.position <= 1.79769313486231570000E+308));
            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_POSITION; 
            	    if (ret) {
            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.speed) && (pVal->elements.arr[i1].max.speed <= 3.40282346600000020000E+038));
            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_SPEED; 
            	        if (ret) {
            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.effort) && (pVal->elements.arr[i1].max.effort <= 3.40282346600000020000E+038));
            	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_EFFORT; 
            	            if (ret) {
            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.raw) && (pVal->elements.arr[i1].max.raw <= 3.40282346600000020000E+038));
            	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_RAW; 
            	                if (ret) {
            	                    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].max.acceleration) && (pVal->elements.arr[i1].max.acceleration <= 3.40282346600000020000E+038));
            	                    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS_ELM_MAX_ACCELERATION; 
            	                }
            	            }
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_NamedVector_Base_JointLimitRange_Encode(const Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = Base_JointLimitRange_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_NamedVector_Base_JointLimitRange_Decode(Base_NamedVector_Base_JointLimitRange* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTLIMITRANGE_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = Base_JointLimitRange_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_NamedVector_Base_JointLimitRange_IsConstraintValid(pVal, pErrCode);
}



void Base_NamedVector_Base_JointState_names_Initialize(Base_NamedVector_Base_JointState_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_JointState_Initialize(Base_NamedVector_Base_JointState* pVal)
{


	/*set names */
	Base_NamedVector_Base_JointState_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_JointTrajectory_Initialize((&(pVal->elements)));
}

flag Base_NamedVector_Base_JointState_IsConstraintValid(const Base_NamedVector_Base_JointState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].position) && (pVal->elements.arr[i1].position <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_POSITION; 
            	if (ret) {
            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].speed) && (pVal->elements.arr[i1].speed <= 3.40282346600000020000E+038));
            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_SPEED; 
            	    if (ret) {
            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].effort) && (pVal->elements.arr[i1].effort <= 3.40282346600000020000E+038));
            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_EFFORT; 
            	        if (ret) {
            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].raw) && (pVal->elements.arr[i1].raw <= 3.40282346600000020000E+038));
            	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_RAW; 
            	            if (ret) {
            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].acceleration) && (pVal->elements.arr[i1].acceleration <= 3.40282346600000020000E+038));
            	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTSTATE_ELEMENTS_ELM_ACCELERATION; 
            	            }
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_NamedVector_Base_JointState_Encode(const Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = Base_JointTrajectory_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_NamedVector_Base_JointState_Decode(Base_NamedVector_Base_JointState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTSTATE_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = Base_JointTrajectory_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	}

	return ret  && Base_NamedVector_Base_JointState_IsConstraintValid(pVal, pErrCode);
}



void Base_NamedVector_Base_Wrench_names_Initialize(Base_NamedVector_Base_Wrench_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_Wrench_elements_Initialize(Base_NamedVector_Base_Wrench_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Wrench_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_Wrench_Initialize(Base_NamedVector_Base_Wrench* pVal)
{


	/*set names */
	Base_NamedVector_Base_Wrench_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_NamedVector_Base_Wrench_elements_Initialize((&(pVal->elements)));
}

flag Base_NamedVector_Base_Wrench_IsConstraintValid(const Base_NamedVector_Base_Wrench* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_FORCE_DATA_ELM; 
            	    }
            	}
            	if (ret) {
            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA; 
            	    if (ret) {
            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++) 
            	        {
            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
            	        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS_ELM_TORQUE_DATA_ELM; 
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_NamedVector_Base_Wrench_Encode(const Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = Base_Wrench_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_NamedVector_Base_Wrench_Decode(Base_NamedVector_Base_Wrench* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = Base_Wrench_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_NamedVector_Base_Wrench_IsConstraintValid(pVal, pErrCode);
}



void Base_NamedVector_Base_JointTrajectory_names_Initialize(Base_NamedVector_Base_JointTrajectory_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_JointTrajectory_elements_Initialize(Base_NamedVector_Base_JointTrajectory_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_JointTrajectory_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_Base_JointTrajectory_Initialize(Base_NamedVector_Base_JointTrajectory* pVal)
{


	/*set names */
	Base_NamedVector_Base_JointTrajectory_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_NamedVector_Base_JointTrajectory_elements_Initialize((&(pVal->elements)));
}

flag Base_NamedVector_Base_JointTrajectory_IsConstraintValid(const Base_NamedVector_Base_JointTrajectory* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((1 <= pVal->elements.arr[i1].nCount) && (pVal->elements.arr[i1].nCount <= 200));
            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].arr[i2].position) && (pVal->elements.arr[i1].arr[i2].position <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_POSITION; 
            	    	if (ret) {
            	    	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].speed) && (pVal->elements.arr[i1].arr[i2].speed <= 3.40282346600000020000E+038));
            	    	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_SPEED; 
            	    	    if (ret) {
            	    	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].effort) && (pVal->elements.arr[i1].arr[i2].effort <= 3.40282346600000020000E+038));
            	    	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_EFFORT; 
            	    	        if (ret) {
            	    	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].raw) && (pVal->elements.arr[i1].arr[i2].raw <= 3.40282346600000020000E+038));
            	    	            *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_RAW; 
            	    	            if (ret) {
            	    	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].arr[i2].acceleration) && (pVal->elements.arr[i1].arr[i2].acceleration <= 3.40282346600000020000E+038));
            	    	                *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS_ELM_ELM_ACCELERATION; 
            	    	            }
            	    	        }
            	    	    }
            	    	}
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_NamedVector_Base_JointTrajectory_Encode(const Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = Base_JointTrajectory_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_NamedVector_Base_JointTrajectory_Decode(Base_NamedVector_Base_JointTrajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRAJECTORY_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = Base_JointTrajectory_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_NamedVector_Base_JointTrajectory_IsConstraintValid(pVal, pErrCode);
}



void Base_commands_Joints_names_Initialize(Base_commands_Joints_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_commands_Joints_Initialize(Base_commands_Joints* pVal)
{


	/*set names */
	Base_commands_Joints_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_JointTrajectory_Initialize((&(pVal->elements)));
	/*set time */
	Base_Time_Initialize((&(pVal->time)));
}

flag Base_commands_Joints_IsConstraintValid(const Base_commands_Joints* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].position) && (pVal->elements.arr[i1].position <= 1.79769313486231570000E+308));
            	*pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_POSITION; 
            	if (ret) {
            	    ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].speed) && (pVal->elements.arr[i1].speed <= 3.40282346600000020000E+038));
            	    *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_SPEED; 
            	    if (ret) {
            	        ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].effort) && (pVal->elements.arr[i1].effort <= 3.40282346600000020000E+038));
            	        *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_EFFORT; 
            	        if (ret) {
            	            ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].raw) && (pVal->elements.arr[i1].raw <= 3.40282346600000020000E+038));
            	            *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_RAW; 
            	            if (ret) {
            	                ret = ((-3.40282346600000020000E+038 <= pVal->elements.arr[i1].acceleration) && (pVal->elements.arr[i1].acceleration <= 3.40282346600000020000E+038));
            	                *pErrCode = ret ? 0 :  ERR_BASE_COMMANDS_JOINTS_ELEMENTS_ELM_ACCELERATION; 
            	            }
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_commands_Joints_Encode(const Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_commands_Joints_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = Base_JointTrajectory_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_commands_Joints_Decode(Base_commands_Joints* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_COMMANDS_JOINTS_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = Base_JointTrajectory_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_commands_Joints_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_RigidBodyState_Initialize(Base_samples_RigidBodyState* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set sourceframe */
	T_String_Initialize((&(pVal->sourceframe)));
	/*set targetframe */
	T_String_Initialize((&(pVal->targetframe)));
	/*set position */
	Wrappers_Vector3d_Initialize((&(pVal->position)));
	/*set cov_position */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_position)));
	/*set orientation */
	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
	/*set cov_orientation */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_orientation)));
	/*set velocity */
	Wrappers_Vector3d_Initialize((&(pVal->velocity)));
	/*set cov_velocity */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_velocity)));
	/*set angular_velocity */
	Wrappers_Vector3d_Initialize((&(pVal->angular_velocity)));
	/*set cov_angular_velocity */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_velocity)));
}

flag Base_samples_RigidBodyState_IsConstraintValid(const Base_samples_RigidBodyState* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = (pVal->sourceframe.nCount <= 40);
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_SOURCEFRAME; 
    if (ret) {
        ret = (pVal->targetframe.nCount <= 40);
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_TARGETFRAME; 
        if (ret) {
            ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_POSITION_DATA_ELM; 
                }
            }
            if (ret) {
                ret = ((1 <= pVal->cov_position.data.nCount) && (pVal->cov_position.data.nCount <= 9));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->cov_position.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_position.data.arr[i1]) && (pVal->cov_position.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_POSITION_DATA_ELM; 
                    }
                }
                if (ret) {
                    ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM; 
                    if (ret) {
                        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_IM_ELM; 
                        }
                    }
                    if (ret) {
                        ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ORIENTATION_RE; 
                    }
                    if (ret) {
                        ret = ((1 <= pVal->cov_orientation.data.nCount) && (pVal->cov_orientation.data.nCount <= 9));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA; 
                        if (ret) {
                            for(i1 = 0; ret && i1 < pVal->cov_orientation.data.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_orientation.data.arr[i1]) && (pVal->cov_orientation.data.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ORIENTATION_DATA_ELM; 
                            }
                        }
                        if (ret) {
                            ret = ((1 <= pVal->velocity.data.nCount) && (pVal->velocity.data.nCount <= 3));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA; 
                            if (ret) {
                                for(i1 = 0; ret && i1 < pVal->velocity.data.nCount; i1++) 
                                {
                                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.data.arr[i1]) && (pVal->velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_VELOCITY_DATA_ELM; 
                                }
                            }
                            if (ret) {
                                ret = ((1 <= pVal->cov_velocity.data.nCount) && (pVal->cov_velocity.data.nCount <= 9));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA; 
                                if (ret) {
                                    for(i1 = 0; ret && i1 < pVal->cov_velocity.data.nCount; i1++) 
                                    {
                                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_velocity.data.arr[i1]) && (pVal->cov_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_VELOCITY_DATA_ELM; 
                                    }
                                }
                                if (ret) {
                                    ret = ((1 <= pVal->angular_velocity.data.nCount) && (pVal->angular_velocity.data.nCount <= 3));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA; 
                                    if (ret) {
                                        for(i1 = 0; ret && i1 < pVal->angular_velocity.data.nCount; i1++) 
                                        {
                                        	ret = ((-1.79769313486231570000E+308 <= pVal->angular_velocity.data.arr[i1]) && (pVal->angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_ANGULAR_VELOCITY_DATA_ELM; 
                                        }
                                    }
                                    if (ret) {
                                        ret = ((1 <= pVal->cov_angular_velocity.data.nCount) && (pVal->cov_angular_velocity.data.nCount <= 9));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA; 
                                        if (ret) {
                                            for(i1 = 0; ret && i1 < pVal->cov_angular_velocity.data.nCount; i1++) 
                                            {
                                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_velocity.data.arr[i1]) && (pVal->cov_angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_COV_ANGULAR_VELOCITY_DATA_ELM; 
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_RigidBodyState_Encode(const Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sourceframe */
	        ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode targetframe */
	            ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode position */
	                ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_position */
	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_position)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode orientation */
	                        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode cov_orientation */
	                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_orientation)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode velocity */
	                                ret = Wrappers_Vector3d_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode cov_velocity */
	                                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_velocity)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode angular_velocity */
	                                        ret = Wrappers_Vector3d_Encode((&(pVal->angular_velocity)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode cov_angular_velocity */
	                                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_RigidBodyState_Decode(Base_samples_RigidBodyState* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sourceframe */
	    ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode targetframe */
	        ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode position */
	            ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_position */
	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_position)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode orientation */
	                    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode cov_orientation */
	                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_orientation)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode velocity */
	                            ret = Wrappers_Vector3d_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode cov_velocity */
	                                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_velocity)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode angular_velocity */
	                                    ret = Wrappers_Vector3d_Decode((&(pVal->angular_velocity)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode cov_angular_velocity */
	                                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_RigidBodyState_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Wrenches_names_Initialize(Base_samples_Wrenches_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Wrenches_elements_Initialize(Base_samples_Wrenches_elements* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Wrench_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Wrenches_Initialize(Base_samples_Wrenches* pVal)
{


	/*set names */
	Base_samples_Wrenches_names_Initialize((&(pVal->names)));
	/*set elements */
	Base_samples_Wrenches_elements_Initialize((&(pVal->elements)));
	/*set time */
	Base_Time_Initialize((&(pVal->time)));
}

flag Base_samples_Wrenches_IsConstraintValid(const Base_samples_Wrenches* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_FORCE_DATA_ELM; 
            	    }
            	}
            	if (ret) {
            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
            	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA; 
            	    if (ret) {
            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++) 
            	        {
            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
            	        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_ELEMENTS_ELM_TORQUE_DATA_ELM; 
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_samples_Wrenches_Encode(const Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_Wrenches_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->elements.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	        {
	        	ret = Base_Wrench_Encode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode time */
	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Wrenches_Decode(Base_samples_Wrenches* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_ELEMENTS;
	    pVal->elements.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->elements.nCount) && ret; i1++) 
	    {
	    	ret = Base_Wrench_Decode((&(pVal->elements.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode time */
	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_samples_Wrenches_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_frame_frame_attrib_t_Initialize(Base_samples_frame_frame_attrib_t* pVal)
{


	/*set data */
	T_String_Initialize((&(pVal->data)));
	/*set name_val */
	T_String_Initialize((&(pVal->name_val)));
}

flag Base_samples_frame_frame_attrib_t_IsConstraintValid(const Base_samples_frame_frame_attrib_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = (pVal->data.nCount <= 40);
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_DATA; 
    if (ret) {
        ret = (pVal->name_val.nCount <= 40);
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIB_T_NAME_VAL; 
    }

	return ret;
}

flag Base_samples_frame_frame_attrib_t_Encode(const Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode data */
	    ret = T_String_Encode((&(pVal->data)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode name_val */
	        ret = T_String_Encode((&(pVal->name_val)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_frame_frame_attrib_t_Decode(Base_samples_frame_frame_attrib_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode data */
	ret = T_String_Decode((&(pVal->data)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode name_val */
	    ret = T_String_Decode((&(pVal->name_val)), pBitStrm, pErrCode);
	}

	return ret  && Base_samples_frame_frame_attrib_t_IsConstraintValid(pVal, pErrCode);
}



void Base_JointTransform_m_Initialize(Base_JointTransform_m* pVal)
{


	/*set sourceframe */
	T_String_Initialize((&(pVal->sourceframe)));
	/*set targetframe */
	T_String_Initialize((&(pVal->targetframe)));
	/*set rotationaxis */
	Wrappers_Vector3d_Initialize((&(pVal->rotationaxis)));
}

flag Base_JointTransform_m_IsConstraintValid(const Base_JointTransform_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = (pVal->sourceframe.nCount <= 40);
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_SOURCEFRAME; 
    if (ret) {
        ret = (pVal->targetframe.nCount <= 40);
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_TARGETFRAME; 
        if (ret) {
            ret = ((1 <= pVal->rotationaxis.data.nCount) && (pVal->rotationaxis.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->rotationaxis.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->rotationaxis.data.arr[i1]) && (pVal->rotationaxis.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORM_M_ROTATIONAXIS_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Base_JointTransform_m_Encode(const Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode sourceframe */
	    ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode targetframe */
	        ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode rotationaxis */
	            ret = Wrappers_Vector3d_Encode((&(pVal->rotationaxis)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointTransform_m_Decode(Base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode sourceframe */
	ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode targetframe */
	    ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode rotationaxis */
	        ret = Wrappers_Vector3d_Decode((&(pVal->rotationaxis)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_JointTransform_m_IsConstraintValid(pVal, pErrCode);
}



void Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_JointTransform_m_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = (pVal->arr[i1].sourceframe.nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_SOURCEFRAME; 
        	if (ret) {
        	    ret = (pVal->arr[i1].targetframe.nCount <= 40);
        	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_TARGETFRAME; 
        	    if (ret) {
        	        ret = ((1 <= pVal->arr[i1].rotationaxis.data.nCount) && (pVal->arr[i1].rotationaxis.data.nCount <= 3));
        	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA; 
        	        if (ret) {
        	            for(i2 = 0; ret && i2 < pVal->arr[i1].rotationaxis.data.nCount; i2++) 
        	            {
        	            	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].rotationaxis.data.arr[i2]) && (pVal->arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
        	            	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM_ELM_ROTATIONAXIS_DATA_ELM; 
        	            }
        	        }
        	    }
        	}
        }
    }

	return ret;
}

flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode(const Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = Base_JointTransform_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode(Std_orogen_typekits_mtype_std_vector_base_JointTransform* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_JOINTTRANSFORM;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = Base_JointTransform_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Std_orogen_typekits_mtype_std_vector_base_JointTransform_IsConstraintValid(pVal, pErrCode);
}



void Base_JointTransformVector_m_names_Initialize(Base_JointTransformVector_m_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_JointTransformVector_m_Initialize(Base_JointTransformVector_m* pVal)
{


	/*set names */
	Base_JointTransformVector_m_names_Initialize((&(pVal->names)));
	/*set elements */
	Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize((&(pVal->elements)));
}

flag Base_JointTransformVector_m_IsConstraintValid(const Base_JointTransformVector_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_SOURCEFRAME; 
            	if (ret) {
            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
            	    *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_TARGETFRAME; 
            	    if (ret) {
            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
            	        *pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA; 
            	        if (ret) {
            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++) 
            	            {
            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
            	            	*pErrCode = ret ? 0 :  ERR_BASE_JOINTTRANSFORMVECTOR_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM; 
            	            }
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_JointTransformVector_m_Encode(const Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_JointTransformVector_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointTransformVector_m_Decode(Base_JointTransformVector_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTTRANSFORMVECTOR_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	}

	return ret  && Base_JointTransformVector_m_IsConstraintValid(pVal, pErrCode);
}



void Base_NamedVector_base_JointTransform_m_names_Initialize(Base_NamedVector_base_JointTransform_m_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_base_JointTransform_m_Initialize(Base_NamedVector_base_JointTransform_m* pVal)
{


	/*set names */
	Base_NamedVector_base_JointTransform_m_names_Initialize((&(pVal->names)));
	/*set elements */
	Std_orogen_typekits_mtype_std_vector_base_JointTransform_Initialize((&(pVal->elements)));
}

flag Base_NamedVector_base_JointTransform_m_IsConstraintValid(const Base_NamedVector_base_JointTransform_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = (pVal->elements.arr[i1].sourceframe.nCount <= 40);
            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_SOURCEFRAME; 
            	if (ret) {
            	    ret = (pVal->elements.arr[i1].targetframe.nCount <= 40);
            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_TARGETFRAME; 
            	    if (ret) {
            	        ret = ((1 <= pVal->elements.arr[i1].rotationaxis.data.nCount) && (pVal->elements.arr[i1].rotationaxis.data.nCount <= 3));
            	        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA; 
            	        if (ret) {
            	            for(i2 = 0; ret && i2 < pVal->elements.arr[i1].rotationaxis.data.nCount; i2++) 
            	            {
            	            	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].rotationaxis.data.arr[i2]) && (pVal->elements.arr[i1].rotationaxis.data.arr[i2] <= 1.79769313486231570000E+308));
            	            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_ELEMENTS_ELM_ROTATIONAXIS_DATA_ELM; 
            	            }
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_NamedVector_base_JointTransform_m_Encode(const Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_NamedVector_base_JointTransform_m_Decode(Base_NamedVector_base_JointTransform_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_JOINTTRANSFORM_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = Std_orogen_typekits_mtype_std_vector_base_JointTransform_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	}

	return ret  && Base_NamedVector_base_JointTransform_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_RigidBodyState_m_Initialize(Base_samples_RigidBodyState_m* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set sourceframe */
	T_String_Initialize((&(pVal->sourceframe)));
	/*set targetframe */
	T_String_Initialize((&(pVal->targetframe)));
	/*set position */
	Wrappers_Vector3d_Initialize((&(pVal->position)));
	/*set cov_position */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_position)));
	/*set orientation */
	Wrappers_Quaterniond_Initialize((&(pVal->orientation)));
	/*set cov_orientation */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_orientation)));
	/*set velocity */
	Wrappers_Vector3d_Initialize((&(pVal->velocity)));
	/*set cov_velocity */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_velocity)));
	/*set angular_velocity */
	Wrappers_Vector3d_Initialize((&(pVal->angular_velocity)));
	/*set cov_angular_velocity */
	Wrappers_Matrix3d_Initialize((&(pVal->cov_angular_velocity)));
}

flag Base_samples_RigidBodyState_m_IsConstraintValid(const Base_samples_RigidBodyState_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = (pVal->sourceframe.nCount <= 40);
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_SOURCEFRAME; 
    if (ret) {
        ret = (pVal->targetframe.nCount <= 40);
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_TARGETFRAME; 
        if (ret) {
            ret = ((1 <= pVal->position.data.nCount) && (pVal->position.data.nCount <= 3));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->position.data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->position.data.arr[i1]) && (pVal->position.data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_POSITION_DATA_ELM; 
                }
            }
            if (ret) {
                ret = ((1 <= pVal->cov_position.data.nCount) && (pVal->cov_position.data.nCount <= 9));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->cov_position.data.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_position.data.arr[i1]) && (pVal->cov_position.data.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_POSITION_DATA_ELM; 
                    }
                }
                if (ret) {
                    ret = ((1 <= pVal->orientation.im.nCount) && (pVal->orientation.im.nCount <= 3));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM; 
                    if (ret) {
                        for(i1 = 0; ret && i1 < pVal->orientation.im.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->orientation.im.arr[i1]) && (pVal->orientation.im.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_IM_ELM; 
                        }
                    }
                    if (ret) {
                        ret = ((-1.79769313486231570000E+308 <= pVal->orientation.re) && (pVal->orientation.re <= 1.79769313486231570000E+308));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ORIENTATION_RE; 
                    }
                    if (ret) {
                        ret = ((1 <= pVal->cov_orientation.data.nCount) && (pVal->cov_orientation.data.nCount <= 9));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA; 
                        if (ret) {
                            for(i1 = 0; ret && i1 < pVal->cov_orientation.data.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_orientation.data.arr[i1]) && (pVal->cov_orientation.data.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ORIENTATION_DATA_ELM; 
                            }
                        }
                        if (ret) {
                            ret = ((1 <= pVal->velocity.data.nCount) && (pVal->velocity.data.nCount <= 3));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA; 
                            if (ret) {
                                for(i1 = 0; ret && i1 < pVal->velocity.data.nCount; i1++) 
                                {
                                	ret = ((-1.79769313486231570000E+308 <= pVal->velocity.data.arr[i1]) && (pVal->velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_VELOCITY_DATA_ELM; 
                                }
                            }
                            if (ret) {
                                ret = ((1 <= pVal->cov_velocity.data.nCount) && (pVal->cov_velocity.data.nCount <= 9));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA; 
                                if (ret) {
                                    for(i1 = 0; ret && i1 < pVal->cov_velocity.data.nCount; i1++) 
                                    {
                                    	ret = ((-1.79769313486231570000E+308 <= pVal->cov_velocity.data.arr[i1]) && (pVal->cov_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_VELOCITY_DATA_ELM; 
                                    }
                                }
                                if (ret) {
                                    ret = ((1 <= pVal->angular_velocity.data.nCount) && (pVal->angular_velocity.data.nCount <= 3));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA; 
                                    if (ret) {
                                        for(i1 = 0; ret && i1 < pVal->angular_velocity.data.nCount; i1++) 
                                        {
                                        	ret = ((-1.79769313486231570000E+308 <= pVal->angular_velocity.data.arr[i1]) && (pVal->angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_ANGULAR_VELOCITY_DATA_ELM; 
                                        }
                                    }
                                    if (ret) {
                                        ret = ((1 <= pVal->cov_angular_velocity.data.nCount) && (pVal->cov_angular_velocity.data.nCount <= 9));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA; 
                                        if (ret) {
                                            for(i1 = 0; ret && i1 < pVal->cov_angular_velocity.data.nCount; i1++) 
                                            {
                                            	ret = ((-1.79769313486231570000E+308 <= pVal->cov_angular_velocity.data.arr[i1]) && (pVal->cov_angular_velocity.data.arr[i1] <= 1.79769313486231570000E+308));
                                            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_RIGIDBODYSTATE_M_COV_ANGULAR_VELOCITY_DATA_ELM; 
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_RigidBodyState_m_Encode(const Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode sourceframe */
	        ret = T_String_Encode((&(pVal->sourceframe)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode targetframe */
	            ret = T_String_Encode((&(pVal->targetframe)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode position */
	                ret = Wrappers_Vector3d_Encode((&(pVal->position)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode cov_position */
	                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_position)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode orientation */
	                        ret = Wrappers_Quaterniond_Encode((&(pVal->orientation)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode cov_orientation */
	                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_orientation)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode velocity */
	                                ret = Wrappers_Vector3d_Encode((&(pVal->velocity)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode cov_velocity */
	                                    ret = Wrappers_Matrix3d_Encode((&(pVal->cov_velocity)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode angular_velocity */
	                                        ret = Wrappers_Vector3d_Encode((&(pVal->angular_velocity)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode cov_angular_velocity */
	                                            ret = Wrappers_Matrix3d_Encode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_RigidBodyState_m_Decode(Base_samples_RigidBodyState_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode sourceframe */
	    ret = T_String_Decode((&(pVal->sourceframe)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode targetframe */
	        ret = T_String_Decode((&(pVal->targetframe)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode position */
	            ret = Wrappers_Vector3d_Decode((&(pVal->position)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode cov_position */
	                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_position)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode orientation */
	                    ret = Wrappers_Quaterniond_Decode((&(pVal->orientation)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode cov_orientation */
	                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_orientation)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode velocity */
	                            ret = Wrappers_Vector3d_Decode((&(pVal->velocity)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode cov_velocity */
	                                ret = Wrappers_Matrix3d_Decode((&(pVal->cov_velocity)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode angular_velocity */
	                                    ret = Wrappers_Vector3d_Decode((&(pVal->angular_velocity)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode cov_angular_velocity */
	                                        ret = Wrappers_Matrix3d_Decode((&(pVal->cov_angular_velocity)), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_RigidBodyState_m_IsConstraintValid(pVal, pErrCode);
}



void Base_NamedVector_base_Wrench_m_names_Initialize(Base_NamedVector_base_Wrench_m_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_NamedVector_base_Wrench_m_Initialize(Base_NamedVector_base_Wrench_m* pVal)
{


	/*set names */
	Base_NamedVector_base_Wrench_m_names_Initialize((&(pVal->names)));
	/*set elements */
	Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize((&(pVal->elements)));
}

flag Base_NamedVector_base_Wrench_m_IsConstraintValid(const Base_NamedVector_base_Wrench_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
            	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_FORCE_DATA_ELM; 
            	    }
            	}
            	if (ret) {
            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
            	    *pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA; 
            	    if (ret) {
            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++) 
            	        {
            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
            	        	*pErrCode = ret ? 0 :  ERR_BASE_NAMEDVECTOR_BASE_WRENCH_M_ELEMENTS_ELM_TORQUE_DATA_ELM; 
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_NamedVector_base_Wrench_m_Encode(const Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_NamedVector_base_Wrench_m_Decode(Base_NamedVector_base_Wrench_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_NAMEDVECTOR_BASE_WRENCH_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	}

	return ret  && Base_NamedVector_base_Wrench_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Wrenches_m_names_Initialize(Base_samples_Wrenches_m_names* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_String_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Wrenches_m_Initialize(Base_samples_Wrenches_m* pVal)
{


	/*set names */
	Base_samples_Wrenches_m_names_Initialize((&(pVal->names)));
	/*set elements */
	Std_orogen_typekits_mtype_std_vector_base_Wrench_Initialize((&(pVal->elements)));
	/*set time */
	Base_Time_Initialize((&(pVal->time)));
}

flag Base_samples_Wrenches_m_IsConstraintValid(const Base_samples_Wrenches_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->names.nCount) && (pVal->names.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_NAMES; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->names.nCount; i1++) 
        {
        	ret = (pVal->names.arr[i1].nCount <= 40);
        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_NAMES_ELM; 
        }
    }
    if (ret) {
        ret = ((1 <= pVal->elements.nCount) && (pVal->elements.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->elements.nCount; i1++) 
            {
            	ret = ((1 <= pVal->elements.arr[i1].force.data.nCount) && (pVal->elements.arr[i1].force.data.nCount <= 3));
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA; 
            	if (ret) {
            	    for(i2 = 0; ret && i2 < pVal->elements.arr[i1].force.data.nCount; i2++) 
            	    {
            	    	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].force.data.arr[i2]) && (pVal->elements.arr[i1].force.data.arr[i2] <= 1.79769313486231570000E+308));
            	    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_FORCE_DATA_ELM; 
            	    }
            	}
            	if (ret) {
            	    ret = ((1 <= pVal->elements.arr[i1].torque.data.nCount) && (pVal->elements.arr[i1].torque.data.nCount <= 3));
            	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA; 
            	    if (ret) {
            	        for(i2 = 0; ret && i2 < pVal->elements.arr[i1].torque.data.nCount; i2++) 
            	        {
            	        	ret = ((-1.79769313486231570000E+308 <= pVal->elements.arr[i1].torque.data.arr[i2]) && (pVal->elements.arr[i1].torque.data.arr[i2] <= 1.79769313486231570000E+308));
            	        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_WRENCHES_M_ELEMENTS_ELM_TORQUE_DATA_ELM; 
            	        }
            	    }
            	}
            }
        }
    }

	return ret;
}

flag Base_samples_Wrenches_m_Encode(const Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode names */
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->names.nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	    {
	    	ret = T_String_Encode((&(pVal->names.arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
	    if (ret) {
	        /*Encode elements */
	        ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Encode((&(pVal->elements)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode time */
	            ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Wrenches_m_Decode(Base_samples_Wrenches_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode names */
	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_WRENCHES_M_NAMES;
	pVal->names.nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->names.nCount) && ret; i1++) 
	{
		ret = T_String_Decode((&(pVal->names.arr[i1])), pBitStrm, pErrCode);
	}
	if (ret) {
	    /*Decode elements */
	    ret = Std_orogen_typekits_mtype_std_vector_base_Wrench_Decode((&(pVal->elements)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode time */
	        ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	    }
	}

	return ret  && Base_samples_Wrenches_m_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_LaserScan_ranges_Initialize(Base_samples_LaserScan_ranges* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_UInt32_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_LaserScan_remission_Initialize(Base_samples_LaserScan_remission* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_LaserScan_Initialize(Base_samples_LaserScan* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set start_angle */
	T_Double_Initialize((&(pVal->start_angle)));
	/*set angular_resolution */
	T_Double_Initialize((&(pVal->angular_resolution)));
	/*set speed */
	T_Double_Initialize((&(pVal->speed)));
	/*set ranges */
	Base_samples_LaserScan_ranges_Initialize((&(pVal->ranges)));
	/*set minrange */
	T_UInt32_Initialize((&(pVal->minrange)));
	/*set maxrange */
	T_UInt32_Initialize((&(pVal->maxrange)));
	/*set remission */
	Base_samples_LaserScan_remission_Initialize((&(pVal->remission)));
}

flag Base_samples_LaserScan_IsConstraintValid(const Base_samples_LaserScan* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->start_angle) && (pVal->start_angle <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_START_ANGLE; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->angular_resolution) && (pVal->angular_resolution <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_ANGULAR_RESOLUTION; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_SPEED; 
            if (ret) {
                ret = ((1 <= pVal->ranges.nCount) && (pVal->ranges.nCount <= 200));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_RANGES; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->ranges.nCount; i1++) 
                    {
                    	ret = (pVal->ranges.arr[i1] <= 4294967295UL);
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_RANGES_ELM; 
                    }
                }
                if (ret) {
                    ret = (pVal->minrange <= 4294967295UL);
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_MINRANGE; 
                    if (ret) {
                        ret = (pVal->maxrange <= 4294967295UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_MAXRANGE; 
                        if (ret) {
                            ret = ((1 <= pVal->remission.nCount) && (pVal->remission.nCount <= 200));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_REMISSION; 
                            if (ret) {
                                for(i1 = 0; ret && i1 < pVal->remission.nCount; i1++) 
                                {
                                	ret = ((-3.40282346600000020000E+038 <= pVal->remission.arr[i1]) && (pVal->remission.arr[i1] <= 3.40282346600000020000E+038));
                                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASERSCAN_REMISSION_ELM; 
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_LaserScan_Encode(const Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_LaserScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode start_angle */
	        ret = T_Double_Encode((&(pVal->start_angle)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode angular_resolution */
	            ret = T_Double_Encode((&(pVal->angular_resolution)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode speed */
	                ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode ranges */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->ranges.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++) 
	                    {
	                    	ret = T_UInt32_Encode((&(pVal->ranges.arr[i1])), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode minrange */
	                        ret = T_UInt32_Encode((&(pVal->minrange)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode maxrange */
	                            ret = T_UInt32_Encode((&(pVal->maxrange)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode remission */
	                                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remission.nCount, 1, 200);
	                                	
	                                for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++) 
	                                {
	                                	ret = T_Float_Encode((&(pVal->remission.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_LaserScan_Decode(Base_samples_LaserScan* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode start_angle */
	    ret = T_Double_Decode((&(pVal->start_angle)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode angular_resolution */
	        ret = T_Double_Decode((&(pVal->angular_resolution)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode speed */
	            ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode ranges */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_RANGES;
	                pVal->ranges.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->ranges.nCount) && ret; i1++) 
	                {
	                	ret = T_UInt32_Decode((&(pVal->ranges.arr[i1])), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode minrange */
	                    ret = T_UInt32_Decode((&(pVal->minrange)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode maxrange */
	                        ret = T_UInt32_Decode((&(pVal->maxrange)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode remission */
	                            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASERSCAN_REMISSION;
	                            pVal->remission.nCount = (long)nCount;
	                            	
	                            for(i1=0; (i1 < (int)pVal->remission.nCount) && ret; i1++) 
	                            {
	                            	ret = T_Float_Decode((&(pVal->remission.arr[i1])), pBitStrm, pErrCode);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_LaserScan_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_Sonar_timestamps_Initialize(Base_samples_Sonar_timestamps* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Time_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Sonar_bearings_Initialize(Base_samples_Sonar_bearings* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Angle_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Sonar_bins_Initialize(Base_samples_Sonar_bins* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_Sonar_Initialize(Base_samples_Sonar* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set timestamps */
	Base_samples_Sonar_timestamps_Initialize((&(pVal->timestamps)));
	/*set bin_duration */
	Base_Time_Initialize((&(pVal->bin_duration)));
	/*set beam_width */
	Base_Angle_Initialize((&(pVal->beam_width)));
	/*set beam_height */
	Base_Angle_Initialize((&(pVal->beam_height)));
	/*set bearings */
	Base_samples_Sonar_bearings_Initialize((&(pVal->bearings)));
	/*set speed_of_sound */
	T_Float_Initialize((&(pVal->speed_of_sound)));
	/*set bin_count */
	T_UInt32_Initialize((&(pVal->bin_count)));
	/*set beam_count */
	T_UInt32_Initialize((&(pVal->beam_count)));
	/*set bins */
	Base_samples_Sonar_bins_Initialize((&(pVal->bins)));
}

flag Base_samples_Sonar_IsConstraintValid(const Base_samples_Sonar* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->timestamps.nCount) && (pVal->timestamps.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_TIMESTAMPS; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->beam_width.rad) && (pVal->beam_width.rad <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_WIDTH_RAD; 
        if (ret) {
            ret = ((-1.79769313486231570000E+308 <= pVal->beam_height.rad) && (pVal->beam_height.rad <= 1.79769313486231570000E+308));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_HEIGHT_RAD; 
            if (ret) {
                ret = ((1 <= pVal->bearings.nCount) && (pVal->bearings.nCount <= 200));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEARINGS; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->bearings.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->bearings.arr[i1].rad) && (pVal->bearings.arr[i1].rad <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEARINGS_ELM_RAD; 
                    }
                }
                if (ret) {
                    ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_SPEED_OF_SOUND; 
                    if (ret) {
                        ret = (pVal->bin_count <= 4294967295UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BIN_COUNT; 
                        if (ret) {
                            ret = (pVal->beam_count <= 4294967295UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BEAM_COUNT; 
                            if (ret) {
                                ret = ((1 <= pVal->bins.nCount) && (pVal->bins.nCount <= 200));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BINS; 
                                if (ret) {
                                    for(i1 = 0; ret && i1 < pVal->bins.nCount; i1++) 
                                    {
                                    	ret = ((-3.40282346600000020000E+038 <= pVal->bins.arr[i1]) && (pVal->bins.arr[i1] <= 3.40282346600000020000E+038));
                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONAR_BINS_ELM; 
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_Sonar_Encode(const Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_Sonar_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timestamps */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	        {
	        	ret = Base_Time_Encode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode bin_duration */
	            ret = Base_Time_Encode((&(pVal->bin_duration)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode beam_width */
	                ret = Base_Angle_Encode((&(pVal->beam_width)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode beam_height */
	                    ret = Base_Angle_Encode((&(pVal->beam_height)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode bearings */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bearings.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++) 
	                        {
	                        	ret = Base_Angle_Encode((&(pVal->bearings.arr[i1])), pBitStrm, pErrCode, FALSE);
	                        }
	                        if (ret) {
	                            /*Encode speed_of_sound */
	                            ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode bin_count */
	                                ret = T_UInt32_Encode((&(pVal->bin_count)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode beam_count */
	                                    ret = T_UInt32_Encode((&(pVal->beam_count)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode bins */
	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->bins.nCount, 1, 200);
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++) 
	                                        {
	                                        	ret = T_Float_Encode((&(pVal->bins.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_Sonar_Decode(Base_samples_Sonar* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode timestamps */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_TIMESTAMPS;
	    pVal->timestamps.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	    {
	    	ret = Base_Time_Decode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode bin_duration */
	        ret = Base_Time_Decode((&(pVal->bin_duration)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode beam_width */
	            ret = Base_Angle_Decode((&(pVal->beam_width)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode beam_height */
	                ret = Base_Angle_Decode((&(pVal->beam_height)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode bearings */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BEARINGS;
	                    pVal->bearings.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->bearings.nCount) && ret; i1++) 
	                    {
	                    	ret = Base_Angle_Decode((&(pVal->bearings.arr[i1])), pBitStrm, pErrCode);
	                    }
	                    if (ret) {
	                        /*Decode speed_of_sound */
	                        ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode bin_count */
	                            ret = T_UInt32_Decode((&(pVal->bin_count)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode beam_count */
	                                ret = T_UInt32_Decode((&(pVal->beam_count)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode bins */
	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONAR_BINS;
	                                    pVal->bins.nCount = (long)nCount;
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->bins.nCount) && ret; i1++) 
	                                    {
	                                    	ret = T_Float_Decode((&(pVal->bins.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_Sonar_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_SonarScan_data_Initialize(Base_samples_SonarScan_data* pVal)
{

	memset(pVal->arr, 0x0, 200);
	pVal->nCount = 1;

}
void Base_samples_SonarScan_time_beams_Initialize(Base_samples_SonarScan_time_beams* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Time_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_SonarScan_Initialize(Base_samples_SonarScan* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set data */
	Base_samples_SonarScan_data_Initialize((&(pVal->data)));
	/*set time_beams */
	Base_samples_SonarScan_time_beams_Initialize((&(pVal->time_beams)));
	/*set number_of_beams */
	T_UInt16_Initialize((&(pVal->number_of_beams)));
	/*set number_of_bins */
	T_UInt16_Initialize((&(pVal->number_of_bins)));
	/*set start_bearing */
	Base_Angle_Initialize((&(pVal->start_bearing)));
	/*set angular_resolution */
	Base_Angle_Initialize((&(pVal->angular_resolution)));
	/*set sampling_interval */
	T_Double_Initialize((&(pVal->sampling_interval)));
	/*set speed_of_sound */
	T_Float_Initialize((&(pVal->speed_of_sound)));
	/*set beamwidth_horizontal */
	Base_Angle_Initialize((&(pVal->beamwidth_horizontal)));
	/*set beamwidth_vertical */
	Base_Angle_Initialize((&(pVal->beamwidth_vertical)));
	/*set memory_layout_column */
	T_Boolean_Initialize((&(pVal->memory_layout_column)));
	/*set polar_coordinates */
	T_Boolean_Initialize((&(pVal->polar_coordinates)));
}

flag Base_samples_SonarScan_IsConstraintValid(const Base_samples_SonarScan* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_DATA; 
    if (ret) {
        ret = ((1 <= pVal->time_beams.nCount) && (pVal->time_beams.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_TIME_BEAMS; 
        if (ret) {
            ret = (pVal->number_of_beams <= 65535UL);
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BEAMS; 
            if (ret) {
                ret = (pVal->number_of_bins <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_NUMBER_OF_BINS; 
                if (ret) {
                    ret = ((-1.79769313486231570000E+308 <= pVal->start_bearing.rad) && (pVal->start_bearing.rad <= 1.79769313486231570000E+308));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_START_BEARING_RAD; 
                    if (ret) {
                        ret = ((-1.79769313486231570000E+308 <= pVal->angular_resolution.rad) && (pVal->angular_resolution.rad <= 1.79769313486231570000E+308));
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_ANGULAR_RESOLUTION_RAD; 
                        if (ret) {
                            ret = ((-1.79769313486231570000E+308 <= pVal->sampling_interval) && (pVal->sampling_interval <= 1.79769313486231570000E+308));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_SAMPLING_INTERVAL; 
                            if (ret) {
                                ret = ((-3.40282346600000020000E+038 <= pVal->speed_of_sound) && (pVal->speed_of_sound <= 3.40282346600000020000E+038));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_SPEED_OF_SOUND; 
                                if (ret) {
                                    ret = ((-1.79769313486231570000E+308 <= pVal->beamwidth_horizontal.rad) && (pVal->beamwidth_horizontal.rad <= 1.79769313486231570000E+308));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_HORIZONTAL_RAD; 
                                    if (ret) {
                                        ret = ((-1.79769313486231570000E+308 <= pVal->beamwidth_vertical.rad) && (pVal->beamwidth_vertical.rad <= 1.79769313486231570000E+308));
                                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_SONARSCAN_BEAMWIDTH_VERTICAL_RAD; 
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_SonarScan_Encode(const Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_SonarScan_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode data */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	        {
	        	BitStream_AppendByte0(pBitStrm, pVal->data.arr[i1]);
	        }
	        if (ret) {
	            /*Encode time_beams */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->time_beams.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++) 
	            {
	            	ret = Base_Time_Encode((&(pVal->time_beams.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	            if (ret) {
	                /*Encode number_of_beams */
	                ret = T_UInt16_Encode((&(pVal->number_of_beams)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode number_of_bins */
	                    ret = T_UInt16_Encode((&(pVal->number_of_bins)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode start_bearing */
	                        ret = Base_Angle_Encode((&(pVal->start_bearing)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode angular_resolution */
	                            ret = Base_Angle_Encode((&(pVal->angular_resolution)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode sampling_interval */
	                                ret = T_Double_Encode((&(pVal->sampling_interval)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode speed_of_sound */
	                                    ret = T_Float_Encode((&(pVal->speed_of_sound)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode beamwidth_horizontal */
	                                        ret = Base_Angle_Encode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode, FALSE);
	                                        if (ret) {
	                                            /*Encode beamwidth_vertical */
	                                            ret = Base_Angle_Encode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode, FALSE);
	                                            if (ret) {
	                                                /*Encode memory_layout_column */
	                                                ret = T_Boolean_Encode((&(pVal->memory_layout_column)), pBitStrm, pErrCode, FALSE);
	                                                if (ret) {
	                                                    /*Encode polar_coordinates */
	                                                    ret = T_Boolean_Encode((&(pVal->polar_coordinates)), pBitStrm, pErrCode, FALSE);
	                                                }
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_SonarScan_Decode(Base_samples_SonarScan* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode data */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
	    pVal->data.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	    {
	    	ret = BitStream_ReadByte(pBitStrm, &(pVal->data.arr[i1])); 
	    	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_DATA;
	    }
	    if (ret) {
	        /*Decode time_beams */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_SONARSCAN_TIME_BEAMS;
	        pVal->time_beams.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->time_beams.nCount) && ret; i1++) 
	        {
	        	ret = Base_Time_Decode((&(pVal->time_beams.arr[i1])), pBitStrm, pErrCode);
	        }
	        if (ret) {
	            /*Decode number_of_beams */
	            ret = T_UInt16_Decode((&(pVal->number_of_beams)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode number_of_bins */
	                ret = T_UInt16_Decode((&(pVal->number_of_bins)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode start_bearing */
	                    ret = Base_Angle_Decode((&(pVal->start_bearing)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode angular_resolution */
	                        ret = Base_Angle_Decode((&(pVal->angular_resolution)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode sampling_interval */
	                            ret = T_Double_Decode((&(pVal->sampling_interval)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode speed_of_sound */
	                                ret = T_Float_Decode((&(pVal->speed_of_sound)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode beamwidth_horizontal */
	                                    ret = Base_Angle_Decode((&(pVal->beamwidth_horizontal)), pBitStrm, pErrCode);
	                                    if (ret) {
	                                        /*Decode beamwidth_vertical */
	                                        ret = Base_Angle_Decode((&(pVal->beamwidth_vertical)), pBitStrm, pErrCode);
	                                        if (ret) {
	                                            /*Decode memory_layout_column */
	                                            ret = T_Boolean_Decode((&(pVal->memory_layout_column)), pBitStrm, pErrCode);
	                                            if (ret) {
	                                                /*Decode polar_coordinates */
	                                                ret = T_Boolean_Decode((&(pVal->polar_coordinates)), pBitStrm, pErrCode);
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_SonarScan_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_MatrixXd_data_Initialize(Wrappers_MatrixXd_data* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_MatrixXd_Initialize(Wrappers_MatrixXd* pVal)
{


	/*set rows */
	T_Int32_Initialize((&(pVal->rows)));
	/*set cols */
	T_Int32_Initialize((&(pVal->cols)));
	/*set data */
	Wrappers_MatrixXd_data_Initialize((&(pVal->data)));
}

flag Wrappers_MatrixXd_IsConstraintValid(const Wrappers_MatrixXd* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-2147483648LL <= pVal->rows) && (pVal->rows <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_ROWS; 
    if (ret) {
        ret = ((-2147483648LL <= pVal->cols) && (pVal->cols <= 2147483647LL));
        *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_COLS; 
        if (ret) {
            ret = ((1 <= pVal->data.nCount) && (pVal->data.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_DATA; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->data.nCount; i1++) 
                {
                	ret = ((-1.79769313486231570000E+308 <= pVal->data.arr[i1]) && (pVal->data.arr[i1] <= 1.79769313486231570000E+308));
                	*pErrCode = ret ? 0 :  ERR_WRAPPERS_MATRIXXD_DATA_ELM; 
                }
            }
        }
    }

	return ret;
}

flag Wrappers_MatrixXd_Encode(const Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_MatrixXd_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode rows */
	    ret = T_Int32_Encode((&(pVal->rows)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode cols */
	        ret = T_Int32_Encode((&(pVal->cols)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode data */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->data.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	            {
	            	ret = T_Double_Encode((&(pVal->data.arr[i1])), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_MatrixXd_Decode(Wrappers_MatrixXd* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode rows */
	ret = T_Int32_Decode((&(pVal->rows)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode cols */
	    ret = T_Int32_Decode((&(pVal->cols)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode data */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_MATRIXXD_DATA;
	        pVal->data.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->data.nCount) && ret; i1++) 
	        {
	        	ret = T_Double_Decode((&(pVal->data.arr[i1])), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Wrappers_MatrixXd_IsConstraintValid(pVal, pErrCode);
}



void Dummy2Base_T_Initialize(Dummy2Base_T* pVal)
{

	DummyBase_T_Initialize(pVal);
}

flag Dummy2Base_T_IsConstraintValid(const Dummy2Base_T* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_DUMMY2BASE_T; 

	return ret;
}

flag Dummy2Base_T_Encode(const Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Dummy2Base_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    ret = DummyBase_T_Encode(pVal, pBitStrm, pErrCode, FALSE);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Dummy2Base_T_Decode(Dummy2Base_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	ret = DummyBase_T_Decode(pVal, pBitStrm, pErrCode);

	return ret  && Dummy2Base_T_IsConstraintValid(pVal, pErrCode);
}



void Base_JointState_MODE_Initialize(Base_JointState_MODE* pVal)
{

	(*(pVal)) = base_jointstate_mode_acceleration;
}

flag Base_JointState_MODE_IsConstraintValid(const Base_JointState_MODE* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((*(pVal)) == base_jointstate_mode_acceleration)) || (((*(pVal)) == base_jointstate_mode_effort)))) || (((*(pVal)) == base_jointstate_mode_position)))) || (((*(pVal)) == base_jointstate_mode_raw)))) || (((*(pVal)) == base_jointstate_mode_speed)))) || (((*(pVal)) == base_jointstate_mode_unset)));
    *pErrCode = ret ? 0 :  ERR_BASE_JOINTSTATE_MODE; 

	return ret;
}

flag Base_JointState_MODE_Encode(const Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_JointState_MODE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_jointstate_mode_acceleration:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case base_jointstate_mode_effort:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case base_jointstate_mode_position:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case base_jointstate_mode_raw:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case base_jointstate_mode_speed:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case base_jointstate_mode_unset:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_JOINTSTATE_MODE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_JointState_MODE_Decode(Base_JointState_MODE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_JOINTSTATE_MODE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_jointstate_mode_acceleration;
	                break;
	            case 1: 
	                (*(pVal)) = base_jointstate_mode_effort;
	                break;
	            case 2: 
	                (*(pVal)) = base_jointstate_mode_position;
	                break;
	            case 3: 
	                (*(pVal)) = base_jointstate_mode_raw;
	                break;
	            case 4: 
	                (*(pVal)) = base_jointstate_mode_speed;
	                break;
	            case 5: 
	                (*(pVal)) = base_jointstate_mode_unset;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_JOINTSTATE_MODE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_jointstate_mode_acceleration;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_JointState_MODE_IsConstraintValid(pVal, pErrCode);
}



void Base_Time_Resolution_Initialize(Base_Time_Resolution* pVal)
{

	(*(pVal)) = base_time_resolution_microseconds;
}

flag Base_Time_Resolution_IsConstraintValid(const Base_Time_Resolution* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((*(pVal)) == base_time_resolution_microseconds)) || (((*(pVal)) == base_time_resolution_milliseconds)))) || (((*(pVal)) == base_time_resolution_seconds)));
    *pErrCode = ret ? 0 :  ERR_BASE_TIME_RESOLUTION; 

	return ret;
}

flag Base_Time_Resolution_Encode(const Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Time_Resolution_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_time_resolution_microseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case base_time_resolution_milliseconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case base_time_resolution_seconds:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_TIME_RESOLUTION; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Time_Resolution_Decode(Base_Time_Resolution* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_TIME_RESOLUTION;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_time_resolution_microseconds;
	                break;
	            case 1: 
	                (*(pVal)) = base_time_resolution_milliseconds;
	                break;
	            case 2: 
	                (*(pVal)) = base_time_resolution_seconds;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_TIME_RESOLUTION;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_time_resolution_microseconds;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_Time_Resolution_IsConstraintValid(pVal, pErrCode);
}



void Base_geometry_SplineBase_CoordinateType_Initialize(Base_geometry_SplineBase_CoordinateType* pVal)
{

	(*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;
}

flag Base_geometry_SplineBase_CoordinateType_IsConstraintValid(const Base_geometry_SplineBase_CoordinateType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((((((*(pVal)) == base_geometry_splinebase_coordinatetype_derivative_to_next)) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_derivative_to_prior)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_knuckle_point)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_ordinary_point)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_second_derivative_to_next)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_second_derivative_to_prior)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_tangent_point_for_next)))) || (((*(pVal)) == base_geometry_splinebase_coordinatetype_tangent_point_for_prior)));
    *pErrCode = ret ? 0 :  ERR_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE; 

	return ret;
}

flag Base_geometry_SplineBase_CoordinateType_Encode(const Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_geometry_splinebase_coordinatetype_derivative_to_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 7);
	        	break;
	        case base_geometry_splinebase_coordinatetype_derivative_to_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 7);
	        	break;
	        case base_geometry_splinebase_coordinatetype_knuckle_point:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 7);
	        	break;
	        case base_geometry_splinebase_coordinatetype_ordinary_point:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 7);
	        	break;
	        case base_geometry_splinebase_coordinatetype_second_derivative_to_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 7);
	        	break;
	        case base_geometry_splinebase_coordinatetype_second_derivative_to_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 7);
	        	break;
	        case base_geometry_splinebase_coordinatetype_tangent_point_for_next:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 7);
	        	break;
	        case base_geometry_splinebase_coordinatetype_tangent_point_for_prior:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 7);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_geometry_SplineBase_CoordinateType_Decode(Base_geometry_SplineBase_CoordinateType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 7);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;
	                break;
	            case 1: 
	                (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_prior;
	                break;
	            case 2: 
	                (*(pVal)) = base_geometry_splinebase_coordinatetype_knuckle_point;
	                break;
	            case 3: 
	                (*(pVal)) = base_geometry_splinebase_coordinatetype_ordinary_point;
	                break;
	            case 4: 
	                (*(pVal)) = base_geometry_splinebase_coordinatetype_second_derivative_to_next;
	                break;
	            case 5: 
	                (*(pVal)) = base_geometry_splinebase_coordinatetype_second_derivative_to_prior;
	                break;
	            case 6: 
	                (*(pVal)) = base_geometry_splinebase_coordinatetype_tangent_point_for_next;
	                break;
	            case 7: 
	                (*(pVal)) = base_geometry_splinebase_coordinatetype_tangent_point_for_prior;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_GEOMETRY_SPLINEBASE_COORDINATETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_geometry_splinebase_coordinatetype_derivative_to_next;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_geometry_SplineBase_CoordinateType_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Initialize(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal)
{

	(*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;
}

flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((*(pVal)) == base_samples_depthmap_depth_measurement_state_measurement_error)) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_too_far)))) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_too_near)))) || (((*(pVal)) == base_samples_depthmap_depth_measurement_state_valid_measurement)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE; 

	return ret;
}

flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Encode(const Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_samples_depthmap_depth_measurement_state_measurement_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 3);
	        	break;
	        case base_samples_depthmap_depth_measurement_state_too_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 3);
	        	break;
	        case base_samples_depthmap_depth_measurement_state_too_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 3);
	        	break;
	        case base_samples_depthmap_depth_measurement_state_valid_measurement:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 3);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_Decode(Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 3);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;
	                break;
	            case 1: 
	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_too_far;
	                break;
	            case 2: 
	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_too_near;
	                break;
	            case 3: 
	                (*(pVal)) = base_samples_depthmap_depth_measurement_state_valid_measurement;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DEPTH_MEASUREMENT_STATE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_samples_depthmap_depth_measurement_state_measurement_error;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_samples_DepthMap_DEPTH_MEASUREMENT_STATE_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_DepthMap_PROJECTION_TYPE_Initialize(Base_samples_DepthMap_PROJECTION_TYPE* pVal)
{

	(*(pVal)) = base_samples_depthmap_projection_type_planar;
}

flag Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((*(pVal)) == base_samples_depthmap_projection_type_planar)) || (((*(pVal)) == base_samples_depthmap_projection_type_polar)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE; 

	return ret;
}

flag Base_samples_DepthMap_PROJECTION_TYPE_Encode(const Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_samples_depthmap_projection_type_planar:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 1);
	        	break;
	        case base_samples_depthmap_projection_type_polar:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 1);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_DepthMap_PROJECTION_TYPE_Decode(Base_samples_DepthMap_PROJECTION_TYPE* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 1);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_samples_depthmap_projection_type_planar;
	                break;
	            case 1: 
	                (*(pVal)) = base_samples_depthmap_projection_type_polar;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_PROJECTION_TYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_samples_depthmap_projection_type_planar;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_samples_DepthMap_PROJECTION_TYPE_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_DepthMap_timestamps_Initialize(Base_samples_DepthMap_timestamps* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Time_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_DepthMap_vertical_interval_Initialize(Base_samples_DepthMap_vertical_interval* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_DepthMap_horizontal_interval_Initialize(Base_samples_DepthMap_horizontal_interval* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_DepthMap_distances_Initialize(Base_samples_DepthMap_distances* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_DepthMap_remissions_Initialize(Base_samples_DepthMap_remissions* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_DepthMap_Initialize(Base_samples_DepthMap* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set timestamps */
	Base_samples_DepthMap_timestamps_Initialize((&(pVal->timestamps)));
	/*set vertical_projection */
	Base_samples_DepthMap_PROJECTION_TYPE_Initialize((&(pVal->vertical_projection)));
	/*set horizontal_projection */
	Base_samples_DepthMap_PROJECTION_TYPE_Initialize((&(pVal->horizontal_projection)));
	/*set vertical_interval */
	Base_samples_DepthMap_vertical_interval_Initialize((&(pVal->vertical_interval)));
	/*set horizontal_interval */
	Base_samples_DepthMap_horizontal_interval_Initialize((&(pVal->horizontal_interval)));
	/*set vertical_size */
	T_UInt32_Initialize((&(pVal->vertical_size)));
	/*set horizontal_size */
	T_UInt32_Initialize((&(pVal->horizontal_size)));
	/*set distances */
	Base_samples_DepthMap_distances_Initialize((&(pVal->distances)));
	/*set remissions */
	Base_samples_DepthMap_remissions_Initialize((&(pVal->remissions)));
}

flag Base_samples_DepthMap_IsConstraintValid(const Base_samples_DepthMap* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->timestamps.nCount) && (pVal->timestamps.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS; 
    if (ret) {
        ret = (((pVal->vertical_projection == base_samples_depthmap_projection_type_planar)) || ((pVal->vertical_projection == base_samples_depthmap_projection_type_polar)));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_PROJECTION; 
        if (ret) {
            ret = (((pVal->horizontal_projection == base_samples_depthmap_projection_type_planar)) || ((pVal->horizontal_projection == base_samples_depthmap_projection_type_polar)));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_PROJECTION; 
            if (ret) {
                ret = ((1 <= pVal->vertical_interval.nCount) && (pVal->vertical_interval.nCount <= 200));
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL; 
                if (ret) {
                    for(i1 = 0; ret && i1 < pVal->vertical_interval.nCount; i1++) 
                    {
                    	ret = ((-1.79769313486231570000E+308 <= pVal->vertical_interval.arr[i1]) && (pVal->vertical_interval.arr[i1] <= 1.79769313486231570000E+308));
                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL_ELM; 
                    }
                }
                if (ret) {
                    ret = ((1 <= pVal->horizontal_interval.nCount) && (pVal->horizontal_interval.nCount <= 200));
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL; 
                    if (ret) {
                        for(i1 = 0; ret && i1 < pVal->horizontal_interval.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->horizontal_interval.arr[i1]) && (pVal->horizontal_interval.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL_ELM; 
                        }
                    }
                    if (ret) {
                        ret = (pVal->vertical_size <= 4294967295UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_VERTICAL_SIZE; 
                        if (ret) {
                            ret = (pVal->horizontal_size <= 4294967295UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_SIZE; 
                            if (ret) {
                                ret = ((1 <= pVal->distances.nCount) && (pVal->distances.nCount <= 200));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES; 
                                if (ret) {
                                    for(i1 = 0; ret && i1 < pVal->distances.nCount; i1++) 
                                    {
                                    	ret = ((-3.40282346600000020000E+038 <= pVal->distances.arr[i1]) && (pVal->distances.arr[i1] <= 3.40282346600000020000E+038));
                                    	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_DISTANCES_ELM; 
                                    }
                                }
                                if (ret) {
                                    ret = ((1 <= pVal->remissions.nCount) && (pVal->remissions.nCount <= 200));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS; 
                                    if (ret) {
                                        for(i1 = 0; ret && i1 < pVal->remissions.nCount; i1++) 
                                        {
                                        	ret = ((-3.40282346600000020000E+038 <= pVal->remissions.arr[i1]) && (pVal->remissions.arr[i1] <= 3.40282346600000020000E+038));
                                        	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_REMISSIONS_ELM; 
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_DepthMap_Encode(const Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_DepthMap_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode timestamps */
	        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->timestamps.nCount, 1, 200);
	        	
	        for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	        {
	        	ret = Base_Time_Encode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode, FALSE);
	        }
	        if (ret) {
	            /*Encode vertical_projection */
	            ret = Base_samples_DepthMap_PROJECTION_TYPE_Encode((&(pVal->vertical_projection)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode horizontal_projection */
	                ret = Base_samples_DepthMap_PROJECTION_TYPE_Encode((&(pVal->horizontal_projection)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode vertical_interval */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertical_interval.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++) 
	                    {
	                    	ret = T_Double_Encode((&(pVal->vertical_interval.arr[i1])), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode horizontal_interval */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->horizontal_interval.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++) 
	                        {
	                        	ret = T_Double_Encode((&(pVal->horizontal_interval.arr[i1])), pBitStrm, pErrCode, FALSE);
	                        }
	                        if (ret) {
	                            /*Encode vertical_size */
	                            ret = T_UInt32_Encode((&(pVal->vertical_size)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode horizontal_size */
	                                ret = T_UInt32_Encode((&(pVal->horizontal_size)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode distances */
	                                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->distances.nCount, 1, 200);
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++) 
	                                    {
	                                    	ret = T_Float_Encode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                    }
	                                    if (ret) {
	                                        /*Encode remissions */
	                                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->remissions.nCount, 1, 200);
	                                        	
	                                        for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++) 
	                                        {
	                                        	ret = T_Float_Encode((&(pVal->remissions.arr[i1])), pBitStrm, pErrCode, FALSE);
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_DepthMap_Decode(Base_samples_DepthMap* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode timestamps */
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_TIMESTAMPS;
	    pVal->timestamps.nCount = (long)nCount;
	    	
	    for(i1=0; (i1 < (int)pVal->timestamps.nCount) && ret; i1++) 
	    {
	    	ret = Base_Time_Decode((&(pVal->timestamps.arr[i1])), pBitStrm, pErrCode);
	    }
	    if (ret) {
	        /*Decode vertical_projection */
	        ret = Base_samples_DepthMap_PROJECTION_TYPE_Decode((&(pVal->vertical_projection)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode horizontal_projection */
	            ret = Base_samples_DepthMap_PROJECTION_TYPE_Decode((&(pVal->horizontal_projection)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode vertical_interval */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_VERTICAL_INTERVAL;
	                pVal->vertical_interval.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->vertical_interval.nCount) && ret; i1++) 
	                {
	                	ret = T_Double_Decode((&(pVal->vertical_interval.arr[i1])), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode horizontal_interval */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_HORIZONTAL_INTERVAL;
	                    pVal->horizontal_interval.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->horizontal_interval.nCount) && ret; i1++) 
	                    {
	                    	ret = T_Double_Decode((&(pVal->horizontal_interval.arr[i1])), pBitStrm, pErrCode);
	                    }
	                    if (ret) {
	                        /*Decode vertical_size */
	                        ret = T_UInt32_Decode((&(pVal->vertical_size)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode horizontal_size */
	                            ret = T_UInt32_Decode((&(pVal->horizontal_size)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode distances */
	                                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_DISTANCES;
	                                pVal->distances.nCount = (long)nCount;
	                                	
	                                for(i1=0; (i1 < (int)pVal->distances.nCount) && ret; i1++) 
	                                {
	                                	ret = T_Float_Decode((&(pVal->distances.arr[i1])), pBitStrm, pErrCode);
	                                }
	                                if (ret) {
	                                    /*Decode remissions */
	                                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_REMISSIONS;
	                                    pVal->remissions.nCount = (long)nCount;
	                                    	
	                                    for(i1=0; (i1 < (int)pVal->remissions.nCount) && ret; i1++) 
	                                    {
	                                    	ret = T_Float_Decode((&(pVal->remissions.arr[i1])), pBitStrm, pErrCode);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_DepthMap_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_DepthMap_UNIT_AXIS_Initialize(Base_samples_DepthMap_UNIT_AXIS* pVal)
{

	(*(pVal)) = base_samples_depthmap_unit_axis_unit_x;
}

flag Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(const Base_samples_DepthMap_UNIT_AXIS* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((*(pVal)) == base_samples_depthmap_unit_axis_unit_x)) || (((*(pVal)) == base_samples_depthmap_unit_axis_unit_y)))) || (((*(pVal)) == base_samples_depthmap_unit_axis_unit_z)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS; 

	return ret;
}

flag Base_samples_DepthMap_UNIT_AXIS_Encode(const Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_samples_depthmap_unit_axis_unit_x:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case base_samples_depthmap_unit_axis_unit_y:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case base_samples_depthmap_unit_axis_unit_z:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_DepthMap_UNIT_AXIS_Decode(Base_samples_DepthMap_UNIT_AXIS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_x;
	                break;
	            case 1: 
	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_y;
	                break;
	            case 2: 
	                (*(pVal)) = base_samples_depthmap_unit_axis_unit_z;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_DEPTHMAP_UNIT_AXIS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_samples_depthmap_unit_axis_unit_x;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_samples_DepthMap_UNIT_AXIS_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_LASER_RANGE_ERRORS_Initialize(Base_samples_LASER_RANGE_ERRORS* pVal)
{

	(*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;
}

flag Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(const Base_samples_LASER_RANGE_ERRORS* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((*(pVal)) == base_samples_laser_range_errors_end_laser_range_errors)) || (((*(pVal)) == base_samples_laser_range_errors_max_range_error)))) || (((*(pVal)) == base_samples_laser_range_errors_measurement_error)))) || (((*(pVal)) == base_samples_laser_range_errors_other_range_errors)))) || (((*(pVal)) == base_samples_laser_range_errors_too_far)))) || (((*(pVal)) == base_samples_laser_range_errors_too_near)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_LASER_RANGE_ERRORS; 

	return ret;
}

flag Base_samples_LASER_RANGE_ERRORS_Encode(const Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_samples_laser_range_errors_end_laser_range_errors:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 5);
	        	break;
	        case base_samples_laser_range_errors_max_range_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 5);
	        	break;
	        case base_samples_laser_range_errors_measurement_error:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 5);
	        	break;
	        case base_samples_laser_range_errors_other_range_errors:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 5);
	        	break;
	        case base_samples_laser_range_errors_too_far:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 5);
	        	break;
	        case base_samples_laser_range_errors_too_near:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 5);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_LASER_RANGE_ERRORS; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_LASER_RANGE_ERRORS_Decode(Base_samples_LASER_RANGE_ERRORS* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 5);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;
	                break;
	            case 1: 
	                (*(pVal)) = base_samples_laser_range_errors_max_range_error;
	                break;
	            case 2: 
	                (*(pVal)) = base_samples_laser_range_errors_measurement_error;
	                break;
	            case 3: 
	                (*(pVal)) = base_samples_laser_range_errors_other_range_errors;
	                break;
	            case 4: 
	                (*(pVal)) = base_samples_laser_range_errors_too_far;
	                break;
	            case 5: 
	                (*(pVal)) = base_samples_laser_range_errors_too_near;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_LASER_RANGE_ERRORS;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_samples_laser_range_errors_end_laser_range_errors;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_samples_LASER_RANGE_ERRORS_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_frame_frame_mode_t_Initialize(Base_samples_frame_frame_mode_t* pVal)
{

	(*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;
}

flag Base_samples_frame_frame_mode_t_IsConstraintValid(const Base_samples_frame_frame_mode_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((((((((((((((((((((((((*(pVal)) == base_samples_frame_frame_mode_t_compressed_modes)) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_bgr)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_grayscale)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_jpeg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_pjpg)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_png)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_rgb)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_rgb32)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_undefined)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_mode_uyvy)))) || (((*(pVal)) == base_samples_frame_frame_mode_t_raw_modes)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_MODE_T; 

	return ret;
}

flag Base_samples_frame_frame_mode_t_Encode(const Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_samples_frame_frame_mode_t_compressed_modes:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_bayer:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_bayer_bggr:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_bayer_gbrg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_bayer_grbg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_bayer_rggb:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 5, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_bgr:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 6, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_grayscale:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 7, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_jpeg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 8, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_pjpg:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 9, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_png:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 10, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_rgb:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 11, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_rgb32:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 12, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_undefined:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 13, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_mode_uyvy:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 14, 0, 15);
	        	break;
	        case base_samples_frame_frame_mode_t_raw_modes:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 15, 0, 15);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_MODE_T; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_frame_frame_mode_t_Decode(Base_samples_frame_frame_mode_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 15);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;
	                break;
	            case 1: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer;
	                break;
	            case 2: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_bggr;
	                break;
	            case 3: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_gbrg;
	                break;
	            case 4: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_grbg;
	                break;
	            case 5: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bayer_rggb;
	                break;
	            case 6: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_bgr;
	                break;
	            case 7: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_grayscale;
	                break;
	            case 8: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_jpeg;
	                break;
	            case 9: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_pjpg;
	                break;
	            case 10: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_png;
	                break;
	            case 11: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_rgb;
	                break;
	            case 12: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_rgb32;
	                break;
	            case 13: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_undefined;
	                break;
	            case 14: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_mode_uyvy;
	                break;
	            case 15: 
	                (*(pVal)) = base_samples_frame_frame_mode_t_raw_modes;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_MODE_T;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_samples_frame_frame_mode_t_compressed_modes;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_samples_frame_frame_mode_t_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_frame_frame_status_t_Initialize(Base_samples_frame_frame_status_t* pVal)
{

	(*(pVal)) = base_samples_frame_frame_status_t_status_empty;
}

flag Base_samples_frame_frame_status_t_IsConstraintValid(const Base_samples_frame_frame_status_t* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((*(pVal)) == base_samples_frame_frame_status_t_status_empty)) || (((*(pVal)) == base_samples_frame_frame_status_t_status_invalid)))) || (((*(pVal)) == base_samples_frame_frame_status_t_status_valid)));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_STATUS_T; 

	return ret;
}

flag Base_samples_frame_frame_status_t_Encode(const Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case base_samples_frame_frame_status_t_status_empty:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 2);
	        	break;
	        case base_samples_frame_frame_status_t_status_invalid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 2);
	        	break;
	        case base_samples_frame_frame_status_t_status_valid:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 2);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_frame_frame_status_t_Decode(Base_samples_frame_frame_status_t* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 2);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = base_samples_frame_frame_status_t_status_empty;
	                break;
	            case 1: 
	                (*(pVal)) = base_samples_frame_frame_status_t_status_invalid;
	                break;
	            case 2: 
	                (*(pVal)) = base_samples_frame_frame_status_t_status_valid;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_STATUS_T;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = base_samples_frame_frame_status_t_status_empty;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Base_samples_frame_frame_status_t_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_frame_Frame_image_Initialize(Base_samples_frame_Frame_image* pVal)
{

	memset(pVal->arr, 0x0, 200);
	pVal->nCount = 1;

}
void Base_samples_frame_Frame_attributes_Initialize(Base_samples_frame_Frame_attributes* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_samples_frame_frame_attrib_t_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Base_samples_frame_Frame_Initialize(Base_samples_frame_Frame* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set received_time */
	Base_Time_Initialize((&(pVal->received_time)));
	/*set image */
	Base_samples_frame_Frame_image_Initialize((&(pVal->image)));
	/*set attributes */
	Base_samples_frame_Frame_attributes_Initialize((&(pVal->attributes)));
	/*set size_val */
	Base_samples_frame_frame_size_t_Initialize((&(pVal->size_val)));
	/*set data_depth */
	T_UInt32_Initialize((&(pVal->data_depth)));
	/*set pixel_size */
	T_UInt32_Initialize((&(pVal->pixel_size)));
	/*set row_size */
	T_UInt32_Initialize((&(pVal->row_size)));
	/*set frame_mode */
	Base_samples_frame_frame_mode_t_Initialize((&(pVal->frame_mode)));
	/*set frame_status */
	Base_samples_frame_frame_status_t_Initialize((&(pVal->frame_status)));
}

flag Base_samples_frame_Frame_IsConstraintValid(const Base_samples_frame_Frame* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->image.nCount) && (pVal->image.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_IMAGE; 
    if (ret) {
        ret = ((1 <= pVal->attributes.nCount) && (pVal->attributes.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->attributes.nCount; i1++) 
            {
            	ret = (pVal->attributes.arr[i1].data.nCount <= 40);
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_DATA; 
            	if (ret) {
            	    ret = (pVal->attributes.arr[i1].name_val.nCount <= 40);
            	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES_ELM_NAME_VAL; 
            	}
            }
        }
        if (ret) {
            ret = (pVal->size_val.width <= 65535UL);
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_WIDTH; 
            if (ret) {
                ret = (pVal->size_val.height <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_SIZE_VAL_HEIGHT; 
            }
            if (ret) {
                ret = (pVal->data_depth <= 4294967295UL);
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_DATA_DEPTH; 
                if (ret) {
                    ret = (pVal->pixel_size <= 4294967295UL);
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_PIXEL_SIZE; 
                    if (ret) {
                        ret = (pVal->row_size <= 4294967295UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_ROW_SIZE; 
                        if (ret) {
                            ret = (((((((((((((((((((((((((((((((pVal->frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_MODE; 
                            if (ret) {
                                ret = (((((pVal->frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->frame_status == base_samples_frame_frame_status_t_status_valid)));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAME_FRAME_STATUS; 
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_samples_frame_Frame_Encode(const Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Base_samples_frame_Frame_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode received_time */
	        ret = Base_Time_Encode((&(pVal->received_time)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode image */
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->image.nCount, 1, 200);
	            	
	            for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++) 
	            {
	            	BitStream_AppendByte0(pBitStrm, pVal->image.arr[i1]);
	            }
	            if (ret) {
	                /*Encode attributes */
	                BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->attributes.nCount, 1, 200);
	                	
	                for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++) 
	                {
	                	ret = Base_samples_frame_frame_attrib_t_Encode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode, FALSE);
	                }
	                if (ret) {
	                    /*Encode size_val */
	                    ret = Base_samples_frame_frame_size_t_Encode((&(pVal->size_val)), pBitStrm, pErrCode, FALSE);
	                    if (ret) {
	                        /*Encode data_depth */
	                        ret = T_UInt32_Encode((&(pVal->data_depth)), pBitStrm, pErrCode, FALSE);
	                        if (ret) {
	                            /*Encode pixel_size */
	                            ret = T_UInt32_Encode((&(pVal->pixel_size)), pBitStrm, pErrCode, FALSE);
	                            if (ret) {
	                                /*Encode row_size */
	                                ret = T_UInt32_Encode((&(pVal->row_size)), pBitStrm, pErrCode, FALSE);
	                                if (ret) {
	                                    /*Encode frame_mode */
	                                    ret = Base_samples_frame_frame_mode_t_Encode((&(pVal->frame_mode)), pBitStrm, pErrCode, FALSE);
	                                    if (ret) {
	                                        /*Encode frame_status */
	                                        ret = Base_samples_frame_frame_status_t_Encode((&(pVal->frame_status)), pBitStrm, pErrCode, FALSE);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_frame_Frame_Decode(Base_samples_frame_Frame* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode received_time */
	    ret = Base_Time_Decode((&(pVal->received_time)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode image */
	        ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	        *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
	        pVal->image.nCount = (long)nCount;
	        	
	        for(i1=0; (i1 < (int)pVal->image.nCount) && ret; i1++) 
	        {
	        	ret = BitStream_ReadByte(pBitStrm, &(pVal->image.arr[i1])); 
	        	*pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_IMAGE;
	        }
	        if (ret) {
	            /*Decode attributes */
	            ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	            *pErrCode = ret ? 0 : ERR_UPER_DECODE_BASE_SAMPLES_FRAME_FRAME_ATTRIBUTES;
	            pVal->attributes.nCount = (long)nCount;
	            	
	            for(i1=0; (i1 < (int)pVal->attributes.nCount) && ret; i1++) 
	            {
	            	ret = Base_samples_frame_frame_attrib_t_Decode((&(pVal->attributes.arr[i1])), pBitStrm, pErrCode);
	            }
	            if (ret) {
	                /*Decode size_val */
	                ret = Base_samples_frame_frame_size_t_Decode((&(pVal->size_val)), pBitStrm, pErrCode);
	                if (ret) {
	                    /*Decode data_depth */
	                    ret = T_UInt32_Decode((&(pVal->data_depth)), pBitStrm, pErrCode);
	                    if (ret) {
	                        /*Decode pixel_size */
	                        ret = T_UInt32_Decode((&(pVal->pixel_size)), pBitStrm, pErrCode);
	                        if (ret) {
	                            /*Decode row_size */
	                            ret = T_UInt32_Decode((&(pVal->row_size)), pBitStrm, pErrCode);
	                            if (ret) {
	                                /*Decode frame_mode */
	                                ret = Base_samples_frame_frame_mode_t_Decode((&(pVal->frame_mode)), pBitStrm, pErrCode);
	                                if (ret) {
	                                    /*Decode frame_status */
	                                    ret = Base_samples_frame_frame_status_t_Decode((&(pVal->frame_status)), pBitStrm, pErrCode);
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Base_samples_frame_Frame_IsConstraintValid(pVal, pErrCode);
}



void Base_samples_frame_FramePair_Initialize(Base_samples_frame_FramePair* pVal)
{


	/*set time */
	Base_Time_Initialize((&(pVal->time)));
	/*set first */
	Base_samples_frame_Frame_Initialize((&(pVal->first)));
	/*set second */
	Base_samples_frame_Frame_Initialize((&(pVal->second)));
	/*set id */
	T_UInt32_Initialize((&(pVal->id)));
}

flag Base_samples_frame_FramePair_IsConstraintValid(const Base_samples_frame_FramePair* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((1 <= pVal->first.image.nCount) && (pVal->first.image.nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_IMAGE; 
    if (ret) {
        ret = ((1 <= pVal->first.attributes.nCount) && (pVal->first.attributes.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES; 
        if (ret) {
            for(i1 = 0; ret && i1 < pVal->first.attributes.nCount; i1++) 
            {
            	ret = (pVal->first.attributes.arr[i1].data.nCount <= 40);
            	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_DATA; 
            	if (ret) {
            	    ret = (pVal->first.attributes.arr[i1].name_val.nCount <= 40);
            	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ATTRIBUTES_ELM_NAME_VAL; 
            	}
            }
        }
        if (ret) {
            ret = (pVal->first.size_val.width <= 65535UL);
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_WIDTH; 
            if (ret) {
                ret = (pVal->first.size_val.height <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_SIZE_VAL_HEIGHT; 
            }
            if (ret) {
                ret = (pVal->first.data_depth <= 4294967295UL);
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_DATA_DEPTH; 
                if (ret) {
                    ret = (pVal->first.pixel_size <= 4294967295UL);
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_PIXEL_SIZE; 
                    if (ret) {
                        ret = (pVal->first.row_size <= 4294967295UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_ROW_SIZE; 
                        if (ret) {
                            ret = (((((((((((((((((((((((((((((((pVal->first.frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->first.frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_MODE; 
                            if (ret) {
                                ret = (((((pVal->first.frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->first.frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->first.frame_status == base_samples_frame_frame_status_t_status_valid)));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_FIRST_FRAME_STATUS; 
                            }
                        }
                    }
                }
            }
        }
    }
    if (ret) {
        ret = ((1 <= pVal->second.image.nCount) && (pVal->second.image.nCount <= 200));
        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_IMAGE; 
        if (ret) {
            ret = ((1 <= pVal->second.attributes.nCount) && (pVal->second.attributes.nCount <= 200));
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES; 
            if (ret) {
                for(i1 = 0; ret && i1 < pVal->second.attributes.nCount; i1++) 
                {
                	ret = (pVal->second.attributes.arr[i1].data.nCount <= 40);
                	*pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_DATA; 
                	if (ret) {
                	    ret = (pVal->second.attributes.arr[i1].name_val.nCount <= 40);
                	    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ATTRIBUTES_ELM_NAME_VAL; 
                	}
                }
            }
            if (ret) {
                ret = (pVal->second.size_val.width <= 65535UL);
                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_WIDTH; 
                if (ret) {
                    ret = (pVal->second.size_val.height <= 65535UL);
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_SIZE_VAL_HEIGHT; 
                }
                if (ret) {
                    ret = (pVal->second.data_depth <= 4294967295UL);
                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_DATA_DEPTH; 
                    if (ret) {
                        ret = (pVal->second.pixel_size <= 4294967295UL);
                        *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_PIXEL_SIZE; 
                        if (ret) {
                            ret = (pVal->second.row_size <= 4294967295UL);
                            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_ROW_SIZE; 
                            if (ret) {
                                ret = (((((((((((((((((((((((((((((((pVal->second.frame_mode == base_samples_frame_frame_mode_t_compressed_modes)) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_bggr)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_gbrg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_grbg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bayer_rggb)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_bgr)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_grayscale)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_jpeg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_pjpg)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_png)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_rgb)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_rgb32)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_undefined)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_mode_uyvy)))) || ((pVal->second.frame_mode == base_samples_frame_frame_mode_t_raw_modes)));
                                *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_MODE; 
                                if (ret) {
                                    ret = (((((pVal->second.frame_status == base_samples_frame_frame_status_t_status_empty)) || ((pVal->second.frame_status == base_samples_frame_frame_status_t_status_invalid)))) || ((pVal->second.frame_status == base_samples_frame_frame_status_t_status_valid)));
                                    *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_SECOND_FRAME_STATUS; 
                                }
                            }
                        }
                    }
                }
            }
        }
        if (ret) {
            ret = (pVal->id <= 4294967295UL);
            *pErrCode = ret ? 0 :  ERR_BASE_SAMPLES_FRAME_FRAMEPAIR_ID; 
        }
    }

	return ret;
}

flag Base_samples_frame_FramePair_Encode(const Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode time */
	    ret = Base_Time_Encode((&(pVal->time)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode first */
	        ret = Base_samples_frame_Frame_Encode((&(pVal->first)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode second */
	            ret = Base_samples_frame_Frame_Encode((&(pVal->second)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode id */
	                ret = T_UInt32_Encode((&(pVal->id)), pBitStrm, pErrCode, FALSE);
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_samples_frame_FramePair_Decode(Base_samples_frame_FramePair* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode time */
	ret = Base_Time_Decode((&(pVal->time)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode first */
	    ret = Base_samples_frame_Frame_Decode((&(pVal->first)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode second */
	        ret = Base_samples_frame_Frame_Decode((&(pVal->second)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode id */
	            ret = T_UInt32_Decode((&(pVal->id)), pBitStrm, pErrCode);
	        }
	    }
	}

	return ret  && Base_samples_frame_FramePair_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_geometry_SplineType_Initialize(Wrappers_geometry_SplineType* pVal)
{

	(*(pVal)) = wrappers_geometry_splinetype_degenerate;
}

flag Wrappers_geometry_SplineType_IsConstraintValid(const Wrappers_geometry_SplineType* pVal, int* pErrCode)
{
    flag ret = TRUE;
	
    ret = ((((((((((*(pVal)) == wrappers_geometry_splinetype_degenerate)) || (((*(pVal)) == wrappers_geometry_splinetype_polynomial_bezier)))) || (((*(pVal)) == wrappers_geometry_splinetype_polynomial_bspline)))) || (((*(pVal)) == wrappers_geometry_splinetype_rational_bezier)))) || (((*(pVal)) == wrappers_geometry_splinetype_rational_bspline)));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINETYPE; 

	return ret;
}

flag Wrappers_geometry_SplineType_Encode(const Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Wrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    switch((*(pVal))) 
	    {
	        case wrappers_geometry_splinetype_degenerate:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 0, 0, 4);
	        	break;
	        case wrappers_geometry_splinetype_polynomial_bezier:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 1, 0, 4);
	        	break;
	        case wrappers_geometry_splinetype_polynomial_bspline:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 2, 0, 4);
	        	break;
	        case wrappers_geometry_splinetype_rational_bezier:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 3, 0, 4);
	        	break;
	        case wrappers_geometry_splinetype_rational_bspline:   
	            BitStream_EncodeConstraintWholeNumber(pBitStrm, 4, 0, 4);
	        	break;
	        default:                    /*COVERAGE_IGNORE*/
	    	    *pErrCode = ERR_UPER_ENCODE_WRAPPERS_GEOMETRY_SPLINETYPE; /*COVERAGE_IGNORE*/
	    	    ret = FALSE;            /*COVERAGE_IGNORE*/
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_geometry_SplineType_Decode(Wrappers_geometry_SplineType* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	{
	    asn1SccSint enumIndex;
	    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &enumIndex, 0, 4);
	    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;
	    if (ret) {
	        switch(enumIndex) 
	        {
	            case 0: 
	                (*(pVal)) = wrappers_geometry_splinetype_degenerate;
	                break;
	            case 1: 
	                (*(pVal)) = wrappers_geometry_splinetype_polynomial_bezier;
	                break;
	            case 2: 
	                (*(pVal)) = wrappers_geometry_splinetype_polynomial_bspline;
	                break;
	            case 3: 
	                (*(pVal)) = wrappers_geometry_splinetype_rational_bezier;
	                break;
	            case 4: 
	                (*(pVal)) = wrappers_geometry_splinetype_rational_bspline;
	                break;
	            default:                        /*COVERAGE_IGNORE*/
		            *pErrCode = ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINETYPE;     /*COVERAGE_IGNORE*/
		            ret = FALSE;                /*COVERAGE_IGNORE*/
	        }
	    } else {
	        (*(pVal)) = wrappers_geometry_splinetype_degenerate;             /*COVERAGE_IGNORE*/
	    }
	}

	return ret  && Wrappers_geometry_SplineType_IsConstraintValid(pVal, pErrCode);
}



void Wrappers_geometry_Spline_knots_Initialize(Wrappers_geometry_Spline_knots* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_geometry_Spline_vertices_Initialize(Wrappers_geometry_Spline_vertices* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    T_Double_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}
void Wrappers_geometry_Spline_Initialize(Wrappers_geometry_Spline* pVal)
{


	/*set geometric_resolution */
	T_Double_Initialize((&(pVal->geometric_resolution)));
	/*set dimension */
	T_Int32_Initialize((&(pVal->dimension)));
	/*set curve_order */
	T_Int32_Initialize((&(pVal->curve_order)));
	/*set kind */
	Wrappers_geometry_SplineType_Initialize((&(pVal->kind)));
	/*set knots */
	Wrappers_geometry_Spline_knots_Initialize((&(pVal->knots)));
	/*set vertices */
	Wrappers_geometry_Spline_vertices_Initialize((&(pVal->vertices)));
}

flag Wrappers_geometry_Spline_IsConstraintValid(const Wrappers_geometry_Spline* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->geometric_resolution) && (pVal->geometric_resolution <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_GEOMETRIC_RESOLUTION; 
    if (ret) {
        ret = ((-2147483648LL <= pVal->dimension) && (pVal->dimension <= 2147483647LL));
        *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_DIMENSION; 
        if (ret) {
            ret = ((-2147483648LL <= pVal->curve_order) && (pVal->curve_order <= 2147483647LL));
            *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_CURVE_ORDER; 
            if (ret) {
                ret = (((((((((pVal->kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->kind == wrappers_geometry_splinetype_rational_bspline)));
                *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KIND; 
                if (ret) {
                    ret = ((1 <= pVal->knots.nCount) && (pVal->knots.nCount <= 200));
                    *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS; 
                    if (ret) {
                        for(i1 = 0; ret && i1 < pVal->knots.nCount; i1++) 
                        {
                        	ret = ((-1.79769313486231570000E+308 <= pVal->knots.arr[i1]) && (pVal->knots.arr[i1] <= 1.79769313486231570000E+308));
                        	*pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_KNOTS_ELM; 
                        }
                    }
                    if (ret) {
                        ret = ((1 <= pVal->vertices.nCount) && (pVal->vertices.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES; 
                        if (ret) {
                            for(i1 = 0; ret && i1 < pVal->vertices.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->vertices.arr[i1]) && (pVal->vertices.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_WRAPPERS_GEOMETRY_SPLINE_VERTICES_ELM; 
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Wrappers_geometry_Spline_Encode(const Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Wrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode geometric_resolution */
	    ret = T_Double_Encode((&(pVal->geometric_resolution)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode dimension */
	        ret = T_Int32_Encode((&(pVal->dimension)), pBitStrm, pErrCode, FALSE);
	        if (ret) {
	            /*Encode curve_order */
	            ret = T_Int32_Encode((&(pVal->curve_order)), pBitStrm, pErrCode, FALSE);
	            if (ret) {
	                /*Encode kind */
	                ret = Wrappers_geometry_SplineType_Encode((&(pVal->kind)), pBitStrm, pErrCode, FALSE);
	                if (ret) {
	                    /*Encode knots */
	                    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->knots.nCount, 1, 200);
	                    	
	                    for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++) 
	                    {
	                    	ret = T_Double_Encode((&(pVal->knots.arr[i1])), pBitStrm, pErrCode, FALSE);
	                    }
	                    if (ret) {
	                        /*Encode vertices */
	                        BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->vertices.nCount, 1, 200);
	                        	
	                        for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++) 
	                        {
	                        	ret = T_Double_Encode((&(pVal->vertices.arr[i1])), pBitStrm, pErrCode, FALSE);
	                        }
	                    }
	                }
	            }
	        }
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Wrappers_geometry_Spline_Decode(Wrappers_geometry_Spline* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	/*Decode geometric_resolution */
	ret = T_Double_Decode((&(pVal->geometric_resolution)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode dimension */
	    ret = T_Int32_Decode((&(pVal->dimension)), pBitStrm, pErrCode);
	    if (ret) {
	        /*Decode curve_order */
	        ret = T_Int32_Decode((&(pVal->curve_order)), pBitStrm, pErrCode);
	        if (ret) {
	            /*Decode kind */
	            ret = Wrappers_geometry_SplineType_Decode((&(pVal->kind)), pBitStrm, pErrCode);
	            if (ret) {
	                /*Decode knots */
	                ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_KNOTS;
	                pVal->knots.nCount = (long)nCount;
	                	
	                for(i1=0; (i1 < (int)pVal->knots.nCount) && ret; i1++) 
	                {
	                	ret = T_Double_Decode((&(pVal->knots.arr[i1])), pBitStrm, pErrCode);
	                }
	                if (ret) {
	                    /*Decode vertices */
	                    ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	                    *pErrCode = ret ? 0 : ERR_UPER_DECODE_WRAPPERS_GEOMETRY_SPLINE_VERTICES;
	                    pVal->vertices.nCount = (long)nCount;
	                    	
	                    for(i1=0; (i1 < (int)pVal->vertices.nCount) && ret; i1++) 
	                    {
	                    	ret = T_Double_Decode((&(pVal->vertices.arr[i1])), pBitStrm, pErrCode);
	                    }
	                }
	            }
	        }
	    }
	}

	return ret  && Wrappers_geometry_Spline_IsConstraintValid(pVal, pErrCode);
}



void Base_Trajectory_Initialize(Base_Trajectory* pVal)
{


	/*set speed */
	T_Double_Initialize((&(pVal->speed)));
	/*set spline */
	Wrappers_geometry_Spline_Initialize((&(pVal->spline)));
}

flag Base_Trajectory_IsConstraintValid(const Base_Trajectory* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPEED; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->spline.geometric_resolution) && (pVal->spline.geometric_resolution <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_GEOMETRIC_RESOLUTION; 
        if (ret) {
            ret = ((-2147483648LL <= pVal->spline.dimension) && (pVal->spline.dimension <= 2147483647LL));
            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_DIMENSION; 
            if (ret) {
                ret = ((-2147483648LL <= pVal->spline.curve_order) && (pVal->spline.curve_order <= 2147483647LL));
                *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_CURVE_ORDER; 
                if (ret) {
                    ret = (((((((((pVal->spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bspline)));
                    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KIND; 
                    if (ret) {
                        ret = ((1 <= pVal->spline.knots.nCount) && (pVal->spline.knots.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KNOTS; 
                        if (ret) {
                            for(i1 = 0; ret && i1 < pVal->spline.knots.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->spline.knots.arr[i1]) && (pVal->spline.knots.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_KNOTS_ELM; 
                            }
                        }
                        if (ret) {
                            ret = ((1 <= pVal->spline.vertices.nCount) && (pVal->spline.vertices.nCount <= 200));
                            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_VERTICES; 
                            if (ret) {
                                for(i1 = 0; ret && i1 < pVal->spline.vertices.nCount; i1++) 
                                {
                                	ret = ((-1.79769313486231570000E+308 <= pVal->spline.vertices.arr[i1]) && (pVal->spline.vertices.arr[i1] <= 1.79769313486231570000E+308));
                                	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_SPLINE_VERTICES_ELM; 
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_Trajectory_Encode(const Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speed */
	    ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode spline */
	        ret = Wrappers_geometry_Spline_Encode((&(pVal->spline)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Trajectory_Decode(Base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode speed */
	ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode spline */
	    ret = Wrappers_geometry_Spline_Decode((&(pVal->spline)), pBitStrm, pErrCode);
	}

	return ret  && Base_Trajectory_IsConstraintValid(pVal, pErrCode);
}



void Base_Trajectory_m_Initialize(Base_Trajectory_m* pVal)
{


	/*set speed */
	T_Double_Initialize((&(pVal->speed)));
	/*set spline */
	Wrappers_geometry_Spline_Initialize((&(pVal->spline)));
}

flag Base_Trajectory_m_IsConstraintValid(const Base_Trajectory_m* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
	
    ret = ((-1.79769313486231570000E+308 <= pVal->speed) && (pVal->speed <= 1.79769313486231570000E+308));
    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPEED; 
    if (ret) {
        ret = ((-1.79769313486231570000E+308 <= pVal->spline.geometric_resolution) && (pVal->spline.geometric_resolution <= 1.79769313486231570000E+308));
        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_GEOMETRIC_RESOLUTION; 
        if (ret) {
            ret = ((-2147483648LL <= pVal->spline.dimension) && (pVal->spline.dimension <= 2147483647LL));
            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_DIMENSION; 
            if (ret) {
                ret = ((-2147483648LL <= pVal->spline.curve_order) && (pVal->spline.curve_order <= 2147483647LL));
                *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_CURVE_ORDER; 
                if (ret) {
                    ret = (((((((((pVal->spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->spline.kind == wrappers_geometry_splinetype_rational_bspline)));
                    *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KIND; 
                    if (ret) {
                        ret = ((1 <= pVal->spline.knots.nCount) && (pVal->spline.knots.nCount <= 200));
                        *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS; 
                        if (ret) {
                            for(i1 = 0; ret && i1 < pVal->spline.knots.nCount; i1++) 
                            {
                            	ret = ((-1.79769313486231570000E+308 <= pVal->spline.knots.arr[i1]) && (pVal->spline.knots.arr[i1] <= 1.79769313486231570000E+308));
                            	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_KNOTS_ELM; 
                            }
                        }
                        if (ret) {
                            ret = ((1 <= pVal->spline.vertices.nCount) && (pVal->spline.vertices.nCount <= 200));
                            *pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES; 
                            if (ret) {
                                for(i1 = 0; ret && i1 < pVal->spline.vertices.nCount; i1++) 
                                {
                                	ret = ((-1.79769313486231570000E+308 <= pVal->spline.vertices.arr[i1]) && (pVal->spline.vertices.arr[i1] <= 1.79769313486231570000E+308));
                                	*pErrCode = ret ? 0 :  ERR_BASE_TRAJECTORY_M_SPLINE_VERTICES_ELM; 
                                }
                            }
                        }
                    }
                }
            }
        }
    }

	return ret;
}

flag Base_Trajectory_m_Encode(const Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	ret = bCheckConstraints ? Base_Trajectory_m_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    /*Encode speed */
	    ret = T_Double_Encode((&(pVal->speed)), pBitStrm, pErrCode, FALSE);
	    if (ret) {
	        /*Encode spline */
	        ret = Wrappers_geometry_Spline_Encode((&(pVal->spline)), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Base_Trajectory_m_Decode(Base_Trajectory_m* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;

	/*Decode speed */
	ret = T_Double_Decode((&(pVal->speed)), pBitStrm, pErrCode);
	if (ret) {
	    /*Decode spline */
	    ret = Wrappers_geometry_Spline_Decode((&(pVal->spline)), pBitStrm, pErrCode);
	}

	return ret  && Base_Trajectory_m_IsConstraintValid(pVal, pErrCode);
}



void Std_orogen_typekits_mtype_std_vector_base_Trajectory_Initialize(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal)
{
    int i1;

	i1 = 0;
	while (i1< 200) {
	    Base_Trajectory_m_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}
	pVal->nCount = 1;
}

flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    int i2;
	
    ret = ((1 <= pVal->nCount) && (pVal->nCount <= 200));
    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY; 
    if (ret) {
        for(i1 = 0; ret && i1 < pVal->nCount; i1++) 
        {
        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].speed) && (pVal->arr[i1].speed <= 1.79769313486231570000E+308));
        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPEED; 
        	if (ret) {
        	    ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.geometric_resolution) && (pVal->arr[i1].spline.geometric_resolution <= 1.79769313486231570000E+308));
        	    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_GEOMETRIC_RESOLUTION; 
        	    if (ret) {
        	        ret = ((-2147483648LL <= pVal->arr[i1].spline.dimension) && (pVal->arr[i1].spline.dimension <= 2147483647LL));
        	        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_DIMENSION; 
        	        if (ret) {
        	            ret = ((-2147483648LL <= pVal->arr[i1].spline.curve_order) && (pVal->arr[i1].spline.curve_order <= 2147483647LL));
        	            *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_CURVE_ORDER; 
        	            if (ret) {
        	                ret = (((((((((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_degenerate)) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_polynomial_bezier)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_polynomial_bspline)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_rational_bezier)))) || ((pVal->arr[i1].spline.kind == wrappers_geometry_splinetype_rational_bspline)));
        	                *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KIND; 
        	                if (ret) {
        	                    ret = ((1 <= pVal->arr[i1].spline.knots.nCount) && (pVal->arr[i1].spline.knots.nCount <= 200));
        	                    *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS; 
        	                    if (ret) {
        	                        for(i2 = 0; ret && i2 < pVal->arr[i1].spline.knots.nCount; i2++) 
        	                        {
        	                        	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.knots.arr[i2]) && (pVal->arr[i1].spline.knots.arr[i2] <= 1.79769313486231570000E+308));
        	                        	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_KNOTS_ELM; 
        	                        }
        	                    }
        	                    if (ret) {
        	                        ret = ((1 <= pVal->arr[i1].spline.vertices.nCount) && (pVal->arr[i1].spline.vertices.nCount <= 200));
        	                        *pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES; 
        	                        if (ret) {
        	                            for(i2 = 0; ret && i2 < pVal->arr[i1].spline.vertices.nCount; i2++) 
        	                            {
        	                            	ret = ((-1.79769313486231570000E+308 <= pVal->arr[i1].spline.vertices.arr[i2]) && (pVal->arr[i1].spline.vertices.arr[i2] <= 1.79769313486231570000E+308));
        	                            	*pErrCode = ret ? 0 :  ERR_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY_ELM_SPLINE_VERTICES_ELM; 
        	                            }
        	                        }
        	                    }
        	                }
        	            }
        	        }
        	    }
        	}
        }
    }

	return ret;
}

flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Encode(const Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	int i1;
	ret = bCheckConstraints ? Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, pVal->nCount, 1, 200);
	    	
	    for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	    {
	    	ret = Base_Trajectory_m_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag Std_orogen_typekits_mtype_std_vector_base_Trajectory_Decode(Std_orogen_typekits_mtype_std_vector_base_Trajectory* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	int i1;
	asn1SccSint nCount;

	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, &nCount, 1, 200);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_STD_OROGEN_TYPEKITS_MTYPE_STD_VECTOR_BASE_TRAJECTORY;
	pVal->nCount = (long)nCount;
		
	for(i1=0; (i1 < (int)pVal->nCount) && ret; i1++) 
	{
		ret = Base_Trajectory_m_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && Std_orogen_typekits_mtype_std_vector_base_Trajectory_IsConstraintValid(pVal, pErrCode);
}

